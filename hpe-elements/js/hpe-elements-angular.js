/*! 
* HPEElementsAngular - v3.4.0 
* Â© Copyright 2016  Hewlett Packard Enterprise Development Company LP
 */
(function () {

  angular.module('hpe.elements.affixElement', []).directive('affixElement', ['$window', affixElement]);

  function affixElement($window) {
    return {
      restrict: 'A',
      scope: {
        scrolloffset: '=affixPosition'
      },
      link: function (scope, element) {
        var win = angular.element($window);
        var scrolloffset = (typeof scope.scrolloffset !== "undefined") ? scope.scrolloffset : 0; // Default value is zero.
        var affixElement = new AffixedElement(element, scrolloffset);
        var body = angular.element('body');

        //Added this code to hide the menu button when there is a condensed toolbar
        //Menu button should only appear in the top header.
        //If there is a better solution this should be removed in the future.

        if (element.parent().hasClass('toolbar')) {
          body.addClass('hide-navbar-toolbar');
        } else {
          body.removeClass('hide-navbar-toolbar');
        }

        if (!element.hasClass('condensed')) {
          body.removeClass('condensed-panel');
        }

        //Affix is set on scrolling.
        var affixOnScrollEventHandler = function () {
          affixElement.currentScrollPosition = win.scrollTop();
        };

        win.on('scroll.affix', undefined, affixOnScrollEventHandler);

        var updateAffix = function () {
          affixElement.update(scope, body);
        };

        window.addEventListener('scroll', updateAffix);

        scope.$on("$destroy", function () {
          win.off("scroll.affix", undefined, affixOnScrollEventHandler);
          window.removeEventListener('scroll', updateAffix);
        });
      }
    };
  }

  function AffixedElement(element, offset) {

    //element to make stick
    this.element = element;
    this.nativeElement = this.element.get(0);
    this.nativeElement.classList.add("affix-element");
    this.nativeElement.classList.add("affix-clone");
    //scroll position at which to trigger the stick
    this.trigger = this.element.offset().top;
    this.initialTop = this.element.css('top');
    //offset at which to position the fixed element from the top
    //this will normally be 0 but on the off chance teams want something custom.
    this.offset = offset;
    //whether the element is affixed or not.
    this.affixed = false;
    this.headerHeight = null;

    //previous values
    //we must keep track of previous values as if they change we must update UI elements
    //previous scrollPosition
    this.previousScrollPosition = 0;
    //current scrollPosition - will be updated by event handler outside this object
    this.currentScrollPosition = 0;
  }
  /*
   * # Creates the clone element
   * creates the clone element and prepends it to parent
   * also then updates the clone elements height to the current height of element
   */
  AffixedElement.prototype.createClone = function () {
    //remove any existing clone associated with this element.
    this.height = this.element.height();

    if (this.height !== this.element.parent().children().first().height()) {

      this.element.parent().children().first().remove();
      this.clone = this.element.clone(false, false).addClass("affix-clone invisible").removeClass("affix-element affix");
      this.element.parent().prepend(this.clone);

      //update the current clone height
      this.currentElementHeight = this.element.outerHeight(true);
      this.updateTrigger();
    }
    if (!this.clone) {
      this.clone = this.element.clone(false, false).addClass("affix-clone invisible").removeClass("affix-element affix");
      this.element.parent().prepend(this.clone);

      //update the current clone height
      this.currentElementHeight = this.element.outerHeight(true);
      this.updateTrigger();
    }
  };

  /*
   * # Updates the trigger for when to become "stuck"
   * have to use the clone as it should always be at the original position
   * if clone doesnt exist use the element
   */
  AffixedElement.prototype.updateTrigger = function () {
    this.trigger = this.clone ? this.clone.offset().top : this.element.offset().top;
  };

  /*
   * # Updates the element
   * decides whether the object should be stuck or not
   * will only execute if the scroll position has changed.
   */
  AffixedElement.prototype.updateElement = function (scope, body) {

    if (this.element.height() !== this.height) {
      this.createClone();
      this.element.get(0).classList.remove('affix-clone');
    }

    if (this.headerHeight === null) {
      this.headerHeight = this.element[0].scrollHeight;
    } else if (this.headerHeight < this.element[0].scrollHeight) {
      this.headerHeight = this.element[0].scrollHeight;
    }

    if (this.currentScrollPosition !== this.previousScrollPosition) {
      var tabs = body[0].getElementsByClassName("navbar-tabs").length !== 0 ?
        body[0].getElementsByClassName("navbar-tabs")[0].getElementsByClassName("nav-tabs")[0] : null;

      var updateAffixScrollCondition;

      if (document.getElementsByClassName('affix-toolbar').length === 0) {
        updateAffixScrollCondition = this.offset > 0 ? 0 : this.trigger;
      } else if (document.getElementsByClassName('navbar-tabs').length !== 0) {
        updateAffixScrollCondition = body[0].getElementsByClassName("navbar-static-top")[0].scrollHeight / 2;
      } else {
        updateAffixScrollCondition = this.offset > 0 ? 0 : this.headerHeight;
      }

      if (this.currentScrollPosition > updateAffixScrollCondition && !this.affixed) {

        this.element.addClass("affix").css('top', this.offset + 'px');
        this.element.parent().addClass("child-affix");

        if (document.getElementsByClassName('affix-toolbar').length === 0) {
          this.wrapperclone = "<div class='wrapper-content-clone invisible'></div>";
          angular.element('.wrapper-content').append(angular.element(this.wrapperclone));
          angular.element('.wrapper-content-clone').height(this.headerHeight / 2 + 'px');
          angular.element('.wrapper-content').css('margin-top', '-' + this.headerHeight / 2 + 'px');
        }

        if (tabs) {
          angular.element(tabs).addClass('hidden');
        }

        body.addClass('condensed-panel');
        this.affixed = true;

      } else if (this.currentScrollPosition <= updateAffixScrollCondition && this.affixed) {

        this.element.removeClass("affix");
        this.element.parent().removeClass("child-affix");

        if (!this.element.hasClass('condensed')) {

          if (document.getElementsByClassName('affix-toolbar').length === 0) {
            angular.element('.wrapper-content').css('margin-top', 0);
            angular.element('.wrapper-content-clone').remove();
          }
          body.removeClass('condensed-panel');
        }

        if (tabs) {
          angular.element(tabs).removeClass('hidden');
        }

        this.affixed = false;

        if (this.offset > 0) {
          //removing affix, put element back where it was (relevant when there are 2 affix elements one beneath
          //each other, like a condensed toolbar under a condensed header, and then we want to bottom
          //element to return to its origin place.
          this.element.css('top', this.initialTop);
        }
      }
      this.previousScrollPosition = this.currentScrollPosition;
    }
  };

  /*
   * # Updates everything
   * This updates whether the item should be "stuck" and also clone details
   */
  AffixedElement.prototype.update = function (scope, body) {
    this.updateTrigger();
    this.updateElement(scope, body);
  };

})();;
//this file has _module name so that it is picked up first by grunt-concat,
//any further module declarations should be added here.

(function () {  
  angular.module("hpe.elements.applicationSwitcher", ["hpe.elements.templates"]);
})();;
(function () {
  
  angular.module('hpe.elements.applicationSwitcher').controller("ApplicationSwitcherContainerCtrl", ApplicationSwitcherContainerCtrl);

  function ApplicationSwitcherContainerCtrl() {
    var vm = this;
    vm.selectedItem = null;
  }

  ApplicationSwitcherContainerCtrl.prototype.select = function (applicationSwitcherItemCtrl) {
    this.selectedItem = applicationSwitcherItemCtrl;
  };
})();;
(function () {
  
  angular.module("hpe.elements.applicationSwitcher").directive("applicationSwitcherContainer", applicationSwitcherContainer);

  function applicationSwitcherContainer() {
    return {
      restrict: "E",
      templateUrl: "applicationSwitcher/applicationSwitcherContainer/template/applicationSwitcherContainer.html",
      controller: "ApplicationSwitcherContainerCtrl as asc",
      transclude: true,
      replace: true
    };
  }
})();;
(function () {
  
  angular.module('hpe.elements.applicationSwitcher').controller("ApplicationSwitcherItemCtrl", ApplicationSwitcherItemCtrl);
  ApplicationSwitcherItemCtrl.$inject = ["$scope"];

  function ApplicationSwitcherItemCtrl($scope) {
    var vm = this;
    vm.value = $scope.value;

    if (localStorage.getItem(vm.value) === "true") {
      vm.checked = true;
    } else {
      vm.checked = false;
    }

    vm.selectCallback = $scope.select;
  }

  ApplicationSwitcherItemCtrl.prototype.select = function () {
    this.applicationSwitcherContainer.select(this);
    this.selectCallback();
  };
})();;
(function () {
  
  angular.module("hpe.elements.applicationSwitcher").directive("applicationSwitcherItem", applicationSwitcherItem);

  function applicationSwitcherItem() {
    return {
      restrict: "E",
      require: "^applicationSwitcherContainer",
      controller: "ApplicationSwitcherItemCtrl as asi",
      templateUrl: "applicationSwitcher/applicationSwitcherItem/template/applicationSwitcherItem.html",
      replace: true,
      scope: {
        name: "@",
        select: "&",
        value: "@"
      },
      link: function (scope, element, attr, applicationSwitcherContainer) {
        element.bind('click', function () {
          scope.asi.applicationSwitcherContainer = applicationSwitcherContainer;
          scope.asi.select();
        });
      }
    };
  }
})();;
(function () {
  
  angular.module('hpe.elements.backButton', []).directive('backButton', backButton);

  function backButton() {
    return {
      restrict: 'E',
      templateUrl: "backButton/template/backButton.html",
      replace: true,
      scope: {
        ariaLabel: "@"
      }
    };
  }

})();;
//this file has _module name so that it is picked up first by grunt-concat,
//any further module declarations should be added here.

(function () {
  angular.module("hpe.elements.backButtonHeader", []);
})();;
(function () {
  
  angular.module('hpe.elements.backButtonHeader').directive('backButtonHeader', backButtonHeader);
  backButtonHeader.$inject = ["$state"];

  function backButtonHeader($state) {
    return {
      restrict: 'E',
      templateUrl: "backButtonHeader/template/backButtonHeader.html",
      replace: true,
      scope: {
        targetState: "="
      },
      link: function (scope, element) {
        element.on('click', function () {
          $state.go(scope.targetState);
        });
      }
    };
  }

})();;
(function () {  
  angular.module("hpe.elements.cardTabs", []);
})();
;
(function () {
  
  angular.module('hpe.elements.cardTabs').directive('cardset', ["$window", "$compile", "safeTimeout", cardset]);

  function cardset($window, $compile, safeTimeout) {
    return {
      restrict: 'E',
      templateUrl: "cardTabs/templates/cardSet.html",
      replace: true,
      transclude: true,
      link: function (scope, element, attrs) {

        //allow angular to finish ng-repeats
        var safeTimeoutInstance = safeTimeout.create(scope);
        safeTimeoutInstance.timeout(function () {
          //carousel properties
          var carousel = element.find('.card-tab-container');
          var belt = carousel.find('.card-tabs');

          //store all useful elements & tabs
          var cards = belt.find('.card-tab');
          var contentAreaTop = element[0].getElementsByClassName('tab-content-container top')[0];
          var contentAreaBottom = element[0].getElementsByClassName('tab-content-container bottom')[0];
          var previousButton = carousel.find('.page-btn.previous');
          var nextButton = carousel.find('.page-btn.next');

          //set list width to content width
          belt.width(belt[0].scrollWidth);

          var bounds = [];

          var widths = {
            carouselWidth: carousel.width(),
            beltWidth: belt.outerWidth()
          };

          //set bounds
          setBounds();

          var topContainer = attrs.contentPosition && attrs.contentPosition.toLowerCase() === 'bottom' ? false : true;

          //add event listeners
          previousButton.click(previousPage);
          nextButton.click(nextPage);

          //when finished animation then fire this
          belt.on('transitionend webkitTransitionEnd', function (e) {
            if (e.originalEvent.propertyName && e.originalEvent.propertyName.toLowerCase() === "left")
              buttonsVisibility();
          });

          //when window resizes recalculate everything
          $(window).bind('resize', function () {
            setBounds();
            buttonsVisibility();
            repositionBelt();
          });

          //add event listeners to all cards
          for (var i = 0; i < cards.length; i++) {
            cards[i].addEventListener('click', selectCard);
          }

          //show or hide buttons accordingly
          buttonsVisibility();

          //select first card by default
          selectInitialCard();

          function previousPage() {
            var oldX = parseInt(belt.css('left'));
            var newX = Math.min(oldX + widths.carouselWidth, bounds[0]);
            belt.css('left', newX);
          }

          function nextPage() {
            var oldX = parseInt(belt.css('left'));
            var newX = Math.max(oldX - widths.carouselWidth, bounds[1]);
            belt.css('left', newX);
          }

          function setBounds() {
            //ensure widths are up to date
            widths = {
              carouselWidth: carousel.width(),
              beltWidth: belt.outerWidth()
            };

            //now set bounds
            bounds = [0, Math.min(widths.carouselWidth - widths.beltWidth, 0)];
          }

          function buttonsVisibility() {
            var beltLeft = parseInt(belt.css('left'));

            if (belt.outerWidth() < carousel.width()) {
              previousButton.hide();
              nextButton.hide();
              return;
            }
            if (beltLeft >= bounds[0])
              previousButton.hide();
            else
              previousButton.show();
            if ((beltLeft <= bounds[1]))
              nextButton.hide();
            else
              nextButton.show();
          }

          function repositionBelt() {

            //ensure on resize that no gaps are left and the space is made best use of            
            var beltLeft = parseInt(belt.css('left'));

            if (beltLeft >= bounds[0]) {
              var newX = Math.min(beltLeft + widths.carouselWidth, bounds[0]);
              belt.css('left', newX);
            }

            if ((beltLeft <= bounds[1])) {
              var newXPos = Math.max(beltLeft - widths.carouselWidth, bounds[1]);
              belt.css('left', newXPos);
            }
          }

          function deselectAllCards() {
            for (var i = 0; i < cards.length; i++) {
              $(cards[i]).removeClass('active');
              $(cards[i]).removeClass('top');
              $(cards[i]).removeClass('bottom');
            }
          }

          function selectInitialCard() {
            if (cards.length === 0) return;

            //get first card
            var card = cards[0];

            //update content area
            updateContent(card);
          }

          function selectCard(e) {

            //ensure all other cards are deselected
            deselectAllCards();

            //select the new card
            var card = e.currentTarget;

            //update content area
            updateContent(card);

            //ensure card is fully on screen
            moveCardOnScreen(card);
          }

          function moveCardOnScreen(card) {
            var beltLeft = parseInt(belt.css('left'));

            var cardStart = card.offsetLeft + beltLeft;
            var cardEnd = (card.offsetLeft + $(card).outerWidth(true)) + beltLeft;

            if (cardStart < 0) {
              var newX = Math.abs(beltLeft) + cardStart;

              if (newX <= (bounds[0] + 5)) newX = bounds[0];

              belt.css('left', -newX);
              buttonsVisibility();
              return;
            }

            if (cardEnd > (widths.carouselWidth + 5)) {
              var newXPos = cardEnd - widths.carouselWidth;

              if (-newXPos < bounds[1]) newXPos = Math.abs(bounds[1]);

              belt.css('left', beltLeft - newXPos);
              buttonsVisibility();
              return;
            }
          }

          function updateContent(card) {

            //apply active class
            $(card).addClass('active');

            //apply appropriate callout class
            if (topContainer)
              $(card).addClass('top');
            else
              $(card).addClass('bottom');


            var cardScope = angular.element(card).scope();

            //now find its associated tab content
            var tabContent = card.getElementsByTagName('tab-content');

            //remove old tab content
            if (topContainer)
              angular.element(contentAreaTop).empty();
            else
              angular.element(contentAreaBottom).empty();

            if (!tabContent || tabContent.length === 0) return;

            var compiledContent = $compile(tabContent[0].innerHTML)(cardScope);

            //apply scope
            apply();

            if (topContainer)
              angular.element(contentAreaTop).append(compiledContent);
            else
              angular.element(contentAreaBottom).append(compiledContent);

          }

          function apply() {
            //only apply scope if we need to
            if (!scope.$$phase) {
              scope.$apply();
            }
          }
        });
      }
    };
  }

})();;
(function () {
  
  angular.module('hpe.elements.cardTabs').directive('card', card);

  function card() {
    return {
      restrict: 'E',
      template: "<li class=\"card-tab\"><div class=\"no-overflow\" ng-transclude></div></li>",
      transclude: true,
      replace: true,
      link: function (scope, element) {
        
        //find our tab content and hide it
        var tabContent = element[0].getElementsByTagName('tab-content');

        if (!tabContent || tabContent.length > 1) throw 'Card tabs can have only one tab-content element';

        if (tabContent.length === 0) return;

        tabContent[0].style.display = 'none';

      }
    };
  }

})();;
//This is essentially to prevent the tab content being evaluated at this stage

(function () {
  
  angular.module('hpe.elements.cardTabs').directive('tabContent', tabContent);

  function tabContent() {
    return {
      restrict: 'E',
      terminal: true
    };
  }

})();;
(function() {
    angular.module('hpe.elements.checkbox', []);
})();;
(function () {

    angular.module('hpe.elements.checkbox').controller('CheckboxCtrl', CheckboxCtrl);

    CheckboxCtrl.$inject = ['$scope'];

    function CheckboxCtrl($scope) {
        var vm = this;

        vm.indeterminate = vm.ngModel === vm.indeterminateValue;

        vm.toggleChecked = function () {

            // if disabled then do nothing
            if (vm.ngDisabled === true) {
                return;
            }

            if (vm.indeterminate === true) {
                vm.ngModel = true;
                vm.indeterminate = false;
            } else {
                vm.ngModel = !vm.ngModel;
            }
        };

        vm.keydown = function(event) {
            
            // if spacebar is pressed toggle state
            if(event.keyCode === 32) {
                vm.toggleChecked();
                event.stopPropagation();
                event.preventDefault();
            }
        };

        $scope.$watch('vm.ngModel', function (newValue) {
            vm.indeterminate = newValue === vm.indeterminateValue;
        });
    }

})();;
(function() {
    angular.module('hpe.elements.checkbox').directive('checkbox', checkbox);

    function checkbox() {
        return {
            restrict: 'E',
            transclude: true,
            templateUrl: 'checkbox/checkbox.html',
            controller: 'CheckboxCtrl as vm',
            bindToController: true,
            replace: true,
            scope: {
                ngModel: '=',
                ngDisabled: '=?',
                indeterminateValue: '=?', 
                simplified: '=?',
                name: '@?'
            },
            compile: function(element, attrs) {

                // check if we have a name attribute
                if(attrs.name !== undefined) {
                    
                    // replace the name attribute with a for attribute
                    element.removeAttr('name').attr('for', attrs.name);
                }
            }
        };
    }

})();;
(function () {

  angular.module('hpe.elements.condensedHeader', []).directive("condensedHeader", condensedHeader);

  function condensedHeader() {
    return {
      restrict: 'A',
      link: function (scope, element) {
        var body = angular.element('body');
        if (element.hasClass('condensed')) {
          body.addClass('condensed-panel');
        }
      }
    };
  }
})();;
(function () {  
  angular.module("hpe.elements.contacts", []);
})();
;
(function () {
    
    angular.module('hpe.elements.contacts').directive('elementsContact', ['$compile', '$document', 'contactTooltipService', elementsContact]);

    function elementsContact($compile, $document, contactTooltipService) {
        return {
            restrict: 'E',
            scope: {
                contact: "=",
                size: "=",
                order: "=?",
                colors: "=",
                showStatus: "="
            },
            templateUrl: "contacts/templates/contact.html",
            link: elementsContactLink
        };

        function elementsContactLink(scope, element) {
            updateContact(scope, element);
            updateStatus(scope, element);
            renderTooltip(scope, element);
            scope.$watch(function () {
                    return scope.contact.status;
                },
                function (nV, oV) {
                    if (!angular.equals(nV, oV)) {
                        updateStatus(scope, element);
                    }
                });
        }

        function updateContact(scope, element) {
            var contactStyles = {
                backgroundColor: scope.colors.primary,
                color: scope.colors.secondary,
                marginLeft: scope.order === 0 ? "0px" : "1px"
            };

            angular.extend(element.find(".contact")[0].style, contactStyles);
        }

        function renderTooltip(scope, element) {

            if (scope.contact.customTooltip === undefined || scope.contact.customTooltip.template === undefined) return;
            contactTooltipService.getTooltip(scope, element, false);

        }

        function updateStatus(scope, element) {
            var status = {
                active: "#01a982",
                passive: "#ccc"
            };

            if (scope.contact) {
                var statusStyles = {
                    backgroundColor: status[scope.contact.status] || null,
                    marginLeft: scope.order === 0 ? "0px" : "1px"
                };

                angular.extend(element.find(".status")[0].style, statusStyles);
            }
        }
    }
})();;
(function () {
  
  angular.module('hpe.elements.contacts').directive('elementsContactGroup', ['contactTooltipService', elementsContactGroup]);

  function elementsContactGroup(contactTooltipService) {
    return {
      restrict: 'E',
      scope: {
        contacts: "=",
        organization: "=",
        size: "=?",
        colors: "=",
        maxContacts: "@",
        overflowClick: "&"
      },
      templateUrl: "contacts/templates/contactGroup.html",
      link: elementsContactGroupLink
    };

    function elementsContactGroupLink(scope, element, attrs) {
      
      if (!Array.isArray(scope.contacts)) {
        scope.contacts = [
          scope.contacts
        ];
      }

      if (scope.organization && scope.organization.label) {
        updateOrganizationLabel(scope.organization.label, scope);
      }
      scope.$watch(function () {
        return scope.organization.label;
      }, function (nV, oV) {
        if (!angular.equals(nV, oV)) {
          updateOrganizationLabel(scope.organization.label, scope);
        }
      });

      scope.size = angular.isDefined(scope.size) ? scope.size.toLocaleLowerCase() : "medium";

      scope.maxContacts = angular.isDefined(scope.maxContacts) ? scope.maxContacts : Infinity;

      scope.overflowCount = function (total, max) {
        return total - max;
      };

      scope.overflowClickable = angular.isDefined(attrs.overflowClick);

      scope.showStatus = angular.isDefined(scope.contacts[0]) ? scope.contacts.some(function (elem) {
        return !!elem.status;
      }) : false;

      var styles = {
        backgroundColor: scope.colors.secondary,
        color: scope.colors.primary,
      };

      angular.extend(element.find(".organization")[0].style, styles);

      //render popover tooltip for organization
      if (angular.isDefined(scope.organization.customTooltip) && angular.isDefined(scope.organization.customTooltip.template)) {
        contactTooltipService.getTooltip(scope, element.find(".organization"), true);
      }
    }

    function updateOrganizationLabel(organizationLabel, scope) {
      switch (organizationLabel.toLocaleLowerCase()) {
        case "external":
          scope.label = "external";
          break;
        case "risk":
          scope.label = "risk";
          break;
        default:
          scope.label = undefined;
      }
    }
  }
})();;
(function () {

    angular.module("hpe.elements.contacts").factory('contactTooltipService', contactTooltipService);

    contactTooltipService.$inject = ['$compile', '$document'];

    function contactTooltipService($compile, $document) {

        function getTooltip(scope, element, organization) {

            var tooltipHtml, tooltipPosition;

            if (organization === false) {
                tooltipHtml = scope.contact.customTooltip.template;
                tooltipPosition = scope.contact.customTooltip.tooltipPosition = angular.isDefined(scope.contact.customTooltip.tooltipPosition) ? scope.contact.customTooltip.tooltipPosition.toLocaleLowerCase() : "bottom";

            } else {
                tooltipHtml = scope.organization.customTooltip.template;
                tooltipPosition = scope.organization.customTooltip.tooltipPosition = angular.isDefined(scope.organization.customTooltip.tooltipPosition) ? scope.organization.customTooltip.tooltipPosition.toLocaleLowerCase() : "bottom";
            }

            var templateHtml = "<ng-include src=\"'" + tooltipHtml + "'\"></ng-include>";
            var div = angular.element('<div></div>');
            var popoverTemplate = div.html(templateHtml);

            //compile the element before adding it to the popover
            var compiledTemplate = $compile(popoverTemplate)(scope);

            //add popover
            element.popover({
                template: '<div class="popover contacts-popover" role="tooltip"><div class="arrow contacts-popover-arrow"></div><div class="popover-content"></div></div>',
                content: compiledTemplate,
                trigger: 'manual',
                placement: tooltipPosition,
                html: true
            });

            configureTooltip(scope, element, tooltipPosition, organization);
        }

        function configureTooltip(scope, element, tooltipPosition, organization) {

            var timer, tooltipElement;

            //Open popover on hover if not already opened
            if (organization === false) {
                tooltipElement = element.children('.contact');
            } else {
                tooltipElement = element;
            }

            tooltipElement.mouseenter(function () {

                timer = setTimeout(function () {

                    //check if there are other popovers
                    var otherPopovers = angular.element(".popover").not(element.parent().children('.popover'));
                    if (otherPopovers.length > 0) {

                        //close them
                        angular.forEach(otherPopovers, function (popover) {
                            var popoverElement = angular.element(popover).prev();
                            popoverElement.popover('hide');

                        });
                    }

                    //show popover if it is not already open
                    if (element.parent().children('.popover').length === 0) {
                        element.popover('show');
                    }

                }, 600);


            }).mouseleave(function () {
                clearTimeout(timer);
            });


            var contactsHoverBind = function (event) {

                //If popover is already closed or if the click is on the contact where popover is already opened, then return
                if (element.parent().children('.popover').length === 0 || element.has(event.target).length > 0) return;

                var xp = [],
                    yp = [];
                var popover = element.parent().children('.popover');
                if (popover.length === 0) return;

                if (tooltipPosition === "bottom") {

                    if (organization === false) {
                        xp.push(element.offset().left);
                        yp.push(element.offset().top);
                        xp.push(element.offset().left + element.children('div.contact')[0].clientWidth);
                        yp.push(element.offset().top);
                    } else {
                        //position tooltip for organization element
                        xp.push(element.offset().left);
                        yp.push(element.offset().top);
                        xp.push(element.offset().left + element[0].clientWidth);
                        yp.push(element.offset().top);

                    }

                    //popover top right co-ordinates
                    xp.push(popover.offset().left + popover[0].clientWidth);
                    yp.push(popover.offset().top);

                    //popover top left co-ordinates
                    xp.push(popover.offset().left);
                    yp.push(popover.offset().top);
                } else {

                    //tooltip position is at top

                    if (organization === false) {
                        xp.push(element.offset().left);
                        yp.push(element.offset().top + element.children('div.contact')[0].clientHeight);
                        xp.push(element.offset().left + element.children('div.contact')[0].clientWidth);
                        yp.push(element.offset().top + element.children('div.contact')[0].clientHeight);
                    } else {
                        //position tooltip for organization element
                        xp.push(element.offset().left);
                        yp.push(element.offset().top + element[0].clientHeight);
                        xp.push(element.offset().left + element[0].clientWidth);
                        yp.push(element.offset().top + element[0].clientHeight);
                    }

                    //popover bottom right co-ordinates
                    xp.push(popover.offset().left + popover[0].clientWidth);
                    yp.push(popover.offset().top + popover[0].clientHeight);

                    //popover bottom left co-ordinates
                    xp.push(popover.offset().left);
                    yp.push(popover.offset().top + popover[0].clientHeight);


                }
                /*The math used in the function is to determine if a point lies on the interior of a polygon
                 This is based on the principle that the point will be inside if a horizontal line drawn through the point
                 has an odd number of intersections with sides of the polygon (Ray casting algorithm)
                 Hence, the value of c will be true if it toggles odd number of times and the function returns true when point
                 is inside and false when point is outside the polygon
                 */
                function checkIfPointIsInside(xp, yp, x, y) {
                    var i, j, c = 0;
                    for (i = 0, j = xp.length - 1; i < xp.length; j = i++) {
                        if ((((yp[i] <= y) && (y < yp[j])) ||
                                ((yp[j] <= y) && (y < yp[i]))) &&
                            (x < (xp[j] - xp[i]) * (y - yp[i]) / (yp[j] - yp[i]) + xp[i]))
                            c = !c;
                    }
                    return c;
                }
                var result = checkIfPointIsInside(xp, yp, event.pageX, event.pageY);

                //no need to hide the popover if mouse pointer is within the allowed region
                if (result === true) return;

                var e = angular.element(event.target);

                //Check for hover outside the popover, if yes then hide popover
                if (angular.element('body').has(event.target) && e.hasClass('popover') === false && e.parents('.popover').length === 0) {
                    element.popover("hide");
                }
            };

            $document.bind('mousemove', contactsHoverBind);

            scope.$on('$destroy', function () {
                $document.unbind('mousemove', contactsHoverBind);
            });


        }

        var service = {
            getTooltip: getTooltip
        };
        return service;
    }

})();;
(function () {  
  angular.module("hpe.elements.dateTimePicker", ["hpe.elements.templates"]);
})();
;
(function () {
  
    angular.module('hpe.elements.dateTimePicker').controller('DateTimePickerPopupCtrl', DateTimePickerPopupCtrl);

    DateTimePickerPopupCtrl.$inject = ['$scope', '$parse', '$attrs'];

    function DateTimePickerPopupCtrl($scope, $parse, $attrs) {
        var vm = this;

        var DisplayFormat12h = "ddd MMM DD, YYYY h:mm:ss A";
        var DisplayFormat24h = "ddd MMM DD, YYYY HH:mm:ss";

        var DateFormats = [
            "ddd MMM D, YYYY",
            "MMM D, YYYY",
            "M/D/YYYY",
            "M-D-YYYY",
            "YYYY-M-D"
        ];

        var TimeFormats = [
            "h A",
            "h:mm A",
            "h:mm:ss A",
            "H:mm",
            "H:mm:ss"
        ];

        var DateAndTimeFormats = [];
        for (var d = 0; d < DateFormats.length; d += 1) {
            for (var t = 0; t < TimeFormats.length; t += 1) {
                DateAndTimeFormats.push(DateFormats[d] + " " + TimeFormats[t]);
            }
        }

        vm.init = function (ngModelCtrl, ngModelAttr, element, timezones) {
            vm.ngModelCtrl = ngModelCtrl;

            vm.element = element;

            vm.ngModelAttr = ngModelAttr;
            vm.modelGetter = $parse(ngModelAttr);

            // Save the timezone
            storeTimezone();

            //get all the timezones for parsing
            vm.timezones = $parse(timezones)($scope);

            //create a custom render
            vm.ngModelCtrl.$render = renderFn;

            //add a parser
            vm.ngModelCtrl.$parsers.push(parse);

            vm.ngModelCtrl.$formatters.push(format);

            vm.ngModelCtrl.$validators.isFormatValid = isFormatValid;
            vm.ngModelCtrl.$validators.isAfterMin = isAfterMin;
            vm.ngModelCtrl.$validators.isBeforeMax = isBeforeMax;

            // Set the initial time on the date if it was specified.
            addTimeToDate(vm.modelGetter($scope));
        };

        // Model value changed by the picker
        vm.onModelUpdate = function(nv) {
            if (!angular.isDefined(nv) || angular.equals(nv, {})) return;

            // If the time field has changed then insert it into the date for correct rendering
            if (angular.isString(nv.time)) {
                addTimeToDate(nv);
            }
            // If there's no time field then add it from the date field
            else if (angular.isDate(nv.date)) {
                nv.time = formatTime(nv.date);
            }

            storeTimezone();

            // Restore selected timezone if it was unset.
            nv.timezone = vm.currentTimezone;

            vm.reformat();

            vm.editing = false;

            vm.ngModelCtrl.$validate();
        };

        // Input was received
        vm.onEdit = function(value) {
            $scope.$apply(function() {
                vm.editing = (value !== format(vm.ngModelCtrl.$modelValue));
            });
        };

        vm.reformat = function() {
            var formatted = format(vm.ngModelCtrl.$modelValue);
            if (angular.isString(formatted)) {
                vm.ngModelCtrl.$setViewValue(formatted);
                vm.ngModelCtrl.$render();
            }
        };

        function renderFn() {
            vm.element.val(vm.ngModelCtrl.$viewValue);
        }

        function parse(value) {
            if (!angular.isString(value)) return undefined;

            // Substitute special tokens
            var dateString = value.trim()
                .replace(/today/i, moment().format("YYYY-MM-DD"))
                .replace(/yesterday/i, moment().subtract(1, "days").format("YYYY-MM-DD"))
                .replace(/tomorrow/i, moment().add(1, "days").format("YYYY-MM-DD"));

            // Look for date-only strings
            var date = moment(dateString, DateFormats, true);
            if (date.isValid()) {
                // Apply the appropriate default time
                if ($attrs.defaultDayTime === "end") {
                    date.endOf("day");
                }
            } else {
                // Check time-only strings (date will be today by default)
                date = moment(dateString, TimeFormats, true);
                if (!date.isValid()) {
                    // Lastly check full date+time formats
                    date = moment(dateString, DateAndTimeFormats, true);
                }
            }

            var valid = date.isValid();
            if (!valid) {
                return {};
            }

            return {
                date: date.toDate(),
                time: formatTime(date),
                timezone: vm.currentTimezone
            };
        }

        function format(value) {
            if (isValidDate(value)) {
                return moment(value.date).format($parse($attrs.isMeridian)($scope) ? DisplayFormat12h : DisplayFormat24h);
            }
            return undefined;
        }

        // Check input is valid
        function isFormatValid(modelValue) {
            return isValidDate(modelValue) || isInputEmpty();
        }

        // Check date is after min-date (if specified)
        function isAfterMin(modelValue) {
            var minDate = $parse($attrs.minDate)($scope);
            if (isValidDate(modelValue) && angular.isDate(minDate) && !moment(modelValue.date).isAfter(minDate)) return false;
            return true;
        }

        // Check date is before max-date (if specified)
        function isBeforeMax(modelValue) {
            var maxDate = $parse($attrs.maxDate)($scope);
            if (isValidDate(modelValue) && angular.isDate(maxDate) && !moment(modelValue.date).isBefore(maxDate)) return false;
            return true;
        }

        function isInputEmpty() {
            return !angular.isString(vm.ngModelCtrl.$viewValue) || vm.ngModelCtrl.$viewValue.length === 0;
        }

        function isValidDate(modelValue) {
            return angular.isDefined(modelValue) && angular.isDefined(modelValue.date) && moment(modelValue.date).isValid();
        }

        // Update the date property with time value.
        function addTimeToDate(value) {
            if (angular.isString(value.time)) {
                var time = moment(value.time, TimeFormats);
                if (time.isValid()) {
                    if (!isValidDate(value)) {
                        value.date = new Date();
                    }
                    value.date.setHours(time.hour());
                    value.date.setMinutes(time.minute());
                    value.date.setSeconds(time.second());
                }
            }
        }

        function formatTime(date) {
            var md = moment(date);
            var isMeridian = $parse($attrs.isMeridian)($scope);
            var chooseSeconds = $parse($attrs.chooseSeconds)($scope);
            var hours = isMeridian ? "hh" : "HH";
            var seconds = chooseSeconds ? ":ss" : "";
            var suffix = isMeridian ? ":A" : "";
            var formatString = hours + ":mm" + seconds + suffix;
            return md.format(formatString);
        }

        // Save the timezone from valid model values. The model will become undefined if an invalid input
        // is entered, so we have to restore the last good value afterwards. 
        function storeTimezone() {
            var model = vm.modelGetter($scope);
            if (model && angular.isDefined(model.timezone)) {
                vm.currentTimezone = model.timezone;
            }
        }
    }
})();;
(function () {

    angular.module('hpe.elements.dateTimePicker').controller("dateTimePickerCtrl", DateTimePickerCtrl);

    DateTimePickerCtrl.$inject = ["$scope"];

    function DateTimePickerCtrl($scope) {
        var vm = this;

        vm.init = function () {
            //set values - with their specifed values or default values
            vm.minDate = $scope.minDate ? $scope.minDate : null;
            vm.maxDate = $scope.maxDate ? $scope.maxDate : null;
            vm.disabled = $scope.disabled ? $scope.disabled : false;
            vm.dateFormat = $scope.dateFormat ? $scope.dateFormat : 'yyyy-MM-dd';
            vm.maxDate = $scope.maxDate ? $scope.maxDate : null;
            vm.datePickerMode = $scope.datePickerMode ? $scope.datePickerMode : 'day';
            vm.isMeridian = $scope.isMeridian ? $scope.isMeridian : null;
            vm.showMeridian = $scope.showMeridian ? $scope.showMeridian : false;
            vm.chooseDate = $scope.chooseDate ? $scope.chooseDate : false;
            vm.chooseTime = $scope.chooseTime ? $scope.chooseTime : false;
            vm.chooseSeconds = $scope.chooseSeconds ? $scope.chooseSeconds : false;
            vm.chooseTimeZone = $scope.chooseTimeZone ? $scope.chooseTimeZone : false;
            vm.defaultDayTime = $scope.defaultDayTime;
            vm.timezones = $scope.timezones ? $scope.timezones : ["GMT", "IST", "EST", "CST", "WST"];
            vm.timezoneDefaultIndex = $scope.timezoneDefaultIndex ? $scope.timezoneDefaultIndex : 0;
        };

        $scope.$watch("ngModel.date", function (nv, ov) {
            if (nv !== ov && !$scope.editing) {
                vm.date = nv;
            }
        });

        $scope.$watch("dtpk.date", function (nv, ov) {
            if (nv !== ov && angular.isDefined(vm.date)) {
                if (!$scope.ngModel) $scope.ngModel = {};
                $scope.ngModel.date = vm.date;
                if (angular.isDate($scope.ngModel.date) && !angular.isDefined($scope.ngModel.time) && vm.defaultDayTime === "end") {
                    $scope.ngModel.date = moment($scope.ngModel.date).endOf("day").toDate();
                }
            }
        });

        vm.goToday = function () {
            //set the value to todays date
            if (!$scope.ngModel) $scope.ngModel = {};
            $scope.ngModel.date = new Date();
        };

    }
})();;
(function () {
  
  angular.module('hpe.elements.dateTimePicker').directive("dateTimePicker", dateTimePicker);

  function dateTimePicker() {
    return {
      restrict: 'E',
      scope: {
        ngModel: '=',
        isOpen: '=',
        minDate: '=?',
        maxDate: '=?',
        disabled: '=?',
        dateFormat: '=?',
        datePickerMode: '=?',
        isMeridian: '=?',
        showMeridian: '=?',
        chooseDate: '=?',
        chooseTime: '=?',
        chooseSeconds: '=?',
        chooseTimeZone: '=?',
        defaultDayTime: '@?',
        timezones: '=?',
        timezoneDefaultIndex: '=?',
        editing: '=?' // boolean value indicating that the model value is not yet finalised
      },
      controller: "dateTimePickerCtrl as dtpk",
      templateUrl: "dateTimePicker/templates/dateTimePicker.html",
      link: function (scope) {
        scope.dtpk.init();
      }
    };
  }
})();;
(function () {
  
    angular.module('hpe.elements.dateTimePicker').directive("dateTimePickerPopup", ['$compile', '$document', '$parse', dateTimePickerPopup]);

    function dateTimePickerPopup($compile, $document, $parse) {
        return {
            restrict: 'A',
            require: 'ngModel',
            controller: 'DateTimePickerPopupCtrl as dtpp',
            scope: true,
            link: function (scope, element, attrs, ngModel) {

                //pass the ngModel to the controller
                scope.dtpp.init(ngModel, attrs.ngModel, element, attrs.timezones);

                // Notify controller of ngModel updates
                scope.$watch(attrs.ngModel, function (nv, ov) {
                    if (!angular.equals(nv, ov)) {
                        scope.dtpp.onModelUpdate(nv, ov);
                    }
                }, true);

                element.keyup(function () {
                    scope.dtpp.onEdit(element.val());
                });

                //this class should act as a wrapper for the date time picker to show it in a popover
                var popoverTemplate = angular.element('<date-time-picker></date-time-picker>');

                var popoverOpen = false;

                //add model to popover
                popoverTemplate.attr({
                    'ng-model': attrs.ngModel,
                    'is-open': attrs.isOpen,
                    'min-date': attrs.minDate,
                    'max-date': attrs.maxDate,
                    'disabled': attrs.disabled,
                    'date-format': attrs.dateFormat,
                    'date-picker-mode': attrs.datePickerMode,
                    'is-meridian': attrs.isMeridian,
                    'choose-date': attrs.chooseDate,
                    'choose-time': attrs.chooseTime,
                    'choose-seconds': attrs.chooseSeconds,
                    'choose-time-zone': attrs.chooseTimezone,
                    'default-day-time': attrs.defaultDayTime,
                    'timezones': attrs.timezones,
                    'timezoneDefaultIndex': attrs.timezoneDefaultIndex,
                    'editing': 'dtpp.editing || !dtpp.ngModelCtrl.$valid || !dtpp.ngModelCtrl.$viewValue'
                });

                //compile the element before adding it to the popover
                var compiledTemplate = $compile(popoverTemplate)(scope);

                //add popover
                element.popover({
                    template: '<div class="popover date-picker-popover" role="tooltip"><div class="date-picker-popover-arrow arrow"></div><div class="popover-content"></div></div>',
                    content: compiledTemplate,
                    trigger: 'manual',
                    placement: 'bottom',
                    html: true
                });
                //attributes to watch
                var attrsToWatch = ['chooseDate', 'chooseTime', 'chooseSeconds', 'chooseTimezone', 'isMeridian'];
                var openPopover = true;

                function validatePopoverOpen() {

                    if ($parse(attrs.chooseDate)(scope) || $parse(attrs.chooseTime)(scope) || $parse(attrs.chooseTimezone)(scope)) {
                        openPopover = true;
                        element.removeAttr('disabled');
                    } else {
                        openPopover = false;
                        element.attr('disabled', 'disabled');
                        element.popover("hide");
                        popoverOpen = false;
                        $parse(attrs.isOpen).assign(scope, false);
                    }
                }
                angular.forEach(attrsToWatch, function (key) {
                    if (attrs[key]) {
                        scope.$watch($parse(attrs[key]), function (nv, ov) {

                            validatePopoverOpen();
                            //update view when the attribute value changes
                            if (nv !== ov) {
                                scope.dtpp.reformat();
                            }
                        });
                    }
                });
                scope.$watch($parse(attrs.isOpen), function (newValue) {
                    if (newValue === true) {
                        if (!popoverOpen && openPopover) {
                            element.popover('show');
                            popoverOpen = true;
                        }
                    } else {
                        element.popover('hide');
                        popoverOpen = false;
                    }
                });

                element.on("keypress", function (event) {
                    if (event.which === 13) {
                        element.blur();
                        scope.$apply(function () {
                            $parse(attrs.isOpen).assign(scope, false);
                        });
                        event.preventDefault();
                    }
                });

                var documentClickBind = function (event) {
                    //Return if clicked on any of the input group components
                    if (isPickerClicked(event.target)) return;

                    var e = angular.element(event.target);
                    //clicked outside datepicker
                    if (angular.element('body').has(event.target) && e.hasClass('popover') === false && e.parents('.popover').length === 0) {
                        element.popover("hide");
                        popoverOpen = false;
                        scope.$apply(function () {
                            $parse(attrs.isOpen).assign(scope, false);
                        });
                    }
                };

                function isPickerClicked(targetElement) {
                    return (targetElement === element.get(0) || element.parents('.input-group').has(targetElement).length > 0);
                }

                $document.bind('mousedown', documentClickBind);

                scope.$on('$destroy', function () {
                    $document.unbind('mousedown', documentClickBind);
                });

            }
        };
    }
})();;
(function() {
  
    angular.module('hpe.elements.dateTimePicker').controller('timePickerCtrl', TimePickerCtrl);

    TimePickerCtrl.$inject = ['$scope'];

    function TimePickerCtrl($scope) {
        var vm = this;

        vm.meridian = "AM";

        //get our reference to parent controller
        vm.dateTimePickerCtrl = $scope.dtpk;
        vm.separator = ":";
        $scope.$watch('ngModel.time', function(nv) {

            if (vm.dateTimePickerCtrl.chooseTime === false) return;

            if (angular.isString(nv)) {
                var matches = nv.match(/(\d{1,2}):(\d{1,2}):?(\d{1,2})?:?(AM|PM)?/i);
                if (matches && matches.length === 5) {
                    vm.hours = matches[1];
                    vm.minutes = matches[2];
                    vm.seconds = matches[3];
                    if (matches[4]) vm.meridian = matches[4];
                }
            }
            else {
                vm.hours = undefined;
                vm.minutes = undefined;
                vm.seconds = undefined;
            }

            if ($scope.isMeridian === true && angular.isString(vm.meridian) && vm.meridian.length > 0) {
                $scope.showMeridian = true;
            } else {
                //Donot show AM/PM button if it is 24 hour clock
                $scope.showMeridian = false;
            }

        });
        $scope.$watch('ngModel.timezone', function(nv) {
            vm.timezone = nv;
        });

        function updateTime() {

            if(vm.dateTimePickerCtrl.chooseTime === false)return;
            
            //Only update if time is valid
            if (!($scope.invalidHours || $scope.invalidMinutes))
            {
                if (!$scope.ngModel) $scope.ngModel = {};

                $scope.ngModel.time = $scope.tmpk.hours + vm.separator + $scope.tmpk.minutes;

                if ($scope.chooseSeconds) {
                    $scope.ngModel.time += vm.separator + $scope.tmpk.seconds;
                }
                if ($scope.isMeridian) {
                    $scope.ngModel.time += vm.separator + $scope.tmpk.meridian;
                }
            }
            
        }

        function updateTimezone() {
            if (angular.isDefined($scope.tmpk.timezone)) {
                if (!$scope.ngModel) $scope.ngModel = {};
                $scope.ngModel.timezone = $scope.tmpk.timezone;
            }
        }

        //Function which validates hours and updates time
        function validateHours(nv) {

            if(vm.dateTimePickerCtrl.chooseTime === false)return;
            if (!angular.isDefined(nv)) return;

            var hours = 0;
            var minOneNum = false;
            for (var i = 0; i < nv.length; i++) {
                if (!isNaN(parseInt(nv[i]))) {
                    hours *= 10;
                    hours += parseInt(nv[i]);
                    minOneNum = true;

                }
            }
            if (minOneNum === false) {
                $scope.invalidHours = true;
                return;
            }

            hours = hours.toString();

            //update vm.dateTimePickerCtrl.value.time here
            //If meridian format, then hours can range from 1-12, else 0-23
            if ($scope.isMeridian === true) {
                if (!(parseInt(hours) >= 1 && parseInt(hours) <= 12)) {
                    $scope.invalidHours = true;
                } else $scope.invalidHours = false;
            } else {
                if (!(parseInt(hours) >= 0 && parseInt(hours) <= 23)) {
                    $scope.invalidHours = true;
                } else $scope.invalidHours = false;
            }
            //If the input box has no string, mark as invalid
            if (hours.length < 1 || minOneNum === false) $scope.invalidHours = true;
            //If the input box has one digit, append zero before it
            else if (hours.length === 1) $scope.tmpk.hours = "0" + hours;

            if ($scope.invalidHours === false) {
                updateTime();
            }
        }
        //watch for changes in these values
        $scope.$watch('tmpk.hours', function(nv, ov) {
            if (nv !== ov) {

                validateHours(nv);

            }
        });

        //Function which validates minutes and updates time
        function validateMinutes(nv) {

            if(vm.dateTimePickerCtrl.chooseTime === false)return;
            if (!angular.isDefined(nv)) return;

            //update vm.dateTimePickerCtrl.value.time here
            var minutes = 0;
            var minOneNum = false;
            for (var i = 0; i < nv.length; i++) {
                if (!isNaN(parseInt(nv[i]))) {
                    minutes *= 10;
                    minutes += parseInt(nv[i]);
                    minOneNum = true;

                }
            }
            if (minOneNum === false) {
                $scope.invalidMinutes = true;
                return;
            }

            minutes = minutes.toString();


            if (!(parseInt(minutes) >= 0 && parseInt(minutes) <= 59)) {
                $scope.invalidMinutes = true;
            } else
                $scope.invalidMinutes = false;
            //If the input box has no string, mark as invalid
            if (minutes.length < 1 || minOneNum === false) $scope.invalidMinutes = true;
            //If the input box has one digit, append zero before it
            else if (minutes.length === 1) $scope.tmpk.minutes = "0" + minutes;

            if ($scope.invalidMinutes === false) {
                updateTime();
            }
        }

        $scope.$watch('tmpk.minutes', function(nv, ov) {
            if (nv !== ov) {
                validateMinutes(nv);

            }
        });

        function validateSeconds(nv) {
            if (!vm.dateTimePickerCtrl.chooseTime || !vm.dateTimePickerCtrl.chooseSeconds) return;
            if (!angular.isDefined(nv)) return;
            $scope.invalidSeconds = (!angular.isString(nv) || nv.match(/^[0-5]?[0-9]$/) === null);
            if (!$scope.invalidSeconds) {
                // Zero padding
                $scope.tmpk.seconds = (nv.length < 2) ? "0" + nv : "" + nv;
                updateTime();
            }
        }

        $scope.$watch('tmpk.seconds', function(nv, ov) {
            if (nv !== ov) {
                validateSeconds(nv);
            }
        });

        $scope.$watch('tmpk.meridian', function(nv, ov) {
            if (nv !== ov) {
                //update vm.dateTimePickerCtrl.value.time here
                updateTime();
            }
        });

        //When isMeridian value changes, validate hours and minutes again
        $scope.$watch('isMeridian', function(nv, ov) {
            // Fix hours when switching between 24h and 12h
            if (ov === false && nv === true && $scope.tmpk.hours > 12) {
                $scope.tmpk.hours = (parseInt($scope.tmpk.hours, 10) - 12).toString();
            }
            else if (ov === true && nv === false && $scope.tmpk.meridian === "PM") {
                $scope.tmpk.hours = (parseInt($scope.tmpk.hours, 10) + 12).toString();
            }
            validateHours($scope.tmpk.hours);
            validateMinutes($scope.tmpk.minutes);
            validateSeconds($scope.tmpk.seconds);
        });

        $scope.$watch('tmpk.timezone', function(nv, ov) {
            if (nv !== ov) {
                //update vm.dateTimePickerCtrl.value.timezone here
                updateTimezone();
            }
        });

        vm.toggleMeridian = function() {
            //do the toggling here
            $scope.tmpk.meridian = $scope.tmpk.meridian === "AM" ? "PM" : "AM";
        };

        vm.selectTimezone = function(index) {
            //update the selected timezone here
            vm.timezone = vm.dateTimePickerCtrl.timezones[index];
        };
    }
})();
;
(function() {
      
    angular.module('hpe.elements.dateTimePicker').directive("timePicker", timePicker);

    function timePicker() {
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            templateUrl: 'dateTimePicker/templates/timePicker.html',
            require: '^dateTimePicker',
            controller: 'timePickerCtrl as tmpk'
        };
    }
})();
;
(function () {
  
  angular.module("hpe.elements.displayPanels", ["hpe.elements.templates"]);
})();;
(function () {
  
  angular.module('hpe.elements.displayPanels').directive('displayPanel', displayPanel);
  displayPanel.$inject = ["displayPanelFactory"];

  function displayPanel(displayPanelFactory) {
    return {
      restrict: 'A',
      templateUrl: 'displayPanels/displayPanel/template/displayPanel.html',
      link: function (scope, element) {

        //get the document display region
        var displayRegion = element[0].getElementsByClassName('display-scroll')[0];

        //if there is a footer then lets get it
        var footer = element[0].getElementsByClassName('footer');

        function calculateScrollRegion() {

          //get the starting position of the scrollable region
          var top = displayRegion.getBoundingClientRect().top;

          //if a footer was found get its top position otherwise we will use the window height
          var bottom = (footer && footer.length > 0) ? footer[0].getBoundingClientRect().top : bottom = window.innerHeight;

          //set the default bottom padding
          var padding = 10;

          //calculate the new height of the region
          var height = bottom - top - padding;

          //set the display region height
          displayRegion.style.height = height + 'px';

        }

        window.addEventListener('resize', calculateScrollRegion);
        window.addEventListener('scroll', calculateScrollRegion);

        scope.previousBtnStatus = displayPanelFactory.getButtonStatus()[0];
        scope.nextBtnStatus = displayPanelFactory.getButtonStatus()[1];

        scope.close = function () {

          var displayPanel = angular.element(".display-panel");

          //checks if the panel has animate class
          if (displayPanel.hasClass("display-panel-animate")) {

            //starts the animation
            displayPanel.get(0).style.width = '0';

            //removes the panel after the animation
            displayPanel.one('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend', function () {
              displayPanelFactory.removeDisplayPanel();
            });
          } else
            displayPanelFactory.removeDisplayPanel();
        };

        scope.previous = function () {
          scope.previousBtnStatus = true;
          scope.$broadcast('gotoPrevious');
        };
        scope.next = function () {
          scope.nextBtnStatus = true;
          scope.$broadcast('gotoNext');
        };

        scope.$on("$destroy", function () {
          //ensure we close the display panel
          scope.close();
          window.removeEventListener('resize', calculateScrollRegion);
          window.removeEventListener('scroll', calculateScrollRegion);
        });
      }
    };
  }
})();;
(function() {
  
    angular.module('hpe.elements.displayPanels').directive('displayPanelContainer', displayPanelContainer);
    displayPanelContainer.$inject = ["$document", "$window", "displayPanelFactory", "$timeout"];

    function displayPanelContainer($document, $window, displayPanelFactory, $timeout) {
        return {
            restrict: 'A',
            scope: true,
            link: function(scope, element) {

                // store reference to native element for must faster dom querying
                var nativeElement = element.get(0);

                var containerClickHandler = function(e) {

                    if (angular.element(e.target).parents('.displayPanel').length === 0) {

                        var displayPanel = angular.element(".display-panel");
                        
                        //checks if the panel has animate class
                        if (displayPanel.hasClass("display-panel-animate")) {

                            //starts the animation
                            displayPanel.get(0).style.width = '0';

                            //removes the panel after the animation
                            displayPanel.one('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend', function() {
                                displayPanelFactory.removeDisplayPanel();
                            });
                        } else
                            displayPanelFactory.removeDisplayPanel();
                    }
                };

                $document.on('click', undefined, containerClickHandler);

                var win = angular.element($window);
                var affixDisplayPanel = new AffixDisplayPanel(displayPanelFactory);

                //Affix is set on scrolling.
                var affixOnScrollEventHandler = function() {
                    affixDisplayPanel.currentScrollPosition = win.scrollTop();

                    if (displayPanelFactory.getReference() !== undefined && displayPanelFactory.getReference() !== "") {
                        affixDisplayPanel.update();
                    }
                };
                win.on('scroll', undefined, affixOnScrollEventHandler);

                // once rendered then check to ensure indexes!
                $timeout(function() {
                    
                    // ensure that all child display-panel-items have indexes
                    var displayPanelItems = nativeElement.querySelectorAll('[display-panel-item]');

                    // filter out items with an index
                    var indexed = [];

                    // iterate each panel items
                    for(var idx = 0; idx < displayPanelItems.length; idx++) {

                        // get the current node
                        var node = displayPanelItems[idx];

                        // store a reference to all elements with an index attribute
                        if(node.hasAttribute('index')) indexed.push(node);
                    }

                    // if all display panel items have an index then we are good to go!
                    if(displayPanelItems.length === indexed.length) return;

                    // if no items has an index then we will index them automatically
                    if(indexed.length === 0) {

                        // iterate each display panel item to add attribute 
                        for(var index = 0; index < displayPanelItems.length; index++) {

                            // get the current node
                            var panel = displayPanelItems[index];

                            // add index attribute - (add one as we will start from 1 rather than 0)
                            panel.setAttribute('index', index + 1);
                        }

                        return;
                    }

                    // if we get to this point then the user has some items with an index and others without. 
                    // This is going to cause some problems and we cannot fix it for them
                    console.log('Elements - Some \'display-panel-item\' elements have an index while others do not. This can cause errors! Add an \'index\' attribute to each \'display-panel-item\' element');
                    
                });

                scope.$on("$destroy", function() {
                    displayPanelFactory.removeDisplayPanel();
                    win.off("scroll", undefined, affixOnScrollEventHandler);
                    $document.off('click', undefined, containerClickHandler);
                });
            }
        };
    }

    function AffixDisplayPanel(displayPanel) {

        // Display Panel - operations are performed here.
        this.displayPanel = displayPanel;
        //check whether element is fixed.
        this.affixed = false;
        // check if the triggerelement is set
        this.triggerSet = false;
        //update the trigger only once.
        this.trigger = 0;
        //previous values
        //we must keep track of previous values as if they change we must update UI elements
        //previous scrollPosition
        this.previousScrollPosition = 0;
        //current scrollPosition - will be updated by event handler outside this object
        this.currentScrollPosition = 0;
    }

    AffixDisplayPanel.prototype.updateTrigger = function(element) {
            if (this.triggerSet === false) {
                this.triggerSet = true;
                this.trigger = element.offsetTop;
            }
            return this.trigger;
        };
        /*
         * # Updates the element
         * decides whether the object should be stuck or not
         * will only execute if the scroll position has changed.
         */
    AffixDisplayPanel.prototype.update = function() {
        if (this.currentScrollPosition !== this.previousScrollPosition) {
            var element = angular.element(this.displayPanel.getReference());
            var el = element[0];
            if (el !== undefined) {
                var trigger = this.updateTrigger(el) + el.offsetHeight;
                if (this.currentScrollPosition > trigger && !this.affixed) {
                    if (!element.hasClass('.affix-element')) {
                        this.displayPanel.getDisplayPanel().css('top', 0 + 'px').addClass('fixed-display-panel').removeClass('float-display-panel');
                    } else {
                        this.displayPanel.getDisplayPanel().css('top', el.offsetTop + el.scrollHeight + "px").addClass('fixed-display-panel').removeClass('float-display-panel');
                    }
                    this.affixed = true;
                    this.displayPanel.fixed(true);
                } else if (this.currentScrollPosition <= trigger && this.affixed) {
                    this.displayPanel.getDisplayPanel().css('top', this.displayPanel.getTop()).addClass('float-display-panel').removeClass('fixed-display-panel');
                    this.affixed = false;
                    this.triggerSet = false;
                    this.trigger = 0;
                    this.displayPanel.fixed(false);
                }
            }
            this.previousScrollPosition = this.currentScrollPosition;
        }
    };
})();
;
(function () {
  
  angular.module('hpe.elements.displayPanels').factory('displayPanelFactory', displayPanelFactory);

  function displayPanelFactory() {
    var displayPanelFactory = {};

    var element = '.displayPanel';
    var displayElement = '.display-panel';
    var displayPanel = new DisplayPanelFactory(element, displayElement);
    var previousButton = true;
    var nextButton = true;

    displayPanelFactory.getDisplayPanel = function() {
     return displayPanel.getDisplayElement();
   };
    displayPanelFactory.setButtonStatus = function(p,n) {
      previousButton = p;
      nextButton = n;
    };
    displayPanelFactory.getButtonStatus = function(){
        return [previousButton,nextButton];
    };

    displayPanelFactory.removeDisplayPanel = function() {
      displayPanel.getElement().remove();
    };

    displayPanelFactory.setDisplayPanel = function(reference, top) {
      displayPanel.setValues(reference, top);
    };
    displayPanelFactory.getTop = function() {
      return displayPanel.getTop();
    };
    displayPanelFactory.getReference = function() {
      return displayPanel.getReference();
    };
    displayPanelFactory.fixed = function(value) {
     return displayPanel.setFixed(value);
   };
    displayPanelFactory.isFixed = function() {
     return displayPanel.getFixed();
   };


    return displayPanelFactory;
  }

  function DisplayPanelFactory(element, displayElement) {
    this.element = element;
    this.displayElem = displayElement;
    this.reference = "";
    this.top = 0;
    this.fixed = false;
  }

  DisplayPanelFactory.prototype.getFixed = function () {
   return this.fixed;
 };
  DisplayPanelFactory.prototype.setFixed = function(value) {
   this.fixed = value;
 };
  DisplayPanelFactory.prototype.getDisplayElement = function() {
    return angular.element(this.displayElem);
  };
  DisplayPanelFactory.prototype.getElement = function() {
    return angular.element(this.element);
  };

  DisplayPanelFactory.prototype.setValues  = function(reference, top) {
    this.reference = reference;
    this.top = top;
  };

  DisplayPanelFactory.prototype.getReference = function() {
   return this.reference;
 };
  DisplayPanelFactory.prototype.getTop = function() {
   return this.top;
 };

 })();
;
(function () {
  
  angular.module('hpe.elements.displayPanels').directive('displayPanelItem', displayPanelItem);
  displayPanelItem.$inject = ["$compile", "$document", "$templateRequest", "$q", "$timeout", "displayPanelFactory", "safeTimeout", "keyboardNavigationService"];

  function displayPanelItem($compile, $document, $templateRequest, $q, $timeout, displayPanelFactory, safeTimeout, keyboardNavigationService) {
    return {
      restrict: 'A',
      scope: {
        displayPanelItem: "=",
        shadow: "="
      },
      link: function (scope, element) {
        var body = $document.find('body').eq(0);
        var modalDomEl = "";
        var keyService = keyboardNavigationService;
        var animate = scope.displayPanelItem.animate || false;
        var safeTimeoutInstance = safeTimeout.create(scope);

        // extended in the future to opt between template and templateUrl.
        function getTemplatePromise(options) {
          return $templateRequest(options);
        }

        //extended in the future to accomodate angular resolves// if needed.
        function getResolvePromises() {
          return [];
        }

        function loadTemplate() {
          var templateAndPromise = $q.all([getTemplatePromise(scope.modalOpt.main)].concat(getResolvePromises()));
          //to only animate if panel if not displayed
          var displayed = angular.element(".display-panel").length;

          templateAndPromise.then(function resolveSuccess(tpl) {
            if (scope.modalOpt.scope !== null) {
              scope.modalOpt.mainEl = $compile(tpl[0])(scope.modalOpt.scope);
            } else {
              scope.modalOpt.mainEl = tpl[0];
            }
            var angularDomEl = angular.element('<div display-panel class="displayPanel"></div>');
            modalDomEl = $compile(angularDomEl)(scope);

          });

          templateAndPromise.finally(function () {
            $timeout(function () {
              //stop animation if the panel is already opened
              if (displayPanelFactory.getDisplayPanel().length !== 0) {
                displayPanelFactory.removeDisplayPanel();
              }

              if (animate) {
                var panel = modalDomEl.find('.display-panel');

                if (displayed === 0) {
                  //set initial width to 0
                  panel.get(0).style.width = '0';
                }

                //add animate class
                panel.addClass('display-panel-animate');
              }

              body.append(modalDomEl);

              angular.element('.displayPanel .main').append(scope.modalOpt.mainEl);
              if (displayPanelFactory.isFixed()) {
                displayPanelFactory.getDisplayPanel().addClass('fixed-display-panel');
                scope.top = 0;
              } else {
                scope.top = scope.modalOpt.top;
              }

              if (animate && displayed === 0) {

                //animate panel
                var displayPanel = angular.element(".display-panel");
                //perform animation
                safeTimeoutInstance.timeout(function () {
                  displayPanel.get(0).style.width = '';
                });

              }
            });
          });
        }

        function animatePanel() {
          var displayPanel = angular.element(".display-panel");

          if (displayPanel.length !== 0) {
            //start animation
            displayPanel.get(0).style.width = '0';

            //remove panel after animation finishes
            displayPanel.one('webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend', function () {
              displayPanelFactory.removeDisplayPanel();
            });
          }
        }

        // when focusing on an item determine whether the prev/next button should be enabled
        // and show panel for item if panel is already open
        element.on('focus', function() {
          if (element.is(':first-child'))
            displayPanelFactory.setButtonStatus(true, false);
          if (element.is(':last-child'))
            displayPanelFactory.setButtonStatus(false, true);
          if (!element.is(':first-child') && !element.is(':last-child'))
            displayPanelFactory.setButtonStatus(false, false);

          if (displayPanelFactory.getDisplayPanel().length)
            $timeout(showItemDisplayPanel);
          });

        // show item display panel on click
        element.on('click', function(evt) {
          evt.preventDefault();
          evt.stopPropagation();   
          showItemDisplayPanel();
        });
        
        // when clicking Previous button go to previous item
        scope.$on('gotoPrevious', function () {
          goToPrevious();
        });

        // when clicking Next button go to next item
        scope.$on('gotoNext', function () {
          goToNext();
        });
        
        // this will be the item we are focusing on
        var goToItem = element;
        
        // up keypress - go to previous item
        keyService.keydown(element, 38, function(evt) {
          evt.preventDefault();
          goToPrevious();
        });

        function goToPrevious() {
          goToItem = element.prev('[display-panel-item]');
          goToItem.focus();
        }

        // down key press - go to next item
        keyService.keydown(element, 40, function(evt) {
          evt.preventDefault();
          goToNext();
        });

        function goToNext() {
          goToItem = element.next('[display-panel-item]');
          goToItem.focus();
        }

        // pg up key press - go to 10th previous item or 1st item if not possible
        keyService.keydown(element, 33, function(evt) {
          evt.preventDefault();
          var itemToJumpTo = element.prevAll('[display-panel-item]');
          if (itemToJumpTo.length) {
            goToItem = element.prevAll('[display-panel-item]:eq(10)').length ? element.prevAll('[display-panel-item]:eq(10)') : itemToJumpTo[itemToJumpTo.length - 1];
            goToItem.focus();
          }
        });

        // pg down key press - go to 10th next item or last item if not possible
        keyService.keydown(element, 34, function(evt) {
          evt.preventDefault();
          var itemToJumpTo = element.nextAll('[display-panel-item]');
          if (itemToJumpTo.length) {
            goToItem = element.nextAll('[display-panel-item]:eq(10)').length ? element.nextAll('[display-panel-item]:eq(10)') : itemToJumpTo[itemToJumpTo.length - 1];
            goToItem.focus();
          }
        });

        // home key press - go to the first item
        keyService.keydown(element, 36, function(evt) {
          evt.preventDefault();
          goToItem = element.prevAll('[display-panel-item]:last');
          goToItem.focus();
        });

        // end key press - go to the last item
        keyService.keydown(element, 35, function(evt) {
          evt.preventDefault();
          goToItem = element.nextAll('[display-panel-item]:last');
          goToItem.focus();
        });

        // esc key press - if display panel is open, close it. Otherwise blur focus on item
        keyService.keydown(element, 27, function(evt) {
          evt.preventDefault();
          if (displayPanelFactory.getDisplayPanel().length) {
            if (animate) {
              animatePanel();
            } else
              displayPanelFactory.removeDisplayPanel();
          } else {
            element.blur();
          }  
        });

        // enter key press - show the display panel 
        keyService.keydown(element, 13, function() {
          $timeout(showItemDisplayPanel);
        });

        // update the scope and show the display panel
        function showItemDisplayPanel() {
          scope.modalOpt = scope.displayPanelItem;
          displayPanelFactory.setDisplayPanel(scope.modalOpt.reference, scope.modalOpt.top);
          loadTemplate();
        }

      }
    };
  }
  
})();;
(function () {  
  angular.module("hpe.elements.draggableCards", ["hpe.elements.templates"]);
})();
;
(function () {
  
  angular.module("hpe.elements.draggableCards").directive("draggableCard", draggableCard);

  function draggableCard() {
    return {
      restrict: "E",
      templateUrl: 'draggableCards/template/draggableCard.html',
      replace: true,
      transclude: true,
      scope: {
        cardTitle: '=?',
        cardSubtitle: '=?',
        cardSelected: '=?',
        cardIcons: '=?',
        disableRemove: '=?',
        disableEdit: '=?'
      },
      link: function (scope, element) {

        //if the card is the default selected card then set an attribute on it
        if (scope.cardSelected && scope.cardSelected === true) {
          element[0].setAttribute('default-selected-card', '');
        }

        //get parent element properties
        var parentScope = element.parent().scope();

        //find out whether we are allowed to edit or remove
        var allowEditing = (parentScope.allowEditing !== null && parentScope.allowEditing !== undefined) ? parentScope.allowEditing : true;
        var allowRemoving = (parentScope.allowRemoving !== null && parentScope.allowRemoving !== undefined) ? parentScope.allowRemoving : true;
        var allowReordering = (parentScope.allowReordering !== null && parentScope.allowReordering !== undefined) ? parentScope.allowReordering : true;

        //find out if we have the necessary functions to edit and remove
        var hasEditFunc = (parentScope.onEdit !== null && parentScope.onEdit !== undefined);
        var hasRemoveFunc = (parentScope.onRemove !== null && parentScope.onRemove !== undefined);

        scope.allowEditing = hasEditFunc && allowEditing;
        scope.allowRemoving = hasRemoveFunc && allowRemoving;
        scope.allowReordering = allowReordering;

        //show header if any of the properties have been set
        scope.showTitle = scope.cardTitle || scope.cardSubtitle;
        scope.showHeader = scope.showTitle || scope.allowEditing || scope.allowRemoving;

      }
    };
  }
})();;
(function () {
  
  angular.module("hpe.elements.draggableCards").directive("fixedCard", fixedCard);

  function fixedCard() {
    return {
      restrict: "E",
      templateUrl: 'draggableCards/template/fixedCard.html',
      replace: true,
      scope: {
        cardTitle: '=',
        cardSubtitle: '=?',
        cardSelected: '=?'
      },
      link: function (scope, element) {

        //if the card is the default selected card then set an attribute on it
        if (scope.cardSelected && scope.cardSelected === true) {
          element[0].setAttribute('default-selected-card', '');
        }

      }
    };
  }
})();;
(function () {
  
  angular.module("hpe.elements.draggableCards").directive("draggableCards", draggableCards);

  draggableCards.$inject = ['safeTimeout', 'safeEventListener'];

  function draggableCards(safeTimeout, safeEventListener) {
    return {
      restrict: "E",
      templateUrl: 'draggableCards/template/draggableCards.html',
      replace: true,
      transclude: true,
      scope: {
        allowEditing: '=?',
        allowRemoving: '=?',
        allowReordering: '=?',
        onEdit: '=?',
        onRemove: '=?',
        onReorder: '=?',
        onSelect: '=?',
        direction: '@?'
      },
      link: function (scope, element) {

        //store some things in this context
        var draggableContainer, cardElements, draggableTop, draggableBottom, draggableCards = [],
          fixedCards = [],
          draggingCard, dragging = false,
          cardCount = 0;

        //identify the container element
        draggableContainer = angular.element(element[0].getElementsByClassName('draggable-card-container')[0]);

        //create a scope safe timeout
        var timeoutInstance = safeTimeout.create(scope);
        var safeEventInstance = safeEventListener.create(scope);

        //initialise tiny scrollbar
        var scrollPane = element.jScrollPane({
          resizeSensor: true,
          verticalGutter: -9,
          enableKeyboardNavigation: true,
          isScrollableH: false
        });

        var api = scrollPane.data('jsp');

        //start timeout - this will callback when the child components have been rendered
        timeoutInstance.timeout(initialise);

        function initialise() {

          //get the card containers and store them
          cardElements = draggableContainer[0].getElementsByClassName('card-container');
          cardCount = cardElements.length;

          //order the cards
          orderCards();

          //prepare cards - add click handlers and position them top
          prepareCards();

          //add event listener to capture dragging
          safeEventInstance.bind(document, 'mousemove', onDrag);
          //add event listener to add keyboard control
          safeEventInstance.bind(document, 'keydown', accesibility);

          // set up an observer to watch for any changes to the number of cards
          var observer = new MutationObserver(cardsHaveChanged);

          // begin observations
          observer.observe(draggableContainer[0], {
            childList: true,
            subtree: true
          });

          // tidy up on scope destroy
          scope.$on('$destroy', function () {
            observer.disconnect();
          });

          selectDefault();

          //ensure we can handle resize events
          element.resize(function () {
            reorderCards();

            draggableContainer[0].style.height = '';
            draggableContainer[0].style.minHeight = element.height() + 'px';
            draggableContainer.height(draggableContainer[0].scrollHeight);
          });
        }

        function cardsHaveChanged() {
          var childNodes = draggableContainer[0].getElementsByClassName('card-container');

          if (childNodes.length !== cardCount) {
            cardCount = childNodes.length;
            reorderCards();
            prepareCards();
            return;
          }

          for (var i = 0; i < childNodes.length; i++) {
            var processed = childNodes[i].getAttribute('reorder') !== null;

            if (!processed) {
              reorderCards();
              prepareCards();
            }
          }
        }

        function selectDefault() {
          for (var i = 0; i < cardElements.length; i++) {
            var card = cardElements[i];

            var selected = card.getAttribute('default-selected-card');

            if (selected !== null)
              selectCard(cardFromContainer(card));
          }
        }

        function prepareCards() {

          //create wrapper function - pass the element from the event to the function
          var click = function (event) {
            if (dragging) return;

            //if the click was on the drag handle then ignore it
            if (angular.element(event.srcElement).hasClass('drag-handle')) return;

            //if the click was on an icon then ignore it
            if (angular.element(event.scrElement).hasClass('draggable-icon')) return;

            //fire select event
            selectCard(event.currentTarget);
          };

          var onArrowUpClick = function (evt) {
            //if dragging then we dont want to do anything
            if (dragging) return;

            //get the card element
            var container = $(evt.currentTarget).closest('.card')[0];

            //call appropriate function
            moveUp(container);

            //stop event bubbling up to select card
            evt.stopPropagation();
          };

          var onArrowDownClick = function (evt) {
            //if dragging then we dont want to do anything
            if (dragging) return;

            //get the card element
            var container = $(evt.currentTarget).closest('.card')[0];

            //call appropriate function
            moveDown(container);

            //stop event bubbling up to select card
            evt.stopPropagation();
          };

          var onEditClick = function (evt) {
            //if dragging then we dont want to do anything
            if (dragging) return;

            //get the card element
            var container = $(evt.currentTarget).closest('.card')[0];

            if (container.querySelector(".title-container .hpe-edit").classList.contains("disabled")) return;

            //call appropriate function
            editCard(container);

            //stop event bubbling up to select card
            evt.stopPropagation();
          };

          var onRemoveClick = function (evt) {
            //if dragging then we dont want to do anything
            if (dragging) return;

            //get the card element
            var container = $(evt.currentTarget).closest('.card')[0];

            if (container.querySelector(".title-container .close-btn").classList.contains("disabled")) return;

            //call appropriate function
            removeCard(container);

            //stop event bubbling up to select card
            evt.stopPropagation();
          };

          //iterate through each card container
          for (var i = 0; i < cardElements.length; i++) {

            if (cardElements[i].getAttribute('reorder') !== null) continue;

            //get the card element from each container
            var card = cardFromContainer(cardElements[i]);
            var dragHandle = card.getElementsByClassName('drag-handle');
            var upArrow = card.getElementsByClassName('arrow-up');
            var downArrow = card.getElementsByClassName('arrow-down');
            var editBtn = card.getElementsByClassName('editing-btn');
            var closeBtn = card.getElementsByClassName('close-btn');

            //set attribute so we know if it has been processed
            cardElements[i].setAttribute('reorder', '');

            //add event listeners
            card.addEventListener('click', click);

            if (upArrow && upArrow.length > 0)
              upArrow[0].addEventListener('click', onArrowUpClick);

            if (downArrow && downArrow.length > 0)
              downArrow[0].addEventListener('click', onArrowDownClick);

            if (editBtn && editBtn.length > 0)
              editBtn[0].addEventListener('click', onEditClick);

            if (closeBtn && closeBtn.length > 0)
              closeBtn[0].addEventListener('click', onRemoveClick);

            if (dragHandle && dragHandle.length > 0)
              dragHandle[0].addEventListener('mousedown', dragCard);
          }
        }

        function editCard(element) {
          var parentScope = angular.element(element.parentNode).scope();

          if (scope.onEdit) {
            scope.onEdit.apply(parentScope, [parentScope, element]);
          }
        }

        function removeCard(element) {
          var parentScope = angular.element(element.parentNode).scope();

          //get height of the container before the card is removed
          var oldHeight = parseInt(draggableContainer[0].style.height);

          if (scope.onRemove) {
            scope.onRemove.apply(parentScope, [parentScope, element]);
          }

          //wait for digest
          timeoutInstance.timeout(function () {
            //get height of the container after card is removed
            var newHeight = parseInt(draggableContainer[0].style.height);
            //scroll up to correct the container size change
            api.scrollByY(-(oldHeight - newHeight));
          });

        }

        function getFixedCards() {
          //get the latest card elements
          cardElements = draggableContainer[0].getElementsByClassName('card-container');

          var fixed = [];

          //group cards by type - ie. fixed or draggable
          for (var i = 0; i < cardElements.length; i++) {
            //get the card element from each container
            var card = angular.element(cardFromContainer(cardElements[i]));

            if (card.hasClass('fixed'))
              fixed.push(cardElements[i]);
          }

          return fixed;
        }

        function getDraggableCards() {
          //get the latest card elements
          cardElements = draggableContainer[0].getElementsByClassName('card-container');

          var draggable = [];

          //group cards by type - ie. fixed or draggable
          for (var i = 0; i < cardElements.length; i++) {
            //get the card element from each container
            var card = angular.element(cardFromContainer(cardElements[i]));

            if (card.hasClass('draggable'))
              draggable.push(cardElements[i]);
          }

          return draggable;
        }

        function reorderCards() {

          //initial top offset
          var top = 5;

          //revert values of stored draggable cards and fixed cards
          fixedCards = getFixedCards();
          draggableCards = getDraggableCards();

          var comparator = function (a, b) {
            var aProcessed = a.getAttribute('reorder') !== null;
            var bProcessed = b.getAttribute('reorder') !== null;

            //if one of them is not processed then move it to the bottom of the list
            if (!aProcessed && bProcessed) return 1;
            if (aProcessed && !bProcessed) return -1;

            var aTop = a.offsetTop;
            var bTop = b.offsetTop;

            if (aTop < bTop) return -1;
            if (aTop > bTop) return 1;
            return 0;
          };

          //sort each by offset and whether or not they have been previously ordered
          fixedCards.sort(comparator);
          draggableCards.sort(comparator);

          //now position cards based on their order
          for (var f = 0; f < fixedCards.length; f++) {
            //position each fixed card at the top
            var fixedCard = fixedCards[f];

            //set top position
            fixedCard.style.position = 'absolute';
            fixedCard.style.top = top + 'px';

            //store new top
            top += $(fixedCard).outerHeight(true);
          }

          //store upper bound
          draggableTop = top;

          for (var d = 0; d < draggableCards.length; d++) {
            //position each fixed card at the top
            var draggableCard = draggableCards[d];

            //set top position
            draggableCard.style.position = 'absolute';
            draggableCard.style.top = top + 'px';

            //store new top
            top += $(draggableCard).outerHeight(true);
          }

          //store lower bound
          draggableBottom = top;

          //find list base
          var listBase = draggableContainer[0].getElementsByClassName('list-base')[0];
          listBase.style.top = draggableBottom + 'px';

          //clear previous height - then set new one
          draggableContainer[0].style.height = '';
          draggableContainer[0].style.minHeight = element.height() + 'px';
          draggableContainer.height(draggableContainer[0].scrollHeight);

        }

        function orderCards() {

          var top = 5;

          //group cards by type - ie. fixed or draggable
          fixedCards = getFixedCards();
          draggableCards = getDraggableCards();

          //set the positions of each card
          for (var f = 0; f < fixedCards.length; f++) {
            //position each fixed card at the top
            var fixedCard = fixedCards[f];

            //set top position
            fixedCard.style.position = 'absolute';
            fixedCard.style.top = top + 'px';

            //store new top
            top += $(fixedCard).outerHeight(true);
          }

          //store upper bound
          draggableTop = top;

          for (var d = 0; d < draggableCards.length; d++) {
            //position each fixed card at the top
            var draggableCard = draggableCards[d];

            //set top position
            draggableCard.style.position = 'absolute';
            draggableCard.style.top = top + 'px';

            //store new top
            top += $(draggableCard).outerHeight(true);
          }

          //store lower bound
          draggableBottom = top;

          //create a base element to maintain height
          var base = document.createElement('div');
          base.style.position = 'absolute';
          base.style.width = '100%';
          base.style.height = '1px';
          base.style.top = draggableBottom + 'px';
          base.className = 'list-base';

          draggableContainer.append(base);
          draggableContainer[0].style.minHeight = element.height() + 'px';
          draggableContainer.height(draggableContainer[0].scrollHeight);
        }

        function selectCard(element) {
          //deselect any currently selected cards
          deselectCards();

          //select the current card
          if (scope.direction) {
            if (scope.direction.toLowerCase() === 'left')
              angular.element(element).addClass('active left');
            else
              angular.element(element).addClass('active right');
          } else {
            angular.element(element).addClass('active right');
          }

          if (scope.onSelect) {
            var cardScope = angular.element(element.parentNode).scope();
            scope.onSelect.apply(cardScope, [cardScope, element]);
          }
        }

        function deselectCards() {
          for (var i = 0; i < cardElements.length; i++) {
            angular.element(cardElements[i]).removeClass('tabbed');
            angular.element(cardFromContainer(cardElements[i])).removeClass('active right');
          }
        }

        function cardFromContainer(container) {

          //ensure container exists
          if (!container) throw 'Cannot find card';

          //get card element
          var card = container.getElementsByClassName('card');

          //ensure card element exists
          if (!card || card.length === 0) throw 'Card container is empty';

          //return card element
          return card[0];
        }

        function moveUp(element) {
          var cardContainer = element.parentNode;
          var previousCard = getPreviousCard(cardContainer);

          //if there is no previous card then dont do anything
          if (previousCard === null) return;

          //other wise lets swap their order
          var previousTop = previousCard.offsetTop;
          var currentHeight = $(cardContainer).outerHeight(true);

          var currentTop = previousTop + 'px';
          previousTop = (previousTop + currentHeight) + 'px';

          //animate the new positions
          moveCard(cardContainer, currentTop);
          moveCard(previousCard, previousTop, notifyReorder);

        }

        function moveCard(element, position, callback) {
          $(element).animate({
            top: position
          }, {
            duration: 100,
            queue: false,
            complete: callback
          });
        }

        function moveDown(element) {
          var cardContainer = element.parentNode;
          var nextCard = getNextCard(cardContainer);

          //if there is no next card then dont do anything
          if (nextCard === null) return;

          //other wise lets swap their order
          var currentTop = cardContainer.offsetTop;
          var nextHeight = $(nextCard).outerHeight(true);

          var nextTop = currentTop + 'px';
          currentTop = (currentTop + nextHeight) + 'px';

          //animate the new positions
          moveCard(cardContainer, currentTop);
          moveCard(nextCard, nextTop, notifyReorder);
        }

        function notifyReorder() {
          //when animation is completed then call the reorder callback
          if (scope.onReorder) {
            var sortedCards = allSortedCards();

            var scopes = [];

            for (var i = 0; i < sortedCards.length; i++) {
              //get the scope of the current card
              scopes.push(angular.element(sortedCards[i]).scope());
            }

            scope.onReorder(scopes);
          }
        }

        function clearSelection() {
          if (document.selection) document.selection.empty();
          else if (window.getSelection) window.getSelection().removeAllRanges();
        }

        function dragCard(event) {
          dragging = true;

          //ensure we remove any text selection before dragging
          clearSelection();

          var card = $(event.currentTarget).closest('.card');
          var cardContainer = card.closest('.card-container');

          //add drag styling
          card.addClass('dragging');

          var release = function () {

            //remove drag styling
            card.removeClass('dragging');

            //remove document event listener
            document.removeEventListener('mouseup', release);

            //remove reference to the card being dragged
            draggingCard.mouseOffset = null;
            draggingCard = null;

            //required so that mouse up event doesn't select the dragged item
            setTimeout(function () {
              dragging = false;
            });

            //snap dragged card to the correct location
            reorderAfterDrag(true);
          };

          //add event listener to document
          document.addEventListener('mouseup', release);

          //store dragging card
          draggingCard = cardContainer[0];
        }

        function onDrag(event) {
          if (!draggingCard) return;

          clearSelection();

          var elementY = draggableContainer[0].getBoundingClientRect().top;
          var mouseY = event.pageY;
          var cardTop = draggingCard.offsetTop;

          //calculate position from top
          var offsetY = (mouseY - elementY) + draggableContainer[0].scrollTop;

          var cardHeight = $(draggingCard).outerHeight(true);

          if (!draggingCard.mouseOffset)
            draggingCard.mouseOffset = offsetY - cardTop;

          //new top position
          var newYPos = (offsetY - draggingCard.mouseOffset);

          //if valid position then move
          if (newYPos < draggableTop) {
            draggingCard.style.top = draggableTop + 'px';
            return;
          } else if ((newYPos + cardHeight) > draggableBottom) {
            draggingCard.style.top = (draggableBottom - cardHeight) + 'px';
            return;
          }

          draggingCard.style.top = (offsetY - draggingCard.mouseOffset) + 'px';

          //reorder the cards based on the current drag position
          reorderAfterDrag(false);
        }

        function reorderAfterDrag(notify) {

          var cards = sortedDraggedCards();

          var top = draggableTop;

          for (var d = 0; d < cards.length; d++) {
            //position each fixed card at the top
            var draggableCard = cards[d];

            if (draggingCard !== draggableCard) {
              //set top position
              draggableCard.style.top = top + 'px';
            }

            //store new top
            top += $(draggableCard).outerHeight(true);
          }

          if (notify) notifyReorder();
        }

        function getPreviousCard(cardContainer) {
          var cards = sortedCards();

          var currentIdx = cards.indexOf(cardContainer);

          if (currentIdx === -1) throw 'Could not find container';

          //if there is no previous card then return null
          if (currentIdx === 0) return null;

          //otherwise return previous card
          return cards[currentIdx - 1];
        }

        function getNextCard(cardContainer) {
          var cards = sortedCards();

          var currentIdx = cards.indexOf(cardContainer);

          if (currentIdx === -1) throw 'Could not find container';

          //if there is no next card then return null
          if (currentIdx === (cards.length - 1)) return null;

          //otherwise return previous card
          return cards[currentIdx + 1];
        }

        function sortedCards() {

          //return the cards in order of top position
          return draggableCards.sort(function (a, b) {
            var aTop = a.offsetTop;
            var bTop = b.offsetTop;

            if (aTop < bTop) return -1;
            if (aTop > bTop) return 1;
            return 0;
          });
        }

        function allSortedCards() {

          //convert html collection to array
          var cards = [];
          for (var i = 0; i < cardElements.length; i++) cards.push(cardElements[i]);

          //return the cards in order of top position
          return cards.sort(function (a, b) {
            var aTop = a.offsetTop;
            var bTop = b.offsetTop;

            if (aTop < bTop) return -1;
            if (aTop > bTop) return 1;
            return 0;
          });
        }

        function sortedDraggedCards() {

          return draggableCards.sort(function (a, b) {

            var aTop = a.offsetTop;
            var aHeight = $(a).outerHeight(true);
            var aMidpoint = (aTop + (aHeight / 2));
            var aBottom = (aTop + aHeight);

            var bTop = b.offsetTop;
            var bHeight = $(b).outerHeight(true);
            var bMidpoint = (bTop + (bHeight / 2));
            var bBottom = (bTop + bHeight);

            if (a === draggingCard) {

              //need to cover this quirk - weird IE sorting
              if (aTop < bTop) {
                if (aBottom > bMidpoint) return 1;
              } else {
                if (bBottom > aMidpoint) return -1;
              }
            }

            if (b === draggingCard) {
              //need to cover this quirk - weird IE sorting
              if (aTop < bTop) {
                if (bTop < aMidpoint) return 1;
              } else {
                if (aTop < bMidpoint) return -1;
              }
            }

            if (aTop < bTop) return -1;
            if (aTop > bTop) return 1;
            return 0;
          });
        }

        function accesibility(evt) {
          //if we are not focused on our element dont do anything
          if (draggableContainer[0] !== document.activeElement) return;

          //get sorted cards
          var cards = allSortedCards();

          var tabbedCard, tabbedIndex = -1;

          //find the current tabbed card
          for (var i = 0; i < cards.length; i++) {
            if ($(cards[i]).hasClass('tabbed')) {
              tabbedCard = cards[i];
              tabbedIndex = i;
              break;
            }
          }

          //return key
          if (evt.keyCode === 13) {
            if (!tabbedCard) return;

            //get card element and select it
            selectCard(cardFromContainer(tabbedCard));
          }

          //up arrow
          if (evt.keyCode === 38) {
            //if we are trying to move to a non existent tab then stop
            if (tabbedIndex <= 0) return;

            //get new selected card
            var previousIndex = tabbedIndex - 1;

            //detabbify the old card
            if (tabbedCard) $(tabbedCard).removeClass('tabbed');

            //tabbify the new card
            $(cards[previousIndex]).addClass('tabbed');
          }

          //down arrow
          if (evt.keyCode === 40) {
            //if we are trying to move to a non existent tab then stop
            if (tabbedIndex >= (cards.length - 1)) return;

            //get new selected card
            var nextIndex = tabbedIndex + 1;

            //detabbify the old card
            if (tabbedCard) $(tabbedCard).removeClass('tabbed');

            //tabbify the new card
            $(cards[nextIndex]).addClass('tabbed');
          }

        }
      }
    };
  }
})();;
(function () {  
  angular.module("hpe.elements.draggablePanels", []);
})();
;
(function () {
  
  angular.module("hpe.elements.draggablePanels").directive("dragHandle", dragHandle);

  function dragHandle() {
    return {
      restrict: "A",
      link: function (scope, element) {
        element.addClass('draggable-panel-handle');
      }
    };
  }
})();;
(function() {
  
  angular.module("hpe.elements.draggablePanels").directive("draggablePanel", draggablePanel);

  function draggablePanel() {
    return {
      restrict: "E",
      template: '<div class="draggable-panel" ng-transclude></div>',
      transclude: true,
      replace: true
    };
  }
})();
;
(function () {
  
  angular.module("hpe.elements.draggablePanels").directive("draggablePanelContainer", draggablePanelContainer);

  function draggablePanelContainer() {
    return {
      restrict: "E",
      scope: {
        draggableGroup: '@',
        draggableView: '@?',
        customPlaceholderSize: '@?',
        onDragStart: '=?',
        onDragOver: '=?',
        onDragEnd: '=?'
      },
      link: function (scope, element) {

        //get the group name or use the default one
        var groupName = scope.draggableGroup ? scope.draggableGroup : 'draggable';
        var draggableView = scope.draggableView ? scope.draggableView : false;
        var customPlaceholderSize = scope.customPlaceholderSize ? scope.customPlaceholderSize : false;



        if (draggableView) {
          if (draggableView === "card")
            element.find(".list").hide();

          if (draggableView === "list")
            element.find(".card").hide();
        }

        var displayView = function (panel) {

          var container = panel.item.parent()[0];

          if (container !== undefined && container !== null) {

            if (container.getAttribute('draggable-view') === "card") {
              angular.element(panel.item[0]).find(".card").show();
              angular.element(panel.item[0]).find(".list").hide();
            }

            if (container.getAttribute('draggable-view') === "list") {
              angular.element(panel.item[0]).find(".card").hide();
              angular.element(panel.item[0]).find(".list").show();
            }
          }

        };

        //add the group name to the element
        element.addClass(groupName);

        element.sortable({
          items: '.draggable-panel',
          handle: ".draggable-panel-handle",
          connectWith: '.' + groupName,
          tolerance: 'pointer',
          placeholder: 'sortable-placeholder',
          forcePlaceholderSize: !customPlaceholderSize,
          opacity: 0.8,
          start: function (evt, panel) {
            if (scope.onDragStart) scope.onDragStart.apply(this, [evt, panel]);
          },
          over: function (evt, panel) {
            if (scope.onDragOver) scope.onDragOver.apply(this, [evt, panel]);
          },
          stop: function (evt, panel) {
            if (draggableView) displayView(panel);
            if (scope.onDragEnd) scope.onDragEnd.apply(this, [evt, panel]);
          }
        });

      }
    };
  }
})();;
(function () {

  angular.module('hpe.elements.dropZone', []).directive("dropZone", dropZone);

  function dropZone() {
    return {
      restrict: 'EA',
      controller: 'FileUploadCtrl as vm',
      link: function (scope, element) {
        element.dropzone({
          maxFilesize: 100,
          paramName: "uploadfile",
          maxThumbnailFilesize: 5,
          init: function () {
            this.on('error', function (file, msg) {
              if (msg.length > 0) {
                this.removeAllFiles();
              }
            });
          }
        });
      }
    };
  }
})();;
(function () {
  
  angular.module("hpe.elements.elementReady", []).directive("elementReady", elementReady);

  function elementReady() {
    return {
      restrict: "A",
      link: function (scope, element, attrs) {
        element.ready(function () {
          scope.$eval(attrs.elementReady);
        });
      }
    };
  }
})();;
(function () {  
  angular.module("hpe.elements.expandInput", []);
})();;
(function () {

  angular.module('hpe.elements.expandInput').controller('ExpandInputCtrl', ExpandInputCtrl);

  ExpandInputCtrl.$inject = ['$element', '$window'];

  function ExpandInputCtrl($element, $window) {
    var vm = this;

    vm.expanded = false;
    vm.value = '';
    vm.iconBase = vm.clearTextIcon && vm.clearTextIcon.indexOf('hp-') === -1 ? 'hpe-icon' : 'hp-icon';

    // store reference to a few elements
    var nativeElement = $element.get(0);
    var navigationParent = findParentWithClass(nativeElement, 'nav');

    // needs to be jquery element here
    var inputElement = $element.find('input');

    // bind to window resize event
    $window.addEventListener('resize', resize);

    vm.updateState = function (expand) {

      // store whether or not the input control should be expanded
      vm.expanded = expand;

      // take into account the expandAlways property
      if (vm.expanded === true) {

        if (vm.expandAlways) {
          // setting search expanded value to true and can be handled in the front end.
          vm.expanded = true;
          showSearch();
        } else {
          //force a condition where search if not always shown does not show up in smaller viewport.
          if ($window.innerWidth > 768) {
            vm.expanded = true;
            showSearch();
          } else {
            vm.expanded = false;
          }
        }
      } else {
        showElement();
      }

      // if a focus callback is defined call it with the state
      if (vm.focus) {
        vm.focus({
          value: vm.expanded
        });
      }
    };

    vm.clear = function (event) {

      // clear the input value
      vm.value = '';

      // ensure we stop this event propagating
      event.preventDefault();
    };

    vm.close = function () {

      // collapse the input
      vm.updateState(false);

      showElement();
    };

    vm.keyPressed = function (event) {

      // if the key pressed was the return key and we have an onEnter event call it with the current value
      if (event.keyCode === 13 && vm.onEnter) {
        vm.onEnter(vm.value);
      }
    };

    vm.keyDown = function (event) {

      // if key pressed was escape then trigger a blur event on input
      if (event.keyCode === 27) {
        inputElement.blur();
      }
    };

    /*
      Private Functions Not Exposed to View
    */

    function resize() {

      // if we are not always expanding then shrink the input
      if (!vm.expandAlways) {

        // trigger a blur event on the element
        inputElement.blur();
      }
    }

    function showElement() {

      // remove class from the element
      nativeElement.classList.remove('expanded');

      // if we are in a navigation bar remove the class from it
      if(navigationParent !== null) {
        navigationParent.classList.remove('inputexpanded');
      }

      // find parent with show-search class
      var showSearch = findParentWithClass(nativeElement, 'show-search');

      // if exists then remove the class
      if(showSearch !== null) {
        showSearch.classList.remove('show-search');
      }

    }

    function showSearch() {

      // add expanded class to the element
      nativeElement.classList.add('expanded');
      
      // if element is in a navigation bar
      if(navigationParent !== null) {
        navigationParent.classList.add('inputexpanded');
      }
    }

    function findParentWithClass(element, className) {

      // iterate through all parent elements
      while(element.parentElement) {
        
        // get the parent element
        var parentElement = element.parentElement;

        // check if the parent element has the class we are looking for
        if(parentElement.classList.contains(className)) {
          return parentElement;
        }

        // set element equal to the parent
        element = parentElement;
      }

      return null;
    }

  }

})();;
(function() {

  angular.module("hpe.elements.expandInput").directive("expandInput", expandInput);

  function expandInput() {
    return {
      restrict: "EA",
      templateUrl: "expandInputs/template/expandInput.html",
      controller: "ExpandInputCtrl as vm",
      bindToController: true,
      replace: true,
      scope: {
        focus: "&",
        name: "@elname",
        placeHolder: "@",
        className: "@",
        clearTextIcon: "@",
        closeSearch: "@",
        expandAlways: "=",
        onEnter: "=?"
      }
    };
  }

})();;
(function () {
  
  angular.module('hpe.elements.expandSearch', []).directive('expandSearch', expandSearch);

  function expandSearch() {
    return {
      restrict: 'A',
      link: function (scope, element) {
        element.bind('click', function () {
          var parent = element.parents(".navbar-static-top").toggleClass("show-search");
          if (parent.hasClass("show-search")) {
            parent.find(".navbar-form-search input").focus();
          }
        });
      }
    };
  }
})();;
(function () {
  angular.module("hpe.elements.expandingTextarea", []);
})();
;
(function () {
  
  angular.module('hpe.elements.expandingTextarea').directive('expandingTextarea', expandingTextarea);

  function expandingTextarea() {
    return {
      restrict: 'A',
      link: function (scope, element, attrs) {
        var disableReturn = attrs.disableReturn ? (attrs.disableReturn.trim().toLowerCase() === 'true' ? true : false) : false;
        var maxVisibleLines = attrs.maxVisibleLines ? +attrs.maxVisibleLines : 0;

        $(element[0]).expandingTextarea({
          disableReturn: disableReturn,
          maxVisibleLines: maxVisibleLines
        });
      }
    };
  }
})();
;
(function () {
  
  angular.module("hpe.elements.extendedCheckboxHit", []).directive("extendedCheckboxHit", extendedCheckboxHit);

  function extendedCheckboxHit() {
    return {
      restrict: "A",
      link: function (scope, element) {
        element.on('click', function () {
          element.children("[multiple-list-select-item]").click();
          return false;
        });
      }
    };
  }
})();;
//this file has _module name so that it is picked up first by grunt-concat,
//any further module declarations should be added here.

(function () {
  angular.module("hpe.elements.facets", ["hpe.elements.templates"]);
})();;
(function () {
  
  angular.module("hpe.elements.facets").controller("FacetCtrl", FacetCtrl);

  FacetCtrl.$inject = ['$scope'];

  function FacetCtrl($scope) {
    var vm = this;
    vm.name = $scope.name;
    vm.expanded = true;
    vm.scrollConfig = {
      autoReinitialise: true,
      showOnlyOnHover: true,
      enableKeyboardNavigation: true
    };
    vm.toggleExpand = function ($event) {
      vm.expanded = !vm.expanded;
      $event.currentTarget.blur();
    };
    vm.toggleExpandKey = function ($event) {
      if ($event.keyCode === 13) {
        vm.expanded = !vm.expanded;
        $event.preventDefault();
      }
    };
  }

  FacetCtrl.prototype.register = function (fo) {
    if (!this.options) {
      this.options = [];
    }
    this.options.push(fo);
  };
})();;
(function() {
  
  angular.module("hpe.elements.facets").directive("facet", facet);
  facet.$inject = ["$rootScope", "$timeout"];

  function facet($rootScope, $timeout) {
    return {
      restrict: "E",
      templateUrl: "facets/facet/template/facet.html",
      transclude: true,
      replace: true,
      controller: "FacetCtrl as fac",
      scope: {
        name: "=",
        facetScroll: "@",
        loadDelay: "=?"
      },
      link: {
         pre: FacetDirectiveLinkFn
      }
    };

    function FacetDirectiveLinkFn (scope, element) {

      scope.enableScroll = (scope.facetScroll !== "off");

      var facetScrollContainer = [];
      var paneMaxHeight = null;

      $timeout(function() {
        // Check when ng-if has been resolved.
        facetScrollContainer = element.find('.facet-scroll');
        if (facetScrollContainer.length > 0) {
          //give the scroll container a unique id
          facetScrollContainer.uniqueId();

          scope.uniqueId = facetScrollContainer.attr('id');

          paneMaxHeight = getMaxHeight(facetScrollContainer);

          if (!(scope.loadDelay === undefined || scope.loadDelay <= 0)) {
            $timeout(reinitialize, scope.loadDelay);
          }
          scope.$watch('fac.expanded', function () {
            //this is done to re-initialise the custom scrollbar on facets
            $timeout(reinitialize, 100);
          });
          // Event to allow reinitialise to be triggered externally
          scope.$on("facet-reinitialise", function() {
            $timeout(reinitialize, 100);
          });
        }
      });

      scope.fac.reinitialize = function () {
        return reinitialize;
      }();

      function reinitialize() {
        if (facetScrollContainer.length > 0) {
          var jsp = facetScrollContainer.data("jsp");
          if (jsp) {
            jsp.reinitialise();

            // Since jspContainer does not shrink correctly after reinitialize I have taken the fix from this bug:
            // https://github.com/vitch/jScrollPane/issues/143
            resizeJsp(element, paneMaxHeight);
          }
        }
      }

      function getMaxHeight(elem) {
        var maxHeight = elem.css("max-height");
        if (maxHeight.indexOf("px") !== -1) {
          maxHeight = parseFloat(maxHeight);
          if (isNaN(maxHeight)) {
            maxHeight = null;
          }
        } else {
          maxHeight = null;
        }
        return maxHeight;
      }

      function resizeJsp(parentElem, paneMaxHeight) {
        var pane = parentElem.find(".jspPane");
        var container = parentElem.find(".jspContainer");

        var paneHeight = parentElem.innerHeight();

        // If pane is shorter than the maximum allowed height, grow the container
        if (paneMaxHeight !== null) {
          if (paneHeight < paneMaxHeight) {
            paneHeight = paneMaxHeight;
            container.css({
              height: paneMaxHeight + 'px'
            });
          }
        }

        // If the content has reduced in height, shrink the container
        if (pane.outerHeight() < paneHeight) {
          container.css({
            height: pane.outerHeight() + 'px'
          });
        }
      }

    }
  }
})();
;
(function () {
  
  angular.module("hpe.elements.facets").controller("FacetContainerCtrl", FacetContainerCtrl);

  FacetContainerCtrl.$inject = ['$scope', "previewPaneProvider"];

  function FacetContainerCtrl($scope, previewPaneProvider) {
    var vm = this;
    vm.selected = $scope.selected = [];
    vm.selectTitle = $scope.selectTitle;
    vm.clearText = $scope.clearText;
    vm.noItemsText = $scope.noItemsText;
    vm.scope = $scope;
    vm.scope.provider = previewPaneProvider;
    vm.clearAllFn = $scope.clearAllFn;

    vm.api = {
      getFacets: function () {
        var facets = [];

        for (var i in vm.container.facets) {

          var facet = vm.container.facets[i];
          var options = [];

          //Standard or Custom Facet
          if (!facet.selectedDynamicFacets) {
            if (facet.options) {
              for (var j = 0; j < facet.options.length; j++) {
                var option = facet.options[j];
                options[j] = {
                  select: function (o) {
                    return function () {
                      o.select();
                    };
                  }(option),
                  deselect: function (o) {
                    return function () {
                      o.deselect();
                    };
                  }(option),
                  toggle: function (o) {
                    return function () {
                      o.toggle();
                    };
                  }(option),
                  name: option.option.name
                };
              }
            }
          }
          //Dynamic Facets
          else if (facet.selectedDynamicFacets) {
            if (facet.scope && facet.scope.facetOptions && facet.scope.facetOptions.options) {
              var dynamicOptionsCombined = [];
              var nonDynamicOptionsCount = 0;

              for (var m in facet.options) {
                dynamicOptionsCombined.push({
                  dynamic: false,
                  option: facet.options[m].option.fo
                });
                nonDynamicOptionsCount++;
              }

              for (var k = nonDynamicOptionsCount; k < facet.scope.facetOptions.options.length; k++) {
                dynamicOptionsCombined.push({
                  dynamic: true,
                  option: facet.scope.facetOptions.options[k]
                });
              }

              for (var n in dynamicOptionsCombined) {
                //var dynamicOption = facet.scope.facetOptions.options[k];
                var dynamicOption = dynamicOptionsCombined[n].option;
                options[n] = {
                  select: function (o, f, d) {
                     return function () {
                      if (!d) {
                        //Option from the normal list - select via itself
                        o.select();
                      } else {
                        //Option from the typeahead - select via the facet
                       f.select(o, o, "");
                      }
                     };
                  }(dynamicOption, facet, dynamicOptionsCombined[n].dynamic),
                  deselect: function (o, f, d) {
                    return function () {
                      if (f.selectedDynamicFacets.length && d) {
                        var index = 0;
                        for (var fo in f.selectedDynamicFacets) {
                          if (f.selectedDynamicFacets[fo].option === o) {
                            break;
                          }
                          index++;
                        }
                        f.remove(null, index);
                      } else {
                        o.deselect();
                      }
                    };
                  }(dynamicOption, facet, dynamicOptionsCombined[n].dynamic),
                  name: dynamicOption.name
                };
              }
            }
          }



          facets[i] = {
            name: facet.name,
            options: options
          };
        }
        return facets;
      }
    };

    vm.container = {};
    vm.container.facets = [];
    //Return the facets for programatic selection
    if ($scope.api) {
      $scope.api = vm.api;
    }
  }

  FacetContainerCtrl.prototype.register = function (facet) {
    if (!this.hasFacet(facet.name)) {
      if (!this.container.facets) {
        this.container.facets = [];
      }
      this.container.facets.push(facet);
    }
  };

  FacetContainerCtrl.prototype.hasFacet = function (facetName) {
    return this.container.facets.some(function (facet) {
      return facet.name.toLowerCase() === facetName.toLowerCase();
    });
  };

  FacetContainerCtrl.prototype.addSelected = function (facetOptionCtrl) {
    var indexOfOption = this.selected.indexOf(facetOptionCtrl);
    if (indexOfOption === -1) {
      this.selected.push(facetOptionCtrl);
    }
  };

  FacetContainerCtrl.prototype.removeSelected = function (facetOptionCtrl) {
    var indexOfOption = this.selected.indexOf(facetOptionCtrl);
    if (indexOfOption >= 0) {
      this.selected.splice(indexOfOption, 1);
    }
  };

  FacetContainerCtrl.prototype.clearAll = function () {
    this.isClearAllFn = this.scope.isClearAllFn;
    for (var i = this.selected.length - 1; i >= 0; i--) {
      this.selected[i].deselect();
    }

    // if a clearAll function is defined, execute it.
    if (this.isClearAllFn) {
      this.clearAllFn();
      this.isClearAllFn = false;
    }
    this.scope.provider.preview.previewFile = "";
  };

})();;
(function () {
  
  angular.module("hpe.elements.facets").directive("facetContainer", facetContainer);

  function facetContainer() {
    return {
      restrict: "E",
      controller: "FacetContainerCtrl as fc",
      templateUrl: "facets/facetContainer/template/facetContainer.html",
      scope: {
        selectTitle: "@",
        clearText: "@",
        noItemsText: "@?",
        clearAllFn: "&?",
        api: "=?"
      },
      transclude: true,
      replace: true,
      link: function (scope, elem, attr) {
        // use the attr to check whether the property is defined
        scope.isClearAllFn = angular.isUndefined(attr.clearAllFn) === false;
      }
    };
  }
})();;
(function () {
  
  angular.module("hpe.elements.facets").controller("FacetCustomCtrl", FacetCustomCtrl);

  FacetCustomCtrl.$inject = ['$scope'];

  function FacetCustomCtrl($scope) {
    var vm = this;
    vm.scope = $scope;
    vm.name = $scope.name;
    vm.expanded = true;

    vm.toggleExpand = function ($event) {
      vm.expanded = !vm.expanded;
      $event.currentTarget.blur();
    };
    vm.toggleExpandKey = function ($event) {
      if ($event.keyCode === 13) {
        vm.expanded = !vm.expanded;
        $event.preventDefault();
      }
    };

    $scope.$watch('model', function (nV, oV) {
      if (!angular.equals(nV, oV)) {
        vm.scope.fo.deselect();
        if (nV !== "") {
          vm.scope.fo.option.displayName = vm.scope.display();
          vm.scope.fo.select();
        }
      }
    });

  }

  FacetCustomCtrl.prototype.register = function (fo) {
    if (!this.options) {
      this.options = [];
    }
    this.options.push(fo);
  };
})();;
(function () {
  
  angular.module("hpe.elements.facets").directive("facetCustom", facetCustom);

  facetCustom.$inject = ["$controller", "previewPaneProvider"];

  function facetCustom($controller, previewPaneProvider) {
    return {
      restrict: "E",
      require: ['^facetContainer'],
      templateUrl: "facets/facetCustom/template/facetCustom.html",
      transclude: true,
      replace: true,
      controller: "FacetCustomCtrl as fac",
      scope: {
        name: "=",
        select: "=",
        display: "=",
        deselect: "=",
        model: "="
      },
      link: function (scope, element, attrs, controllers) {
        scope.title = '' + scope.name;
        scope.fo = $controller("FacetOptionCtrl", {
          '$scope': scope,
          'previewPaneProvider': previewPaneProvider
        });
        scope.fo.facet = scope.fac;
        scope.fo.facetContainer = controllers[0];

        //Add the option to the facet
        scope.fo.facet.register(scope.fo);

        //Add the facet to the container
        scope.fo.facetContainer.register(scope.fo.facet);
      }
    };
  }
})();;
(function () {
 
  angular.module("hpe.elements.facets").controller("FacetDynamicCtrl", FacetDynamicCtrl);

  FacetDynamicCtrl.$inject = ['$scope'];

  function FacetDynamicCtrl($scope) {
    var vm = this;
    vm.scope = $scope;
    vm.name = $scope.name;
    vm.facetOptions = $scope.facetOptions;
    vm.visibleFacetOptions = [];
    vm.displayConfiguration = $scope.displayConfiguration;
    vm.placeholder = $scope.placeholder;
    vm.updateCallback = $scope.updateCallback;

    vm.minCharsForTypeahead = vm.displayConfiguration.minCharacters || 3;
    vm.showZero = vm.displayConfiguration.showZero;

    vm.selectedDynamicFacets = [];
    vm.dynamicTypeaheadSelected = {
      text: ""
    };

    vm.expanded = true;

    vm.toggleExpand = function ($event) {
      vm.expanded = !vm.expanded;
      $event.currentTarget.blur();
    };
    vm.toggleExpandKey = function ($event) {
      if ($event.keyCode === 13) {
        vm.expanded = !vm.expanded;
        $event.preventDefault();
      }
    };
    vm.updateFacetOptions();
  }


  //limit the number of facet options shown
  FacetDynamicCtrl.prototype.updateFacetOptions = function (updatedOptions) {

    //limit the number of facet options shown
    var vm = this;

    //Need to update facetOptions, in case of a change
    if (typeof updatedOptions !== "undefined")
      vm.facetOptions.options = updatedOptions;

    // Apply the changes to the other dependent properties of facetOptions
    vm.useTypeaheadControl = (vm.displayConfiguration.maxIndividualItems) ? vm.displayConfiguration.maxIndividualItems <= vm.facetOptions.options.length && (vm.displayConfiguration.minIndividualItems ? vm.displayConfiguration.minIndividualItems < vm.facetOptions.options.length : true) : true;
    vm.showFacetOptions = vm.displayConfiguration.minIndividualItems && vm.displayConfiguration.minIndividualItems > 0 ? true : !vm.useTypeaheadControl;
    vm.maxDisplayableItems = vm.displayConfiguration.maxDisplayableItems || vm.facetOptions.options.length;

    if (vm.showFacetOptions) {

      //if we are under the typeahead threshold then show all the items
      var maxItems = !vm.useTypeaheadControl ? vm.facetOptions.options : vm.displayConfiguration.minIndividualItems;

      var newOptions = [];

      vm.facetOptions.options.forEach(function (element) {
        if (newOptions.length >= maxItems) return false;
        if (element.count !== 0 || !vm.useTypeaheadControl || vm.showZero) newOptions.push(element);
      });

      vm.visibleFacetOptions = newOptions;
    }
  };

  FacetDynamicCtrl.prototype.remove = function (option, $index) {
    var vm = this;
    //call the FO deselect
    var filterOption = vm.selectedDynamicFacets[$index];
    if (filterOption.option.origDeselectFn) {
      filterOption.option.origDeselectFn.apply(filterOption);
    } else {
      filterOption.deselect();
    }
    //remove it from my list
    vm.selectedDynamicFacets.splice($index, 1);
  };

  FacetDynamicCtrl.prototype.select = function ($item) {
    var vm = this;
    //create FO control
    var filterOption = vm.foConstructor.$controller("FacetOptionCtrl", {
      '$scope': $item,
      'previewPaneProvider': vm.foConstructor.previewPaneProvider
    });

    filterOption.facetContainer = vm.foConstructor.facetContainer;
    //add it to my list of FOs
    vm.selectedDynamicFacets.push(filterOption);
    //decorate the deselect so that we can remove it later from the container panel too
    filterOption.option.origDeselectFn = angular.copy(filterOption.deselect);
    filterOption.deselect = function () {
      vm.remove(this.option, vm.selectedDynamicFacets.indexOf(this));
    };
    //trigger select
    filterOption.select();
    //clear the input text
    vm.dynamicTypeaheadSelected.text = "";
  };

  FacetDynamicCtrl.prototype.dynamicTypeaheadOnChange = function () {
    var vm = this;
    if (vm.updateCallback) {
      vm.facetOptions.options = vm.updateCallback(vm.dynamicTypeaheadSelected.text, vm.facetOptions.options);
    }
  };

  FacetDynamicCtrl.prototype.register = function (fo) {
    if (!this.options) {
      this.options = [];
    }
    this.options.push(fo);
  };
})();;
(function () {

  angular.module("hpe.elements.facets").directive("facetDynamic", facetDynamic);

  facetDynamic.$inject = ["$controller", "previewPaneProvider"];

  function facetDynamic($controller, previewPaneProvider) {
    return {
      restrict: "E",
      require: ['^facetContainer'],
      templateUrl: "facets/facetDynamic/template/facetDynamic.html",
      transclude: true,
      replace: true,
      controller: "FacetDynamicCtrl as fac",
      scope: {
        name: "=",
        facetOptions: "=",
        displayConfiguration: "=?",
        placeholder: "=",
        updateCallback: "=?",
        maxLength: "=",
        maxLines: "=?",
        disableReturn: "=?"
      },
      link: function (scope, element, attrs, controllers) {
        scope.title = '' + scope.name;
        var textareaEl = "";
        scope.regex = "'.*(\\\\([0-9]*\\\\))'";
        scope.fontClass = "'count-font-light'";
        scope.fac.foConstructor = {
          '$controller': $controller,
          'previewPaneProvider': previewPaneProvider,
          'facetContainer': controllers[0]
        };

        //Add the facet to the container
        controllers[0].register(scope.fac);

        // Watching when the textarea is included in the page.
        scope.$watch("element.children().length", function () {
          textareaEl = element.find('textarea');
          if (textareaEl.length !== 0) {

            if (scope.maxLength !== undefined) {
              textareaEl[0].setAttribute('maxlength', scope.maxLength);
            }

          }
        });

        //Adding watch to capture dynamic facet option changes and when no facets are loaded- it checks for undefined nv
        scope.$watch("facetOptions.options", function (nv, ov) {
          if (nv !== ov) {
            // if nv is not defined, then assigning the options to an empty array.
            if (typeof nv === "undefined") {
              nv = [];
            }
            
            scope.fac.updateFacetOptions(nv);
          }
        });

        // Removing events when scope is destroyed.
        scope.$on("$destroy", function () {
          textareaEl.off('input');
        });

      }
    };
  }
})();;
(function () {

  angular.module("hpe.elements.facets").filter("facetDynamicSelectedFilter",
    function () {
      return function (options, selectedList) {
        var filteredList = [];
        options.forEach(function (elem) {
          var selected = selectedList.some(function (sel) {
            return elem.name.toLowerCase() === sel.option.name.toLowerCase();
          });
          if (!selected) {
            filteredList.push(elem);
          }
        });
        return filteredList;
      };
    });
})();;
(function() {

  angular.module("hpe.elements.facets").filter("facetDynamicVisibleFilter", facetDynamicVisibleFilter);

  function facetDynamicVisibleFilter() {
    return function(options, visibleList) {

      var excludeVisible = options.filter(function(item) {
        for (var i = 0; i < visibleList.length; i++) {
          if (visibleList[i].name === item.name) return false;
        }
        return true;
      });

      return excludeVisible;
    };
  }

})();
;
(function() {

  angular.module("hpe.elements.facets").directive("dynamicFacetOption", dynamicFacetOption);
  dynamicFacetOption.$inject = ["$rootScope", "safeTimeout"];

  function dynamicFacetOption($rootScope, safeTimeout) {
    return {
      restrict: "E",
      require: ["^facetDynamic", "^^facetContainer"],
      controller: "FacetOptionCtrl as fo",
      templateUrl: "facets/facetOption/template/facetOption.html",
      transclude: true,
      replace: true,
      scope: {
        name: "=",
        count: "=?",
        select: "&",
        deselect: "&",
        disabled: "=?",
        selectedAriaLabel: "@",
        showZero: '=?'
      },
      link: function(scope, element, attrs, controllers) {
        scope.fo.facetContainer = controllers[1];
        scope.fo.facet = controllers[0];

        //Add the option to the facet
        scope.fo.facet.register(scope.fo);

        //Add the facet to the container
        scope.fo.facetContainer.register(scope.fo.facet);

        var safeTimeoutInstance = safeTimeout.create(scope);

        scope.$watch("count", function(ov, nv) {
          if ((ov !== nv && nv === 0) || (ov !== nv && ov === 0)) {
            //re-initialise custom scrollbar on facets
            safeTimeoutInstance.timeout(function() {
              $rootScope.$broadcast("reinit-pane", scope.fo.facet.name);
            }, 100);
          }

        });
        scope.checked = false;
        scope.$on("destroy", function() {
          scope.fo.deselect();
        });
      }
    };
  }
})();
;
(function() {

  angular.module('hpe.elements.facets').controller("FacetOptionCtrl", FacetOptionCtrl);
  FacetOptionCtrl.$inject = ["$scope", "previewPaneProvider", "$animate"];

  function FacetOptionCtrl($scope, previewPaneProvider, $animate) {
    var vm = this;
    vm.option = $scope;
    vm.name = $scope.name;
    vm.selectCallback = $scope.select;
    vm.deselectCallback = $scope.deselect;
    vm.option.previewProvider = previewPaneProvider;
    vm.$animate = $animate;
  }

  FacetOptionCtrl.prototype.toggle = function() {
    var vm = this;

    //disable animations
    this.$animate.enabled(false);

    if (this.option.checked) {
      this.deselect();
    } else {
      this.select();
    }

    //once finished drawing - enable animations
    setTimeout(function() {
      vm.$animate.enabled(true);
    });
  };

  FacetOptionCtrl.prototype.deselect = function() {
    //if item is disabled do nothing on deselect
    if(this.option.disabled) return;

    this.facetContainer.removeSelected(this);
    this.option.checked = false;
    //If there is a preview pane, then show initial message.
    this.option.previewProvider.preview.previewFile = "";
    // deselect call back is invoked when user wants, else user will handle this.
    if(!this.facetContainer.isClearAllFn) {
        this.deselectCallback();
    }
  };

  FacetOptionCtrl.prototype.select = function() {
    //if item is disabled do nothing on select
    if(this.option.disabled) return;

    this.facetContainer.addSelected(this);
    this.option.checked = true;
    //If there is a preview pane, then show initial message.
    this.option.previewProvider.preview.previewFile = "";
    this.selectCallback();
  };
})();
;
(function() {

  angular.module("hpe.elements.facets").directive("facetOption", facetOption);
  facetOption.$inject = ["$rootScope", "$timeout"];

  function facetOption($rootScope, $timeout) {
    return {
      restrict: "E",
      require: ["^facet", "^^facetContainer"],
      controller: "FacetOptionCtrl as fo",
      templateUrl: "facets/facetOption/template/facetOption.html",
      transclude: true,
      replace: true,
      scope: {
        name: "=",
        count: "=?",
        select: "&",
        disabled: "=?",
        deselect: "&",
        selectedAriaLabel: "@",
        showZero: '=?'
      },
      link: function(scope, element, attrs, controllers) {
        scope.fo.facetContainer = controllers[1];
        scope.fo.facet = controllers[0];

        //Add the option to the facet
        scope.fo.facet.register(scope.fo);

        //Add the facet to the container
        scope.fo.facetContainer.register(scope.fo.facet);

        //Update the scroll panel
        scope.fo.facet.reinitialize();

        scope.$watch("count", function(ov, nv) {
          if ((ov !== nv && nv === 0) || (ov !== nv && ov === 0)) {
            //re-initialise custom scrollbar on facets
            $timeout(function() {
              $rootScope.$broadcast("reinit-pane", scope.fo.facet.name);
            }, 100);
          }

        });
        scope.checked = false;
        scope.$on("destroy", function() {
          scope.fo.deselect();
        });
      }
    };
  }
})();
;
(function () {
  angular.module("hpe.elements.filters", []);
})();;
(function () {

  angular.module("hpe.elements.filters").directive("filter", filter);

  function filter() {
    return {
      restrict: "E",
      require: "^filterContainer",
      controller: "FilterCtrl as fc",
      templateUrl: function (tElem, tAttrs) {
        if (tAttrs.filterOptions) {
          return "filters/filter/template/filterOptions.html";
        }
        return "filters/filter/template/filter.html";
      },
      scope: {
        name: "=",
        dynamicOptions: "=?filterOptions",
        displayConfiguration: "=?",
        updateCallback: "=?"
      },
      transclude: true,
      replace: true,
      link: function (scope, element, attr, controller) {
        scope.fc.filterContainer = controller;
        scope.fc.filterContainer.addFilters(scope.fc);

        //To remove search string from dynamic filters
        if (element.hasClass('dynamic-filter-toggle')) {
          element.on('click', function () {
            if (!element.hasClass('open')) {
              element.find('ul li.input-container > input')[0].value = "";
            }
          });
        }


      }
    };
  }
})();;
(function () {

  angular.module('hpe.elements.filters').controller("FilterCtrl", ["$scope", "$timeout", FilterCtrl]);

  function FilterCtrl($scope, $timeout) {
    var vm = this;

    vm.$timeout = $timeout;
    vm.filteroption = $scope;
    vm.default = $scope.name;
    vm.filteroptions = $scope.filteroptions = [];
    vm.previousFilter = null;
    vm.updateCallback = $scope.updateCallback || null;


    //Long List properties
    if ($scope.dynamicOptions && $scope.displayConfiguration) {
      //whether to render a dropdown (true) or individual items (false)
      $scope.showListControl = ($scope.displayConfiguration.maxIndividualItems) ? $scope.displayConfiguration.maxIndividualItems <= $scope.dynamicOptions.options.length : true;

      //how many characters the user should input before a dropdown typeahead is presented
      $scope.minCharsForTypeAhead = ($scope.displayConfiguration.minCharacters) || 3;

      //how many items to display in the dropdown at most
      $scope.maxDisplayableItems = ($scope.displayConfiguration.maxDisplayableItems) || $scope.dynamicOptions.options.length;

      $scope.dynamicSelected = null;
      $scope.dynamicTypeaheadSelected = {
        text: ""
      };
      $scope.type = $scope.name.replace(/\w+/g,
        function (w) {
          return w[0].toUpperCase() + w.slice(1).toLowerCase();
        });
    }

    vm.setTitle = function (title, defaultval) {
      var filterAlreadySelected = null;

      vm.filteroption.name = title;

      vm.filteroption.class = defaultval ? '' : 'filter-selected';

      if (vm.previousFilter === vm) {
        if (defaultval) {
          filterAlreadySelected = true;
          vm.previousFilter = null;
        }
      } else {
        if (!defaultval) {
          filterAlreadySelected = false;
          vm.previousFilter = vm;
        }
      }


      vm.filterContainer.setClass(filterAlreadySelected);
    };

    vm.addFilterOptions = function (val) {
      vm.filteroptions.push(val);
    };

    vm.dynamicFilterSelected = function ($item) {
      vm.filteroption.dynamicSelected = $item;
      //click 
      vm.setTitle($item.name, $item.default);
      for (var i = 0; i < vm.filteroptions.length; i++) {
        vm.filteroptions[i].filterOption.selectedClass = false;
      }
      $item.select();
      vm.filterContainer.filterContainer.provider.preview.previewFile = "";

      vm.dismiss();
      vm.filteroption.dynamicTypeaheadSelected.text = null;

    };

    vm.clearDynamic = function () {
      if (vm.filteroption.dynamicSelected !== null && vm.filteroption.dynamicSelected !== undefined) {
        vm.filteroption.dynamicSelected = null;
        vm.filteroption.dynamicTypeaheadSelected.text = null;
      }
      vm.dismiss();
    };

    vm.dismiss = function () {
      $('.dynamic-filter-toggle').removeClass("open");
    };

    vm.dynamicTypeaheadOnChange = function () {

      if (vm.updateCallback) {
        vm.filteroption.dynamicOptions.options = vm.updateCallback(vm.filteroption.dynamicTypeaheadSelected.text, vm.filteroption.dynamicOptions.options);
      }
    };
  }

})();;
(function () {

  angular.module('hpe.elements.filters').controller("FilterContainerCtrl", FilterContainerCtrl);

  FilterContainerCtrl.$inject = ["$scope", "previewPaneProvider"];

  function FilterContainerCtrl($scope, previewPaneProvider) {
    var vm = this;
    vm.filteroptions = $scope.filteroptions = [];
    vm.filters = $scope.filters = [];
    vm.clearTitle = $scope.clearTitle;
    vm.filterContainer = $scope;
    vm.clearedFilter = 0;
    vm.filterContainer.provider = previewPaneProvider;
  }

  FilterContainerCtrl.prototype.addFilterOptions = function (val) {
    this.filteroptions.push(val);
  };

  FilterContainerCtrl.prototype.addFilters = function (val) {
    this.filters.push(val);
  };

  FilterContainerCtrl.prototype.clearFilter = function () {

    for (var i = this.filteroptions.length - 1; i >= 0; i--) {
      this.filteroptions[i].select();
    }

    for (var idx = this.filters.length - 1; idx >= 0; idx--) {
      this.filters[idx].previousFilter = null;
      this.filters[idx].clearDynamic();
    }

    this.filterContainer.provider.preview.previewFile = "";
  };

  FilterContainerCtrl.prototype.setClass = function (filterAlreadySelected) {

    if (filterAlreadySelected !== null) {

      if (!filterAlreadySelected) {
        this.clearedFilter++;
      } else {
        this.clearedFilter--;
      }
    }

    this.filterContainer.containerClass = (this.clearedFilter > 0) ? 'clear-selected' : '';
  };

})();;
(function () {

  angular.module("hpe.elements.filters").directive("filterContainer", filterContainer);

  function filterContainer() {
    return {
      restrict: "E",
      templateUrl: "filters/filterContainer/template/filterContainer.html",
      controller: "FilterContainerCtrl as fil",
      transclude: true,
      replace: true,
      scope: {
        clearTooltip: "@"
      }
    };
  }
})();;
(function () {

  angular.module('hpe.elements.filters').controller("FilterOptionCtrl", FilterOptionCtrl);
  FilterOptionCtrl.$inject = ["$scope", "previewPaneProvider"];

  function FilterOptionCtrl($scope, previewPaneProvider) {
    var vm = this;
    vm.selectCallback = $scope.select;
    vm.name = $scope.name;
    vm.default = $scope.default;
    vm.filterOption = $scope;
    
    if (vm.default) {
      vm.filterOption.selectedClass = true;
    }
    vm.filterOption.provider = previewPaneProvider;
  }

  FilterOptionCtrl.prototype.select = function () {
    this.filter.setTitle(this.name, this.default);

    for (var i = this.filter.filteroptions.length - 1; i >= 0; i--) {
      this.filter.filteroptions[i].deselect();
    }

    this.filterOption.selectedClass = true;
    this.selectCallback();
    this.filterOption.provider.preview.previewFile = "";
  };

  FilterOptionCtrl.prototype.deselect = function () {
    this.filterOption.selectedClass = false;
  };
})();;
(function () {
  
  angular.module("hpe.elements.filters").directive("filterOption", filterOption);

  function filterOption() {
    return {
      restrict: "E",
      require: ['^filter', '^^filterContainer'],
      templateUrl: "filters/filterOption/template/filterOption.html",
      controller: "FilterOptionCtrl as foc",
      transclude: true,
      replace: true,
      scope: {
        name: "=",
        select: "&",
        default: "="
      },
      link: function (scope, element, attrs, controllers) {
        scope.foc.filter = controllers[0];
        scope.foc.filterContainer = controllers[1];
        scope.foc.filter.addFilterOptions(scope.foc);
        if (scope.default) {
          scope.foc.filterContainer.addFilterOptions(scope.foc);
        }
      }
    };
  }
})();;
(function() {
	angular.module('hpe.elements.flippableCard', []);
})();;
(function () {

    angular.module('hpe.elements.flippableCard').directive('cardBack', cardBack);

    function cardBack() {
        return {
            restrict: 'E',
            transclude: true,
            replace: true,
            template: '<div class="back" ng-transclude></div>'
        };
    }
})();;
(function () {

    angular.module('hpe.elements.flippableCard').directive('cardFront', cardFront);

    function cardFront() {
        return {
            restrict: 'E',
            transclude: true,
            replace: true,
            template: '<div class="front" ng-transclude></div>'
        };
    }
})();;
(function () {

    angular.module("hpe.elements.flippableCard").directive("flippableCard", flippableCard);

    function flippableCard() {
        return {
            restrict: 'E',
            scope: {
                flipStyle: '@',
                flipOn: '@',
                cardWidth: '@',
                cardHeight: '@'
            },
            transclude: true,
            template: '<div class="flip-container">' +
                '<div class="flipper" ng-transclude>' +
                '</div>' +
                '</div>',
            link: function (scope, element) {
                // if flip style set to vertical, then add vertical class
                if (scope.flipStyle === 'vertical') {
                    element.find('.flip-container').addClass('vertical');
                }

                // set the width and height if specified by the user
                if (scope.cardWidth) {
                    element.find('.flip-container').css('width', scope.cardWidth);
                    element.find('.front').css('width', scope.cardWidth);
                    element.find('.back').css('width', scope.cardWidth);
                }
                if (scope.cardHeight) {
                    element.find('.flip-container').css('height', scope.cardHeight);
                    element.find('.front').css('height', scope.cardHeight);
                    element.find('.back').css('height', scope.cardHeight);

                    if (scope.flipStyle === 'vertical') {
                        element.find('.flipper').css('transform-origin', '100% ' + scope.cardHeight / 2 + 'px');
                    }
                }


                var flipOnItemClick = element.find('[flip-on-click]');
                var flipper = element.find('.flipper');

                // flip the item based on the appropriate event specified 
                if (scope.flipOn === "click") {
                    if (flipOnItemClick.length > 0)
                        flipOnItemClick.on("click", flipCard);
                    else
                        element.on("click", flipCard);
                } else {
                    element.hover(flipCard, unflipCard);
                }


                // does the actual flipping
                function flipCard() {
                    if (!flipper.hasClass('flip-card')) {
                        // if flipOn is by hover, the add the hover-flipper class for animation delay
                        if (scope.flipOn !== "click")
                            flipper.addClass('hover-flipper');

                        flipper.addClass('flip-card');
                    } else {
                        flipper.removeClass('hover-flipper');
                        flipper.removeClass('flip-card');
                    }
                }

                function unflipCard() {
                    flipper.removeClass('hover-flipper');
                    flipper.removeClass('flip-card');
                }
            }

        };
    }
})();;
(function () {

  angular.module("hpe.elements.floatLabel", []).directive("floatLabel", floatLabel);

  function floatLabel() {
    return {
      restrict: "C",
      link: function (scope, element) {
        var childInput = element.children(":input");

        childInput.attr('data-value', childInput.val()).on('keyup', function () {
          childInput.attr('data-value', childInput.val());
        });

      }
    };
  }
})();;
(function () {
  angular.module("hpe.elements.floatingActionButton", []);
})();;
(function () {

  angular.module('hpe.elements.floatingActionButton').controller("FloatingActionButton", FloatingActionButton);
  
  FloatingActionButton.$inject = ["$scope"];

  function FloatingActionButton() {
    var vm = this;

    vm.onSelect = function (select) {
      select();
    };
  }
})();;
(function () {

  angular.module('hpe.elements.floatingActionButton').directive('floatingActionButton', floatingActionButton);

  function floatingActionButton() {
    return {
      restrict: 'E',
      templateUrl: "floatingActionButton/template/floatingActionButton.html",
      controller: 'FloatingActionButton as fab',
      replace: true,
      scope: {
        items: "=",
        direction: "=",
        primary: "="
      },
      link: {
        post: function postLink(scope) {
          if (!scope.direction) {
            scope.direction = "bottom";
          }

          scope.focus = false;
          if (scope.direction === "top") {
            scope.className = "child-btn-set-top-visible";
            scope.parentClass = ".child-btn-set-top.top";
          } else if (scope.direction === "bottom") {
            scope.className = "child-btn-set-visible";
            scope.parentClass = ".child-btn-set.bottom";
          } else if (scope.direction === "left") {
            scope.className = "child-btn-set-visible-horizontal";
            scope.parentClass = ".child-btn-set-horizontal.left";
          } else {
            scope.className = "child-btn-set-visible-horizontal";
            scope.parentClass = ".child-btn-set-horizontal.right";
          }

          scope.expand = function (e) {
            scope.parent = angular.element(e.currentTarget.parentNode);
            scope.parent.addClass('floating-expand');
            var el = ".floating-expand " + scope.parentClass;
            angular.element(el).addClass(scope.className);
          };

          scope.collapse = function () {
            var el = ".floating-expand " + scope.parentClass;
            angular.element(el).removeClass(scope.className);
            if (scope.parent) scope.parent.removeClass('floating-expand');
          };

          scope.selectedCollapse = function (event) {
            scope.fab.onSelect(event);
            var el = ".floating-expand " + scope.parentClass;
            angular.element(el).removeClass(scope.className);
            scope.parent.removeClass('floating-expand');
          };
        }
      }
    };
  }
})();;
(function () {

  angular.module("hpe.elements.focusOnShow", []).directive("focusOnShow", focusOnShow);
  focusOnShow.$inject = ["$timeout"];

  function focusOnShow($timeout) {
    return {
      restrict: "A",
      link: function (scope, element, attrs) {

        if (attrs.ngShow) {
          scope.$watch(attrs.ngShow, function (nV) {
            if (nV) {
              $timeout(function () {
                element.focus();
              });
            }
          });
        } else if (attrs.ngHide) {
          scope.$watch(attrs.ngHide, function (nV) {
            if (!nV) {
              $timeout(function () {
                element.focus();
              });
            }
          });
        }
      }
    };
  }
})();;
(function () {
    
    angular.module("hpe.elements.forceFocus", []).directive("forceFocus", forceFocus);
    forceFocus.$inject = ["$timeout"];

    function forceFocus($timeout) {
        return {
            restrict: "A",
            link: function (scope, element, attrs) {
                var timeout = attrs.timeout ? parseInt(attrs.timeout, 10) : 200;

                var preventFocus = scope.$eval(attrs.preventFocus);
                var isChosen = scope.$eval(attrs.chosen);

                if (!preventFocus) {
                    $timeout(function () {
                        if (isChosen) {
                            element.trigger("chosen:activate");
                        } else {
                            element.focus();
                        }
                    }, timeout);
                }
            }
        };
    }
})();;
/* Code added for demo : Should be re-written in jquery for use. */
(function () {

  angular.module('hpe.elements.groupedPrevious', []).directive('groupedPrevious', groupedPrevious);

  function groupedPrevious() {
    return {
      restrict: 'A',
      link: function (scope, element) {
        scope.group = element[0].parentNode;
        var btnNav = scope.group.querySelectorAll('.btn-nav');
        element.on('click', function () {
          scope.curr.classList.remove('active');
          if (scope.index <= 0) {
            scope.index = scope.count - 1;
            scope.curr = btnNav.item(scope.index);
          } else {
            scope.index--;
            scope.curr = btnNav.item(scope.index);
          }
          scope.curr.classList.add('active');
        });
      }
    };
  }
})();


(function () {

  angular.module('hpe.elements.groupedNext', []).directive('groupedNext', groupedNext);

  function groupedNext() {
    return {
      restrict: 'A',
      link: function (scope, element) {
        scope.group = element[0].parentNode;
        var btnNav = scope.group.querySelectorAll('.btn-nav');
        element.on('click', function () {
          scope.curr.classList.remove('active');
          if (scope.index >= scope.count - 1) {
            scope.index = 0;
            scope.curr = btnNav.item(0);
          } else {
            scope.index++;
            scope.curr = btnNav.item(scope.index);
          }
          scope.curr.classList.add('active');
        });
      }
    };
  }
})();

(function () {

  angular.module('hpe.elements.groupedClear', []).directive('groupedClear', groupedClear);

  function groupedClear() {
    return {
      restrict: 'A',
      link: function (scope, element) {
        //only do this once
        if (!scope.curr) {
          scope.group = element[0].parentNode;
          var btnNav = scope.group.querySelectorAll('.btn-nav');
          scope.count = btnNav.length;
          for (var i = 0; i < btnNav.length; i++) {
            if (btnNav.item(i).classList.contains('active')) {
              scope.curr = btnNav.item(i);
              scope.index = i;
            }
          }
          //if no active class was set the first button should be active
          if (!scope.curr) {
            scope.curr = btnNav.item(0);
            scope.curr.classList.add('active');
            scope.index = 0;
          }
        }
        element.on('click', function () {
          scope.curr.classList.remove('active');
          scope.curr = element;
          scope.index = scope.curr.index() - 1;
          scope.curr = scope.curr[0];
          scope.curr.classList.add('active');
        });
      }
    };
  }
})();

(function () {

  angular.module('hpe.elements.groupedSelected', []).directive('groupedSelected', groupedSelected);

  function groupedSelected() {
    return {
      restrict: 'A',
      link: function (scope, element) {
        element.on('click', function () {
          angular.element('.btn-align').removeClass('active');
          element.addClass('active');
        });
      }
    };
  }
})();

/* Code added for demo : Should be re-written in jquery for use. */;
//this file has _module name so that it is picked up first by grunt-concat,
//any further module declarations should be added here.

(function () {
  angular.module("hpe.elements.helpCenter", ["hpe.elements.templates"]);
})();;
(function () {

  angular.module("hpe.elements.helpCenter").directive("helpCenterItem", helpCenterItem);

  helpCenterItem.$inject = ['$rootScope'];

  function helpCenterItem($rootScope) {
    return {
      restrict: "A",
      scope: {
        helpCenterTitle: '@',
        helpCenterUrl: '@'
      },
      link: function (scope) {

        scope.$watch('helpCenterTitle', function (nv, ov) {
          if (nv !== ov) {
            $rootScope.$broadcast('Help-Center-Update');
          }
        });

        scope.$watch('helpCenterUrl', function (nv, ov) {
          if (nv !== ov) {
            $rootScope.$broadcast('Help-Center-Update');
          }
        });
      }
    };
  }
})();;
(function () {

    angular.module("hpe.elements.helpCenter").directive("helpCenterMenu", helpCenterMenu);
    helpCenterMenu.$inject = ["$timeout", "$rootScope"];

    function helpCenterMenu($timeout, $rootScope) {
        return {
            restrict: "E",
            scope: {
                url: "@",
                helpText: "@",
                icon: "@",
                target: "@?"
            },
            templateUrl: "helpCenter/template/helpCenterMenu.html",
            replace: "true",
            link: function (scope) {
                if (!scope.target) scope.target = '_self';
                scope.iconBase = scope.icon && scope.icon.indexOf('hp-') === -1 ? 'hpe-icon' : 'hp-icon';

                //populate the health center once binding intially evaluated
                $timeout(updateList);

                //if any of the items url/text changes we need to update the list
                $rootScope.$on('Help-Center-Update', updateList);

                function updateList() {
                    var items = angular.element("[help-center-item]");

                    scope.menuItems = [];

                    for (var i = 0; i < items.length; i++) {
                        var options = {
                            title: angular.element(items[i]).attr('help-center-title'),
                            url: angular.element(items[i]).attr('help-center-url')
                        };
                        scope.menuItems.push(options);
                    }

                    scope.menuItems.sort(function (prev, next) {
                        if (prev.title > next.title) {
                            return 1;
                        }
                        if (prev.title < next.title) {
                            return -1;
                        } else {
                            return 0;
                        }
                    });
                }
            }
        };
    }
})();;
(function () {
  angular.module("hpe.elements.hotkey", []);
})();
;
(function () {

  angular.module('hpe.elements.hotkey').directive('elementsHotkey', elementsHotkey);

  elementsHotkey.$inject = ["hotkeyService", "$document"];

  function elementsHotkey(hotkeyService, $document) {
    return {
      restrict: 'A',
      link: elementsHotkey
    };

    function elementsHotkey(scope, element, attrs) {
      var keyCode = getKeyCode(attrs);
      var callback = getCallback(scope, attrs);

      checkHotkeyHint(scope, element, attrs);

      var focusGroup = element.find("[elements-hotkey-item]");

      //unshift adds to the start of an array
      //Invoking the method via voodoo because jquery-style nodelists don't follow the Array prototype but are array-like
      Array.prototype.unshift.call(focusGroup, element[0]);

      setTabIndices(focusGroup);

      var index = 0;
      var alsoFocusCallback = function () {
        //Loop the index back to the start if necessary
        if (index > focusGroup.length - 1) {
          index = 0;
        }

        //Focus the next item in the list
        if (focusGroup[index]) {
          focusGroup[index].focus();
        }
        //Perform the supplied logic
        //Invoke with the current element
        callback(angular.element(focusGroup[index]));

        index++;
      };

      hotkeyService.bindKey(keyCode, alsoFocusCallback, element, $document);
    }

    function checkHotkeyHint(scope, element, attrs) {
      if (angular.isDefined(attrs.elementsHotkeyHint)) {
        hotkeyService.createHotkeyHint(element, attrs.elementsHotkey);
      }
    }

    function setTabIndices(elements) {
      //Force this element to be tabbable
      for (var i in elements) {
        if (!elements.eq(i).attr("tabindex")) {
          elements.eq(i).attr("tabindex", "0");
        }
      }
    }

    function getKeyCode(attrs) {
      if (!attrs.elementsHotkey || typeof attrs.elementsHotkey !== "string") {
        console.error("Please refer to the Elements documentation for how to set a hotkey");
        return 0;
      }
      var keyCode = hotkeyService.getCharCode(attrs.elementsHotkey);
      if (!keyCode) {
        console.error("Could not parse keycode for" + attrs.elementsHotkey);
        return 0;
      }
      return keyCode;
    }

    function getCallback(scope, attrs) {
      var callback;
      if (attrs.elementsHotkeyAction) {
        callback = scope.$eval(attrs.elementsHotkeyAction);
      }
      return angular.isFunction(callback) ? callback : angular.noop;
    }

  }
})();;
(function () {
  angular.module('hpe.elements.hoverActions', []);
})();;
(function () {

  angular.module('hpe.elements.hoverActions').directive('hoverAction', hoverAction);

  function hoverAction() {
    return {
      restrict: 'E',
      replace: true,
      templateUrl: 'hoverActions/templates/hoverAction.html',
      scope: {
        icon: "@",
        name: "@",
        click: "&"
      },
      require: '^hoverActions',
      link: function (scope, element, attrs, hoverActionCtrl) {

        /*
          Properties
        */
        var container = element.parent();

        /*
          Bind to events
        */
        element.focus(onFocus);
        element.blur(onBlur);
        element.keydown(onKeyDown);
        element.click(onClick);

        /*
          Event handlers
        */

        function onClick(evt) {
          //evaluate the function
          scope.click();

          //no longer force focus
          container.removeClass('action-hovered');

          evt.stopPropagation();
          evt.preventDefault();

        }

        function onFocus() {
          container.addClass('action-hovered');
        }

        function onBlur() {
          container.removeClass('action-hovered');
        }

        function onKeyDown(evt) {
          //if left arrow key is pressed
          if (evt.keyCode === 37) {
            //try and select the previous action if there is one
            var previousBtn = element.prev('.hover-action').focus();

            //if there are no more previous elements, highlight the hover element again
            if (previousBtn.length === 0) {
              hoverActionCtrl.hoverElement.focus();
              container.removeClass('action-hovered');
            }

            evt.stopPropagation();
            evt.preventDefault();

          }

          //if right arrow key is pressed
          if (evt.keyCode === 39) {
            //try and select the next action if there is one
            element.next('.hover-action').focus();
            evt.stopPropagation();
            evt.preventDefault();

          }

          //if return key was pressed
          if (evt.keyCode === 13) {
            //evaluate the function - unlike click retain focus
            scope.click();

            evt.stopPropagation();
            evt.preventDefault();
          }
        }
      }
    };
  }
})();;
(function () {

  /*
    The purpose of this controller is to ensure that a hover-action elements is only
    used within a hover-actions container. It is also used to store the hover element
    to avoid any unnecessary DOM traversal
  */

  angular.module('hpe.elements.hoverActions').controller('HoverActionsCtrl', HoverActionsCtrl);

  function HoverActionsCtrl() {
    var vm = this;

    vm.hoverElement = null;
  }
})();;
(function () {

    angular.module('hpe.elements.hoverActions').directive('hoverActions', hoverActions);

    hoverActions.$inject = ['safeTimeout'];

    function hoverActions(safeTimeout) {
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            template: '<div class="hover-actions" ng-transclude></div>',
            controller: 'HoverActionsCtrl as hac',
            link: function (scope, element, attrs) {

                var hoverActions = null;

                //create safeTimeout instance
                var safeTimeoutInstance = safeTimeout.create(scope);

                //await for transclusion to finish then process element
                safeTimeoutInstance.timeout(getHoverElement);

                /*
                  Initialisation
                */
                function getHoverElement() {

                    //find the element that will trigger the hover effect
                    var hoverElement;

                    if (attrs.hoverElement === null) hoverElement = element.parent();
                    else hoverElement = element.parents(attrs.hoverElement);

                    //ensure a hover element was specified
                    if (hoverElement.length === 0) hoverElement = element.parent();

                    // if we have one it should be the first item in the list
                    scope.hac.hoverElement = hoverElement.first();

                    //ensure it is hoverable
                    if (!scope.hac.hoverElement.attr('tabindex')) scope.hac.hoverElement.attr('tabindex', 0);

                    //get hover actions
                    hoverActions = scope.hac.hoverElement.find('.hover-action');

                    //apply listeners to the parent element
                    applyListeners();
                }

                /*
                  Bind to events
                */
                function applyListeners() {
                    scope.hac.hoverElement.mouseover(onHover);
                    scope.hac.hoverElement.mouseleave(onLeave);
                    scope.hac.hoverElement.focus(onFocus);
                    scope.hac.hoverElement.blur(onBlur);
                    scope.hac.hoverElement.keydown(onKeyDown);
                }

                /*
                  Event handlers
                */
                function onFocus() {
                    element.addClass('focused');
                }

                function onBlur() {
                    element.removeClass('focused');
                }

                function onHover() {
                    element.addClass('hovered');
                }

                function onLeave() {
                    element.removeClass('hovered');
                }

                function onKeyDown(evt) {
                    //if there right arrow key is pressed then focus the first action
                    if (evt.keyCode === 39) hoverActions.first().focus();
                }
            }
        };
    }
})();;
(function () {

  angular.module('hpe.elements.icheck', []).directive("icheck", icheck);

  function icheck() {
    return {
      scope: {
        model: "=ngModel",
        disable: "=ngDisable",
        ngValue: '=ngValue',
        value: '=value',
        indeterminate: '=?indeterminateValue',
        simplified: '='
      },
      require: "ngModel",
      restrict: "A",
      link: function ($scope, element, $attrs, ngModel) {
        var value = $scope.value || $scope.ngValue;
        var indeterminate = $scope.indeterminate;
        var checkboxStyle = 'icheckbox-hp';

        if ($scope.simplified === true)
          checkboxStyle = 'icheckbox-hp-simplified';

        //have to check if indeterminate was actually set as the indeterminate value may be undefined on purpose
        var indeterminateSet = $attrs.hasOwnProperty("indeterminateValue");

        var $element = $(element);
        $scope.$watch("model", function (newValue) {
          if ($element.attr('type') === 'radio') {
            $element.iCheck(newValue === value ? 'check' : 'uncheck');

          } else if (indeterminateSet && indeterminate === newValue) {
            $element.iCheck("indeterminate");
            return;
          }
          $element.iCheck('update');

        });
        $scope.$watch("disable", function (newValue) {
          $element.iCheck(newValue ? 'disable' : 'enable');
        });

        return $element.iCheck({
          checkboxClass: checkboxStyle,
          radioClass: 'iradio-hp',
          aria: 'true'
        }).on('ifChanged', function (event) {
          //if this has been triggered by a model change then ignore.
          if ($scope.$root.$$phase === "$digest") {
            return;
          }
          if ($element.attr('type') === 'checkbox') {
            $scope.$apply(function () {
              return ngModel.$setViewValue(event.target.checked);
            });
          }
          if ($element.attr('type') === 'radio') {
            return $scope.$apply(function () {
              return ngModel.$setViewValue(value);
            });
          }
        });
      }
    };
  }
})();;
(function () {
  angular.module("hpe.elements.index", []);
})();
;
(function() {

  angular.module('hpe.elements.index').directive('elementsIndex' , elementsIndex);

  function elementsIndex() {
    return{
      restrict:'A',
      link :elementsIndexLink
    };

    function elementsIndexLink(scope, element, attrs){
      //This value will come from an ng-repeat
      var index = scope.$index || 0;
      var indexOptions = {};

      //Evaluate configuration object and set defaults
      var elementsIndexValue = scope.$eval(attrs.elementsIndex || "") || {};
      indexOptions.skip = elementsIndexValue.skip || 0;
      indexOptions.offset = elementsIndexValue.offset || 0;
      indexOptions.base = elementsIndexValue.base || 0;

      //User wants to declare how many items to skip over but we want to calculate what the value of the next item after that should be
      //NB: when the value is 1 there is nothing to skip.
      indexOptions.skip++;

      //E.g. if a row has 5 hover actions, the rows should be numbered 0, 6, 12 etc.
      //so that the hover actions can have index 1,2,3,4,5
      //the offset value allows for a non-zero start
      var calculatedIndex = ( index * indexOptions.skip ) + indexOptions.offset;

      //If these properties are not set, then set them
      if (!angular.isDefined(attrs.index)){
        //This property is used internally for keyboard controls
        element.attr("index" , calculatedIndex);
      }
      if (!angular.isDefined(attrs.tabIndex)){
        //NB essentially this disables tabbing so that the internal keyboard controls can work
        element.attr("tabindex" , ( calculatedIndex === indexOptions.base)  ? "1" : "-1" );
      }

    }
  }
})();
;
(function() {
  angular.module('hpe.elements.infiniteScroll', []);
})();
;
(function () {

    angular.module('hpe.elements.infiniteScroll').directive('infiniteScroll', infiniteScroll);

    infiniteScroll.$inject = ['$parse', '$templateRequest', '$compile', '$timeout', 'safeTimeout', 'safeInterval'];

    function infiniteScroll($parse, $templateRequest, $compile, $timeout, safeTimeout, safeInterval) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {

                //initialise properties
                var currentPage = 0;
                var items = [];
                var itemTemplate = null;
                var lastPage = false;
                var loadingIndicator = null,
                    loadButton = null;
                var isLoading = false;
                var isInitialised = false;
                var safeIntervalInstance = safeInterval.create(scope);
                var body = angular.element('body');
                var win = angular.element(window);

                //get the evaluated attributes from the element - prevent isolating scope
                var pageSize = +$parse(attrs.pageSize)(scope);
                var pageFn = $parse(attrs.pageFn)(scope);
                var pagePosition = attrs.pagePosition ? +$parse(attrs.pagePosition)(scope) : 85;
                var containerId = attrs.containerId ? $parse(attrs.containerId)(scope) : null;
                var itemTemplateUrl = $parse(attrs.itemTemplate)(scope);
                var showLoading = attrs.showLoading ? $parse(attrs.showLoading)(scope) : true;
                var searchQuery = $parse(attrs.searchQuery)(scope);
                var scrollBarConfig = $parse(attrs.scrollConfig)(scope);

                //allow option to use window scroll rather than div
                var windowScroll = attrs.windowScroll ? $parse(attrs.windowScroll)(scope) : false;

                //load more button
                var defaultLoadButtonOptions = {
                    show: false,
                    text: 'Load More',
                    class: ''
                };

                var loadButtonOptions = defaultLoadButtonOptions;

                if (attrs.loadMoreButton) {
                    var value = $parse(attrs.loadMoreButton)(scope);
                    loadButtonOptions = angular.extend(defaultLoadButtonOptions, value);
                }

                //detect whether this is on a normal scrollbar or a jscrollpane
                var jScrollPane = attrs.scrollPane === '';

                //load the template
                var templateLoaded = $templateRequest(itemTemplateUrl);

                //wait for promise to be resolved (template has been loaded)
                templateLoaded.then(function (template) {
                    //store the item template
                    itemTemplate = template;

                    //load the first page
                    loadPage();
                });

                //perform search when search query changes
                scope.$watch(function () {
                    return $parse(attrs.searchQuery)(scope);
                }, function (nv, ov) {
                    if (nv !== ov) {
                        //store the new search query
                        searchQuery = nv;

                        //remove all previous list items
                        getContainer().empty();

                        //set the page back to zero
                        currentPage = 0;
                        isLoading = false;

                        //load the next page
                        loadPage();
                    }
                });

                //allow jScrollPane to initialise
                $timeout(bindToScroll);

                function showLoadingIndicator() {

                    //if option specified not to show indicator then stop here
                    if (!showLoading) return;

                    //if no loading indicator has been created then make one
                    if (!loadingIndicator) {
                        //create spinner container
                        loadingIndicator = document.createElement('div');
                        loadingIndicator.className = 'infinite-scroll-loading';

                        //create spinner
                        var spinner = document.createElement('div');
                        spinner.className = 'spinner spinner-accent spinner-bounce-middle';

                        var spinnerText = document.createElement('span');
                        spinnerText.className = 'spinner-text';
                        spinnerText.innerHTML = "Loading...";

                        //add spinner to container
                        loadingIndicator.appendChild(spinner);
                        loadingIndicator.appendChild(spinnerText);
                    }

                    //add loading indicator to bottom of container
                    getContainer().append(loadingIndicator);
                }

                function showLoadingButton() {
                    //if no button should be shown then stop here - or if we are on the last page then no more to load
                    if (!loadButtonOptions || !loadButtonOptions.show || lastPage) return;

                    //create element if one does not already exist
                    if (!loadButton) {
                        //create the element
                        loadButton = angular.element('<div class="infinite-scroll-load-button ' + loadButtonOptions.class + '"><p class="load-button-text">' + loadButtonOptions.text + '</p></div>');

                        //add click event - use angular as it is easier to unit test
                        loadButton.click(function () {
                            //remove the button from the dom
                            loadButton.remove();

                            //remove any references to load button
                            loadButton = null;

                            //load the next page
                            loadNextPage();

                            //scrol to bottom of the div
                            scrollToBottom();
                        });
                    }

                    //add button to container
                    getContainer().append(loadButton);
                }

                function hideLoadingIndicator() {
                    //remove loading indicator from the container
                    getContainer().find('.infinite-scroll-loading').remove();
                }

                function bindToScroll() {

                    //if we want to use a loading button instead we dont need to bind to scroll
                    if (loadButtonOptions && loadButtonOptions.show) return;

                    //if we are should use window scrolling
                    if (windowScroll === true) {

                        win.scroll(function () {
                            //dont do anything if we are loading
                            if (isLoading) return;

                            //calculate the percentage value from scrolled
                            var scrollPosition = win.scrollTop() + win.height();
                            var scrollHeight = body.innerHeight();
                            var scrolledPercentage = (scrollPosition / scrollHeight) * 100;

                            //we we are near the bottom of the list then begin loading the next page
                            if (scrolledPercentage > pagePosition) loadNextPage();
                        });

                    } else if (jScrollPane) {

                        element.on('jsp-scroll-y', function () {
                            //dont do anything if we are loading
                            if (isLoading) return;

                            //get the jscrollpane data
                            var scrolledPercentage = element.data('jsp').getPercentScrolledY() * 100;

                            //we we are near the bottom of the list then begin loading the next page
                            if (scrolledPercentage > pagePosition) loadNextPage();
                        });
                    } else {
                        element.scroll(function () {
                            //dont do anything if we are loading
                            if (isLoading) return;

                            //calculate the percentage value from scrolled
                            var scrollPosition = element.scrollTop() + element.innerHeight();
                            var scrollHeight = element.get(0).scrollHeight;
                            var scrolledPercentage = (scrollPosition / scrollHeight) * 100;

                            //we we are near the bottom of the list then begin loading the next page
                            if (scrolledPercentage > pagePosition) loadNextPage();

                        });
                    }

                    //ensure enough items are visible to show a scrollbar
                    ensureScrollable();
                }

                function loadNextPage() {
                    currentPage++;
                    loadPage();
                }

                function loadPage() {

                    //store loading state
                    isLoading = true;

                    //show loading indicator
                    showLoadingIndicator();

                    //call the specified paging function
                    var results = pageFn(currentPage, pageSize, searchQuery);

                    //if results is a promise wait until it is solved
                    if (results.then) {
                        results.then(
                            function (newItems) {
                                processItems(newItems);
                            },
                            function () {
                                //if request fails reset properties
                                isLoading = false;
                                hideLoadingIndicator();
                                lastPage = true;
                            });
                    } else
                        processItems(results);
                }

                function processItems(newItems) {
                    //hide loading indicator if there was one
                    hideLoadingIndicator();

                    //check if the number of items returned is less than expected - if so then it is the last page
                    if (!newItems || newItems.length < pageSize) lastPage = true;

                    //if the items was null or empty dont render new results
                    if (!newItems || newItems.length === 0) return;

                    //append the new items to the list
                    for (var i = 0; i < newItems.length; i++) items.push(newItems[i]);

                    //render the new items
                    renderItems(newItems);

                    // Mark that it's run at least once
                    isInitialised = true;
                }

                function renderItems(newItems) {

                    //get the container element
                    var container = getContainer();

                    for (var i = 0; i < newItems.length; i++) {
                        var item = newItems[i];

                        //create new scope with data as item data
                        var itemScope = scope.$new();
                        itemScope.data = item;

                        //compile and append item
                        var compiledItem = $compile(itemTemplate)(itemScope);
                        container.append(compiledItem);
                    }

                    //depending on when the rendering is occuring we likely need to manually start a digest
                    if (scope.$root.$$phase === null) scope.$digest();

                    // if the scroll is a jScrollPane, then timeout for longer than the autoReinitialiseDelay to ensure the paging isn't done twice
                    if (jScrollPane) {
                        var safeTimeoutInstance = safeTimeout.create(scope);

                        var delay = angular.isDefined(scrollBarConfig.autoReinitialiseDelay) ? scrollBarConfig.autoReinitialiseDelay + 10 : 1000;
                        safeTimeoutInstance.timeout(function () {
                            isLoading = false;
                        }, delay);
                    } else
                        isLoading = false;

                    //show load more button (if required)
                    showLoadingButton();
                }

                function getContainer() {

                    //if no container was specified then just return the element
                    if (containerId === null) return element;

                    return angular.element(element.find('[infinite-scroll-container="' + containerId + '"]').get(0));
                }

                function ensureScrollable() {

                    //if we are using a load more button this is also not required
                    if (loadButtonOptions && loadButtonOptions.show) return;

                    //we need to constantly check that a scrollbar is visible and if not then load more until there is
                    safeIntervalInstance.interval(function () {
                        //if we are currently loading then we should wait until we arent - if last page then no more to load
                        if (!isInitialised || isLoading || lastPage) return;

                        if (windowScroll) {
                            //if a window scrollbar is not visible then load the next page
                            if (body.height() <= win.height()) loadNextPage();
                        } else if (jScrollPane) {
                            var scrollbarVisible = element.data('jsp').getIsScrollableV();

                            //if a scrollbar is not visible then load the next page
                            if (!scrollbarVisible) loadNextPage();
                        } else {
                            //if a scrollbar is not visible then load the next page
                            if (element.get(0).clientHeight !== 0 && element.get(0).scrollHeight <= element.get(0).clientHeight) loadNextPage();
                        }
                    }, 100, 0, false);
                }

                function scrollToBottom() {
                    if (jScrollPane) element.data('jsp').scrollToPercentY(100, false);
                    else element.scrollTop(element[0].scrollHeight);
                }
            }
        };
    }
})();;
(function () {

    angular.module('hpe.elements.inputMask', []).directive("mask", mask);

    function mask() {
        return {
            restrict: 'A',
            scope: {
                mask: "=",
                maskType: "="
            },
            link: function (scope, elem) {
                if (scope.mask) {
                    if (scope.maskType) {
                        elem.inputmask(scope.maskType, scope.mask);
                    } else {
                        elem.inputmask(scope.mask);
                    }
                }
            }
        };
    }
})();;
(function () {
  angular.module("hpe.elements.keyboardNavigableTable", []);
})();;
(function () {

  angular.module("hpe.elements.keyboardNavigableTable").directive("keyboardNavigableTable", keyboardNavigableTable);
  keyboardNavigableTable.$inject = ["$document"];

  function keyboardNavigableTable($document) {
    var Keys = {
      'left': 37,
      'up': 38,
      'right': 39,
      'down': 40
    };
    return {
      restrict: "A",
      link: function (scope, elem) {
        // Table key handler
        elem.on("keydown.keyboardNavigableTable", "tr", function (e) {
          if ([Keys.left, Keys.up, Keys.right, Keys.down].indexOf(e.which) === -1) return;
          e.stopPropagation();
          e.preventDefault(); // Prevents arrow keys from scrolling the page
          var selection = getSelection();
          var newSelectedElement = selection.selected;
          switch (e.which) {
            case Keys.up:
              newSelectedElement = selection.parentRow.prev("tr");
              break;
            case Keys.down:
              newSelectedElement = selection.parentRow.next("tr");
              break;
            case Keys.left:
              if (selection.selected.is("a")) {
                newSelectedElement = selection.selected.prev("a");
              } else {
                newSelectedElement = selection.parentRow.find("a.list-hover-action").last();
              }
              break;
            case Keys.right:
              if (selection.selected.is("a")) {
                newSelectedElement = selection.selected.next("a");
              } else {
                newSelectedElement = selection.parentRow.find("a.list-hover-action").first();
              }
              break;
          }
          if (newSelectedElement.length === 0) {
            // If the next selection doesn't exist then keep focus on current element
            newSelectedElement = selection.selected;
          }
          newSelectedElement.focus();

          if (newSelectedElement.is("tr") && newSelectedElement !== selection.selected) {
            // Notify when selected row changes
            newSelectedElement.trigger({
              type: "receivedSelection.keyboardNavigableTable",
              shiftKey: e.shiftKey,
              ctrlKey: e.ctrlKey
            });
          }
        });

        // Table focus handler
        elem.on("focus", function () {
          // Focus the first row instead of the table, for visual feedback
          elem.find("tbody tr").first().focus();
        });

        // Table hover-action focus handlers
        elem.on("focus", "a.list-hover-action", function (e) {
          // Add focus styling to parent elements when hover action is focused
          angular.element(e.target).closest("tr").addClass("child-focus");
        });
        elem.on("blur", "a.list-hover-action", function (e) {
          angular.element(e.target).closest("tr").removeClass("child-focus");
        });

        // Function to return the focused element, and it's parent row.
        function getSelection() {
          var result = {
            selected: elem.find("tbody tr").first()
          };
          var selected = angular.element($document[0].activeElement);
          if (elem.has(selected)) {
            var parentRow = selected.closest("tr");
            result.selected = selected.is("a") ? selected : parentRow;
            result.parentRow = parentRow;
          }
          return result;
        }
      }
    };
  }
})();;
(function () {
  angular.module("hpe.elements.layoutSwitcher", []);
})();;
(function () {

    angular.module('hpe.elements.layoutSwitcher').controller('LayoutSwitcherContainerCtrl', LayoutSwitcherContainerCtrl);

    LayoutSwitcherContainerCtrl.$inject = ['$scope', '$element', '$attrs', '$parse', '$resize', '$timeout'];

    function LayoutSwitcherContainerCtrl($scope, $element, $attrs, $parse, $resize, $timeout) {
        var vm = this;

        vm.selectedLayout = $parse($attrs.selected)($scope);

        vm.activeLayout = null;
        vm.containerWidth = $element.get(0).offsetWidth;

        vm.layouts = [];

        vm.registerLayout = function (layout) {
            vm.layouts.push(layout);
        };

        vm.updateLayout = function () {

            // hide all layouts
            vm.resetLayoutVisibility();

            // find selected layout
            var selectedLayout = vm.findLayout(vm.selectedLayout);

            // determine if we should show the collapse layout
            if (selectedLayout.collapseLayout) {
                vm.activeLayout = vm.containerWidth <= selectedLayout.collapseSize ? selectedLayout.collapseLayout : vm.selectedLayout;
            } else {
                vm.activeLayout = vm.selectedLayout;
            }

            // find matching layout
            var activeLayout = vm.findLayout(vm.activeLayout);

            // make visible
            activeLayout.visible = true;

            if ($attrs.active) {

                $parse($attrs.active).assign($scope, vm.activeLayout);

                // we need to run a digest here if one is not already in progress 
                if (!$scope.$$phase) {
                    $scope.$digest();
                }
            }
        };

        vm.resetLayoutVisibility = function () {

            // set all layouts to hidden
            vm.layouts.forEach(function (layout) {
                layout.visible = false;
            });
        };

        vm.findLayout = function (layoutName) {

            var matches = vm.layouts.filter(function (layout) {
                return layout.layoutName === layoutName;
            });

            return matches[0];
        };

        vm.resizeHandler = function (element, width) {
            vm.containerWidth = width;

            vm.updateLayout();
        };

        // watch for any size changes
        $resize.bind($element.get(0), vm.resizeHandler);

        // update ui after initial digest
        $timeout(vm.updateLayout);

        // watch for any changes to the selectedLayout
        $scope.$watch(function () {
            return $parse($attrs.selected)($scope);
        }, function (newValue, oldValue) {
            if (newValue !== oldValue) {
                vm.selectedLayout = newValue;

                vm.updateLayout();
            }
        });
    }
})();;
(function () {

  angular.module("hpe.elements.layoutSwitcher").directive("layoutSwitcherContainer", layoutSwitcherContainer);

  function layoutSwitcherContainer() {
    return {
      restrict: "E",
      controller: 'LayoutSwitcherContainerCtrl as lsc'
    };
  }

})();;
(function () {

    angular.module('hpe.elements.layoutSwitcher').controller('LayoutSwitcherItemCtrl', LayoutSwitcherItemCtrl);

    LayoutSwitcherItemCtrl.$inject = ['$scope', '$attrs'];

    function LayoutSwitcherItemCtrl($scope, $attrs) {
        var vm = this;

        // store reference to parent controller
        vm.layoutSwitcher = $scope.$parent.lsc;

        // get values from attributes
        vm.layoutName = $attrs.name;
        vm.layoutUrl = $attrs.layout;
        vm.collapseLayout = $attrs.collapseLayout;
        vm.collapseSize = $attrs.collapseSize || 960;

        // store if this is the current visible view and if collapsed
        vm.visible = false;

        // register this layout in container
        vm.layoutSwitcher.registerLayout(vm);

    }
})();;
(function () {

  angular.module("hpe.elements.layoutSwitcher").directive("layoutSwitcherItem", layoutSwitcherItem);

  layoutSwitcherItem.$inject = ['$templateRequest', '$compile'];

  function layoutSwitcherItem($templateRequest, $compile) {
    return {
      restrict: "E",
      replace: false,
      transclude: true,
      require: '^layoutSwitcherContainer',
      controller: 'LayoutSwitcherItemCtrl as vm',
      template: '<div ng-style="{ \'display\': vm.visible ? \'block\' : \'none\' }"></div>',
      scope: true,
      link: function (scope, element, attrs, ctrl, transclude) {

        var layoutUrl = attrs.layout;
        var targetScope = scope.$parent;
        var container = element.children().first();

        // if a layout url was specified we need to load it
        if (layoutUrl !== undefined) {

          $templateRequest(layoutUrl).then(function (template) {
            container.append($compile(template)(targetScope));
          });

        } else {

          // otherwise just perform transclusion
          container.append(transclude(targetScope));
        }
      }
    };
  }
})();;
(function () {
  angular.module("hpe.elements.listHoverActions", ["hpe.elements.templates"]);
})();;
(function () {

  angular.module("hpe.elements.listHoverActions").controller("ListHoverActionCtrl", ListHoverActionCtrl);
  ListHoverActionCtrl.$inject = ["$scope"];

  function ListHoverActionCtrl($scope) {
    this.icon = $scope.icon;

    this.iconBase = this.icon && this.icon.indexOf('hp-') === -1 ? 'hpe-icon' : 'hp-icon';

    this.click = $scope.click;
  }

})();;
(function () {

  angular.module("hpe.elements.listHoverActions").directive("listHoverAction", listHoverAction);

  function listHoverAction() {
    return {
      restrict: "E",
      replace: true,
      templateUrl: "listHoverActions/listHoverAction/template/listHoverAction.html",
      controller: "ListHoverActionCtrl as lha",
      scope: {
        icon: "@",
        name: "@",
        click: "&"
      },
      link: function (scope, element) {
        element.tooltip({
          title: scope.name
        });

        // clean up after destroyed
        scope.$on('$destroy', function () {
          element.tooltip('destroy');
        });
      }
    };
  }
})();;
(function () {

  angular.module("hpe.elements.listHoverActions").directive("listHoverActions", listHoverActions);

  listHoverActions.$inject = ['$timeout'];

  function listHoverActions($timeout) {
    return {
      restrict: "E",
      replace: true,
      transclude: true,
      templateUrl: "listHoverActions/template/listHoverActions.html",
      link: function (scope, element) {

        // store references to elements
        var nativeElement = element.get(0);
        var parentRow = element.parents('tr').get(0);
        var listActions = nativeElement.getElementsByClassName('list-hover-action');

        // add class to parent row
        parentRow.classList.add('hover-actions');

        // after initial digest then add index to parent row
        $timeout(createIndex);

        // watch for changes to classes
        var observer = new MutationObserver(function (mutations) {

          var classMutations = mutations.filter(function (mutation) {
            return mutation.attributeName && mutation.attributeName === 'class';
          });

          if (classMutations.length > 0) {
            updateVisibility();
          }

        });

        var config = {
          attributes: true,
          subtree: true,
          characterData: true
        };

        observer.observe(nativeElement, config);

        function createIndex() {
          // if the parent row has index get it
          var rowIndex = parentRow.getAttribute('index') | 0;

          // iterate each list action and give it an index
          for (var idx = 0; idx < listActions.length; idx++) {

            // get current list action
            var listAction = listActions.item(idx);

            // give the element an index
            listAction.setAttribute('index', ++rowIndex);
          }
        }

        function updateVisibility() {

          if (hasFocus()) {
            // show the actions
            nativeElement.style.opacity = '1';

            // add class to row
            parentRow.classList.add('highlight');
          } else {
            // hide the actions
            nativeElement.style.opacity = '';

            // remove class from row
            parentRow.classList.remove('highlight');
          }

        }

        function hasFocus() {

          // iterate each list action to see if it has focus
          for (var idx = 0; idx < listActions.length; idx++) {

            // get current list action
            var listAction = listActions.item(idx);

            if (listAction.classList.contains('preview-pane-selected-item')) {
              return true;
            }

          }

          return false;
        }
      }
    };
  }
})();;
(function () {
  angular.module('hpe.elements.listItemFilter', []);
})();;
(function () {

    angular.module('hpe.elements.listItemFilter').directive('listItemFilter', listItemFilter);

    function listItemFilter() {
        return {
            restrict: 'A',
            scope: {
                filterText: '='
            },
            link: function (scope, element) {

                scope.$watch('filterText', function (nv, ov) {
                    if (nv !== ov) filter(nv);
                });

                var filter = function (filterText) {
                    // get a list of the latest children
                    var children = element.children();

                    // iterate through each child and filter based on key
                    children.each(function (idx, listItem) {
                        var li = angular.element(listItem);

                        var key = li.attr('key');

                        if (key && key.toLowerCase().indexOf(filterText.toLowerCase()) !== -1)
                            li.show();
                        else
                            li.hide();
                    });
                };
            }
        };
    }
})();;
(function() {
  angular.module('hpe.elements.marqueeWizard', []);
})();
;
(function () {
    
    angular.module('hpe.elements.marqueeWizard').directive('marqueeWizard', marqueeWizard);

    function marqueeWizard() {
        return {
            restrict: 'E',
            templateUrl: 'marqueeWizard/templates/marqueeWizard.html',
            replace: true,
            controller: 'MarqueeWizardCtrl',
            controllerAs: 'mc',
            scope: {
                wizardIcon: '=',
                wizardSteps: '=',
                buttonOptions: '=',
                onChanging: '=?',
                onFinished: '=?',
                onFinishing: '=?',
                onCanceled: '=?',
                isVisited: '=?',
                sideInfo: '=?'
            },
            link: function (scope, element) {

                //get button elements
                var previousBtn = element.find('.marquee-previous-btn');
                var nextBtn = element.find('.marquee-next-btn');
                var finishBtn = element.find('.marquee-finish-btn');

                //when buttonOptions changes then update tooltips accordingly
                scope.$watch('buttonOptions', function (nv, ov) {
                    if (angular.equals(nv, ov)) updateTooltips();
                }, true);

                //initially add the tooltips
                updateTooltips();

                function updateTooltips() {
                    //destory previous tooltips
                    previousBtn.tooltip('destroy');
                    nextBtn.tooltip('destroy');
                    finishBtn.tooltip('destroy');

                    //add new tootlips if required to previous btn
                    if (scope.buttonOptions.previousTooltip !== null) {
                        previousBtn.tooltip({
                            title: scope.buttonOptions.previousTooltip
                        });
                    }


                    //add new tootlips if required to next btn
                    if (scope.buttonOptions.nextTooltip !== null) {
                        nextBtn.tooltip({
                            title: scope.buttonOptions.nextTooltip
                        });
                    }


                    //add new tootlips if required to finish btn
                    if (scope.buttonOptions.finishTooltip !== null) {
                        finishBtn.tooltip({
                            title: scope.buttonOptions.finishTooltip
                        });
                    }
                }
            }
        };
    }
})();;
(function () {

  angular.module('hpe.elements.marqueeWizard').controller('MarqueeWizardCtrl', MarqueeWizardCtrl);

  MarqueeWizardCtrl.$inject = ['$scope'];

  function MarqueeWizardCtrl($scope) {
    var vm = this;

    //get all the steps available
    vm.steps = $scope.wizardSteps;

    //initially set the completed state to false for each step
    processSteps();

    //select the first step initially
    vm.stepIndex = 0;
    vm.currentStep = vm.steps[vm.stepIndex];
    vm.currentStep.visited = true;
    vm.currentStep.error = false;

    //side info
    vm.sidePanelInfo = $scope.sideInfo || null;

    if (vm.sidePanelInfo !== null) {
      vm.sidePanelTitle = vm.sidePanelInfo.title || null;
      vm.sidePanelDescription = vm.sidePanelInfo.description || null;
    }

    //process the button options
    updateButtonOptions();

    //determine which buttons to show
    updateButtonVisibility();

    //watch for changes to the button options
    $scope.$watch('buttonOptions', function (nv, ov) {
      if (angular.equals(nv, ov)) {
        updateButtonOptions();
      }
    }, true);

    /*
      Public Functions
    */

    //allow the user to go to the next step
    vm.goNext = function () {
      //check if we are on the last page
      if (vm.stepIndex === vm.steps.length - 1) return;

      //if on change function specified call it and await its response
      if (typeof $scope.onChanging === 'function') {
        var response = $scope.onChanging(vm.stepIndex, vm.stepIndex + 1);

        //dont go to the next page if the response is false
        if (response === false) {
          vm.currentStep.error = true;
          return;
        }
        vm.currentStep.error = false;
      }

      //mark page as completed and visited
      vm.currentStep.completed = true;

      //move to the next page
      vm.stepIndex++;
      vm.currentStep = vm.steps[vm.stepIndex];

      //mark the new step as visited
      vm.currentStep.visited = true;

      //determine which buttons to show
      updateButtonVisibility();
    };

    //allow the user to go to the previous step
    vm.goPrevious = function () {
      //check if we are on the first page
      if (vm.stepIndex === 0) return;

      //if on change function specified call it and await its response
      if (typeof $scope.onChanging === 'function') {
        var response = $scope.onChanging(vm.stepIndex, vm.stepIndex - 1);

        //dont go to the previous page if the response is false
        if (response === false) return;
      }

      vm.currentStep.error = false;

      //move to the next page
      vm.stepIndex--;
      vm.currentStep = vm.steps[vm.stepIndex];

      //determine which buttons to show
      updateButtonVisibility();
    };

    //allow the user to finish
    vm.finish = function () {

      //if on finishing function specified call it and await its response
      if (typeof $scope.onFinishing === 'function') {
        var response = $scope.onFinishing();

        //dont go to the next page if the response is false
        if (response === false) {
          vm.currentStep.error = true;
          return;
        }
        vm.currentStep.error = false;
      }

      //mark the final step as complete
      vm.currentStep.completed = true;

      //if a function was specified to be called when the finish button is clicked call it
      if (typeof $scope.onFinished === 'function') $scope.onFinished();
    };

    //if modal is dimissed using the close button
    vm.cancel = function () {
      //if a function was specified to be called when the modal is canceled then call it
      if (typeof $scope.onCanceled === 'function') $scope.onCanceled();
    };

    vm.goToStep = function (stepIdx) {
      var targetStep = vm.steps[stepIdx];

      if (targetStep.visited === true) {
        vm.currentStep.error = false;
        vm.stepIndex = stepIdx;
        vm.currentStep = vm.steps[vm.stepIndex];

        //determine which buttons to show
        updateButtonVisibility();
      }
    };

    /*
      Private Functions
    */
    function processSteps() {
      //add an additional property on the steps to store its completed and visited state
      vm.steps.forEach(function (step) {
        step.completed = false;
        step.visited = $scope.isVisited !== null || $scope.isVisited !== undefined ? $scope.isVisited : false;
      });
    }

    function updateButtonVisibility() {

      //set initially hide all the buttons
      vm.showPrevious = false;
      vm.showNext = false;
      vm.showFinish = false;

      //show buttons accordingly
      if (vm.stepIndex > 0 && vm.buttonOptions.showPrevious === true) vm.showPrevious = true;
      if (vm.stepIndex === vm.steps.length - 1 && vm.buttonOptions.showFinish === true) vm.showFinish = true;
      else if (vm.buttonOptions.showNext) vm.showNext = true;
    }

    function updateButtonOptions() {
      var options = $scope.buttonOptions;

      var defaultOptions = {
        previousText: 'Previous',
        nextText: 'Next',
        finishText: 'Finish',
        showPrevious: true,
        showNext: true,
        showFinish: true,
        previousTooltip: null,
        nextTooltip: null,
        finishTooltip: null,
        previousEnabled: true,
        nextEnabled: true,
        finishEnabled: true
      };

      //store the button options
      vm.buttonOptions = angular.extend(defaultOptions, options);
    }

  }
})();;
(function () {

    angular.module('hpe.elements.marqueeWizard').directive('marqueeWizardStep', marqueeWizardStep);

    marqueeWizardStep.$inject = ['$templateRequest', '$compile', '$rootScope', '$parse'];

    function marqueeWizardStep($templateRequest, $compile, $rootScope, $parse) {
        return {
            require: '?^^form',
            restrict: 'E',
            replace: true,
            scope: false,
            link: function (scope, element, attr, formCtrl) {

                var template = $parse(attr.template)(scope);

                $templateRequest(template).then(function (result) {

                    var target_scope = $rootScope.$new(false, scope);

                    // make form accesible to the new scope
                    target_scope.form = formCtrl;

                    element.append(angular.element(result));

                    // compile the element
                    $compile(element.children().first())(target_scope);
                });

            }
        };
    }
})();;
(function () {
  angular.module("hpe.elements.menuTab", []);
})();
;
(function () {

    angular.module('hpe.elements.menuTab').directive('menuTab', menuTab);

    menuTab.$inject = ["safeTimeout"];

    function menuTab(safeTimeout) {
        return {
            restrict: 'E',
            templateUrl: 'menuTab/templates/menuTab.html',
            replace: true,
            scope: {
                tabMenuContent: '='
            },
            link: function (scope, element) {
                var currentMenuItem = null;
                var currentMenuContent = null;

                var nativeElement = element.get(0);

                var safeTimeoutInstance = safeTimeout.create(scope);
                var dropdownMenu = nativeElement.querySelector(".dropdown-menu");

                var mousedownEvent = document.createEvent("MouseEvent");
                mousedownEvent.initMouseEvent("click", true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null);

                dropdownMenu.addEventListener('click', function (event) {
                    if (!event.target.classList.contains("hyperlink-hover")) {
                        event.stopPropagation();
                    }
                });

                scope.resizeDropdown = function () {
                    var computedStyles = window.getComputedStyle(nativeElement.parentNode, null);
                    var padding = parseInt(computedStyles.paddingLeft);
                    var width = parseInt(computedStyles.width);
                    var tabWidth = (width - (padding * 2)) + "px";
                    dropdownMenu.style.width = tabWidth;
                };

                window.addEventListener('resize', scope.resizeDropdown);

                scope.addTag = function (content) {
                    var tabs = nativeElement.parentNode.children;
                    //hide the previous tab
                    if (currentMenuItem !== null && currentMenuContent !== content) {
                        for (var x = 0; x < tabs.length; x++) {
                            var oldTab = tabs[x];
                            if (oldTab.tagName.toLowerCase() === 'li' && oldTab.textContent !== null && oldTab.textContent.trim() === currentMenuItem) {
                                oldTab.querySelector("tab-heading").textContent = currentMenuContent;
                                oldTab.classList.add("hidden");
                            }
                        }
                    }

                    //show the new tab
                    for (var i = 0; i < tabs.length; i++) {
                        var tab = tabs[i];
                        if (tab.tagName.toLowerCase() === 'li' && tab.classList.contains("hidden")) {
                            if (tab.textContent !== null && tab.textContent.trim() === content) {

                                tab.querySelector("tab-heading").textContent = ("..." + content);
                                //add the dots
                                currentMenuItem = "..." + content;
                                currentMenuContent = content;
                                tab.classList.remove("hidden");

                                //select the tab                
                                safeTimeoutInstance.timeout(dispatchMouseEvent.bind(tab));
                                break;
                            }
                        }
                    }

                    function dispatchMouseEvent() {
                        this.querySelector('a').dispatchEvent(mousedownEvent);
                    }
                };
            }
        };
    }
})();;
(function () {

  angular.module('hpe.elements.minimizeMenu', []).directive("minimizeMenu", minimizeMenu);

  minimizeMenu.$inject = ['$rootScope'];

  function minimizeMenu($rootScope) {
    return {
      restrict: 'A',
      scope: {
        animate: '=?',
        autoCollapse: '=?'
      },
      link: function (scope, element) {
        var body = document.body;
        var navbarVisible = true;
        var previousWindowWidth = window.innerWidth;
        var autoCollapse = scope.autoCollapse;
        var sideNavigation = document.querySelector('.navbar-static-side-container');
        var sideNavigationWidth;

        scope.$evalAsync(function() {
          sideNavigationWidth = sideNavigation.offsetWidth;

          //initially hide is screen is small or auto collapse is true after we get the width
          if(window.innerWidth <= 1023 || autoCollapse){
            minimize();
          }
        });

        if(scope.animate){
          body.classList.add("animate-navbar");
        }

        //minimize the side menu
        var minimize = function() {
          body.classList.add("hide-navbar");
          sideNavigation.style.marginLeft = "-" + sideNavigationWidth + "px";
          navbarVisible = false;
        };

        //maximize the side menu
        var maximize = function() {
          body.classList.remove("hide-navbar");
          sideNavigation.style.marginLeft = "0";
          navbarVisible = true;
        };

        //button is clicked
        element.on("click", function() {
          if(navbarVisible){
            minimize();
          } else {
            maximize();
          }
        });

        //window resize
        window.addEventListener('resize', function(){

          //dont do anything if auto collapse is true
          if(autoCollapse){
            return;
          }

          if(window.innerWidth <= 1023 && navbarVisible === true && previousWindowWidth > 1023){
            minimize();
          } else if(window.innerWidth > 1023 && navbarVisible === false && previousWindowWidth <= 1023){
            maximize();
          }
          //store the old screen position so it only shows/hides when required and not every resize
          previousWindowWidth = window.innerWidth;
        });

        //if auto collapse is true the side bar should collapse when state changes
        var stateChanged = function () {
          if(autoCollapse && navbarVisible === true){
            minimize();
          }
        };
        $rootScope.$on('$stateChangeStart', stateChanged);

      }

    };
  }

})();;
(function() {
  angular.module('hpe.elements.modalInsetPanel', ['hpe.elements.templates']);
})();
;
(function () {

    angular.module('hpe.elements.modalInsetPanel').directive('modalInsetContent', modalInsetContent);

    modalInsetContent.$inject = ['$parse', '$compile', '$templateCache', '$templateRequest'];

    function modalInsetContent($parse, $compile, $templateCache, $templateRequest) {
        return {
            restrict: 'E',
            transclude: true,
            replace: true,
            template: '<div class="modal-panel-content"></div>',
            link: function (scope, element, attrs, controllers, transclude) {

                var template = attrs.panelTemplate ? $parse(attrs.panelTemplate)(scope.$parent) : null;

                //if we have a template specified - dont transclude - load template then insert
                if (template !== null) {

                    //watch for the template changing
                    scope.$watch(function () {
                        return $parse(attrs.panelTemplate)(scope.$parent);
                    }, function (nv, ov) {
                        if (nv === ov) return;

                        //if the new template is an empty string just empty contents
                        if (nv.trim() === '') {
                            element.empty();
                            return;
                        }

                        //load and render new template
                        getTemplate(nv, function (tpl) {
                            renderTemplate(tpl);
                        });

                    });

                    //if the template is an empty string then empty element
                    if (template.trim() === '') {
                        element.empty();
                        return;
                    }

                    //load and render template
                    getTemplate(template, function (tpl) {
                        renderTemplate(tpl);
                    });

                } else {
                    //if no template specified perform manually transclusion to provide the appropriate scope after transclusion
                    transclude(scope.$parent, function (clone) {
                        element.append(clone);
                    });
                }


                function getTemplate(url, callback) {

                    //check if template was cached
                    var cachedTemplate = $templateCache.get(url);

                    if (cachedTemplate) {
                        //call back with the template
                        callback(cachedTemplate);
                        return;
                    }

                    //create request to load template
                    var request = $templateRequest(url);

                    //once request has completed compile and append
                    request.then(function (result) {

                        //cache the template for future use
                        $templateCache.put(url, result);

                        //call back with the template
                        callback(result);
                    });
                }

                function renderTemplate(template) {

                    //compile the template with the parent scope
                    var compiledTemplate = $compile(template)(scope.$parent);

                    //remove any current contents
                    element.empty();

                    //append compiled element
                    element.append(compiledTemplate);
                }
            }
        };
    }
})();;
(function () {

    angular.module('hpe.elements.modalInsetPanel').directive('modalInsetHeader', modalInsetHeader);

    function modalInsetHeader() {
        return {
            restrict: 'E',
            transclude: true,
            replace: true,
            templateUrl: 'modalInsetPanel/templates/modalInsetHeader.html',
            link: function (scope, element, attrs, controllers, transclude) {

                //perform manually transclusion to provide the appropriate scope after transclusion
                transclude(scope.$parent, function (clone) {
                    element.find('.header-content').append(clone);
                });

                //find the close container element to allow closing of the element on click
                var closeElement = element.find('.close-container');

                var allowDismiss = attrs.allowDismiss && attrs.allowDismiss === 'false' ? false : true;

                //if they do not want the dismiss button to be shown, hide it
                if (allowDismiss === false) {
                    closeElement.hide();
                }

                //hide panel when close button is clicked
                closeElement.click(function (event) {

                    scope.$apply(function () {
                        scope.showPanel = false;
                    });
                    event.stopPropagation();
                });
            }
        };
    }
})();;
(function () {

    angular.module('hpe.elements.modalInsetPanel').directive('modalInsetPanel', modalInsetPanel);

    modalInsetPanel.$inject = ['safeAnimationFrame'];

    function modalInsetPanel(safeAnimationFrame) {
        return {
            restrict: 'E',
            transclude: true,
            replace: true,
            template: '<div class="modal-panel-region"><div class="modal-panel"></div></div>',
            scope: {
                showPanel: '=',
                panelWidth: '=',
                panelSide: '=',
                onDismiss: '=?'
            },
            link: function (scope, element, attrs, controllers, transclude) {

                //perform manually transclusion to provide the appropriate scope after transclusion
                transclude(scope, function (clone) {
                    element.find('.modal-panel').append(clone);
                });

                //store the current offset - avoid making dom measurements
                var transformX = 0,
                    sideMultiplier = scope.panelSide === 'left' ? -1 : 1,
                    panelWidth = scope.panelWidth;

                //store the different states in a 'enum' style structure
                var states = {
                    closed: 1,
                    closing: 2,
                    opening: 3,
                    open: 4
                };

                //hold current state
                var state = (scope.showPanel === false) ? states.closed : states.open;

                //get the modal panel element
                var modalPanel = element.find('.modal-panel');

                //set panel side classes and multiplier
                setPanelSide();

                //set the initial panel size
                resizeModalPanel();

                //instantiate the safeAnimationFrame service with current scope
                var animationInstance = safeAnimationFrame.create(scope);

                //on animation frame do update position etc..
                animationInstance.animationFrame(updatePanel);

                //watch the showPanel property for changes
                scope.$watch('showPanel', function (nv, ov) {
                    if (nv !== ov) {
                        if (nv === true) showPanel();
                        else {
                            hidePanel();
                        }
                    }
                });

                //watch for changes to the desired modal side
                scope.$watch('panelSide', function (nv, ov) {
                    if (nv !== ov) setPanelSide();
                });

                //watch the panel size changing - dont store if width is 0, means it is hidden
                scope.$watch('panelWidth', function (nv, ov) {
                    if (nv !== ov) {
                        panelWidth = nv;

                        //set the actual panel size
                        resizeModalPanel();
                    }
                });

                //if the user clicks inside the modal panel container hide the panel
                element.click(function () {
                    scope.showPanel = false;
                });

                //if the user clicks inside the panel then stop propagation
                modalPanel.click(function (event) {
                    event.stopPropagation();
                });

                function setPanelSide() {
                    //apply the appropriate side class
                    if (scope.panelSide === 'left') {
                        modalPanel.removeClass('right');
                        modalPanel.addClass('left');
                    } else {
                        modalPanel.removeClass('left');
                        modalPanel.addClass('right');
                    }

                    //update side multiplier
                    sideMultiplier = scope.panelSide === 'left' ? -1 : 1;

                    //call resize panel to update position if closed
                    resizeModalPanel();
                }

                function resizeModalPanel() {
                    //ensure we have the latest size
                    panelWidth = scope.panelWidth;

                    //actually size the element
                    modalPanel.width(panelWidth);

                    //if the panel should be offscreen - update position
                    if (state === states.closed || state === states.opening) {
                        var targetOffset = (panelWidth + 10) * sideMultiplier;
                        transformX = targetOffset;
                        modalPanel.get(0).style.transform = 'translateX(' + transformX + 'px)';
                    }
                }

                function showPanel() {
                    //ensure showPanel has the correct value
                    scope.showPanel = true;

                    //ensure the element is visible
                    element.get(0).style.display = 'block';

                    //begin animation to open panel
                    state = states.opening;
                }

                function hidePanel() {
                    //ensure showPanel has the correct value
                    scope.showPanel = false;

                    //update the state
                    state = states.closing;

                    //if a function was specified to be called when dismissed then call it.
                    if (scope.onDismiss) scope.onDismiss();
                }

                function updatePanel() {
                    //take all require measurments up front to avoid reflow
                    var targetOffset = (panelWidth + 10) * sideMultiplier;

                    //calculate how much the position should change every frame - assume ~60fps - target duration 0.1 seconds
                    var tick = panelWidth / (60 * 0.1);

                    switch (state) {
                        case states.closed:
                            if (transformX !== targetOffset) {
                                transformX = targetOffset;
                                modalPanel.get(0).style.transform = 'translateX(' + transformX + 'px)';

                                //hide the container element
                                if (element.get(0).style.display !== 'none') element.get(0).style.display = 'none';
                            } else {
                                //ensure the container element is hidden
                                if (element.get(0).style.display !== 'none') element.get(0).style.display = 'none';
                            }
                            break;

                        case states.closing:

                            //begin moving toward an offset of targetOffset
                            if (transformX < targetOffset) {

                                //increment the position by the tick amount
                                transformX += tick;

                                //check to see if animation has finished
                                if (transformX >= targetOffset) {
                                    transformX = targetOffset;
                                    state = states.closed;
                                }
                            } else {
                                //increment the position by the tick amount
                                transformX -= tick;

                                //check to see if animation has finished
                                if (transformX <= targetOffset) {
                                    transformX = targetOffset;
                                    state = states.closed;
                                }
                            }

                            //set position - using css transforms for smooth animation - especially on mobile
                            modalPanel.get(0).style.transform = 'translateX(' + transformX + 'px)';
                            break;

                        case states.opening:

                            //begin moving toward an offset of zero
                            if (transformX < 0) {

                                //increment the position by the tick amount
                                transformX += tick;

                                //check to see if animation has finished
                                if (transformX >= 0) {
                                    transformX = 0;
                                    state = states.open;
                                }
                            } else {
                                //increment the position by the tick amount
                                transformX -= tick;

                                //check to see if animation has finished
                                if (transformX <= 0) {
                                    transformX = 0;
                                    state = states.open;
                                }
                            }

                            //set position - using css transforms for smooth animation - especially on mobile
                            modalPanel.get(0).style.transform = 'translateX(' + transformX + 'px)';
                            break;

                        case states.open:
                            if (transformX !== 0) {
                                transformX = 0;
                                modalPanel.get(0).style.transform = 'translateX(' + 0 + 'px)';
                            }
                            break;
                    }

                }


            }
        };
    }
})();;
(function () {  
  angular.module("hpe.elements.multipleListSelect", ["hpe.elements.templates"]);
})();;
(function () {

  angular.module("hpe.elements.multipleListSelect").controller("displayCancelOptionCtrl", DisplayCancelOptionCtrl);

  DisplayCancelOptionCtrl.$inject = ["$scope", "multipleSelectProvider"];

  function DisplayCancelOptionCtrl($scope, multipleSelectProvider) {
    this.provider = multipleSelectProvider;


    this.state = this.provider.state;
  }

})();;
(function () {

  angular.module("hpe.elements.multipleListSelect").directive("displayCancelOption", displayCancelOption);

  function displayCancelOption() {
    return {
      restrict: "E",
      transclude: true,
      replace: true,
      templateUrl: "multipleListSelect/displayCancelOption/template/displayCancelOption.html",
      controller: "displayCancelOptionCtrl as dc"
    };
  }
})();;
(function () {

  angular.module("hpe.elements.multipleListSelect").controller("displaySelectOptionsCtrl", displaySelectOptionsCtrl);
  displaySelectOptionsCtrl.$inject = ["$scope", "multipleSelectProvider"];

  function displaySelectOptionsCtrl($scope, multipleSelectProvider) {
    this.provider = multipleSelectProvider;

    this.state = this.provider.state; 

  }

})();;
(function () {

  angular.module("hpe.elements.multipleListSelect").directive("displaySelectOptions", displaySelectOptions);

  function displaySelectOptions() {
    return {
      restrict: "E",
      transclude: true,
      replace: true,
      templateUrl: "multipleListSelect/displaySelectOptions/template/displaySelectOptions.html",
      controller: "displaySelectOptionsCtrl as ds"
    };
  }
})();;
(function () {
  
  angular.module("hpe.elements.multipleListSelect").controller("multipleListSelectActionsCtrl", MultipleListSelectActionsCtrl);
  MultipleListSelectActionsCtrl.$inject = ["$scope", "multipleSelectProvider"];

  function MultipleListSelectActionsCtrl($scope, multipleSelectProvider) {
    this.provider = multipleSelectProvider;
    this.provider.onSelect = $scope.onSelect;
    this.provider.onDeselect = $scope.onDeselect;
    this.provider.total = $scope.total;
    //only override keyfn if one exists
    this.provider.keyFn = $scope.keyFn;

    this.state = this.provider.state;

  }

})();;
(function () {
  
  angular.module("hpe.elements.multipleListSelect").directive("multipleListSelectActions", multipleListSelectActions);
  multipleListSelectActions.$inject = ["$document", "multipleSelectProvider"];

  function multipleListSelectActions($document, multipleSelectProvider) {
    return {
      restrict: "E",
      transclude: true,
      replace: true,
      templateUrl: "multipleListSelect/multipleListSelectActions/template/multipleListSelectActions.html",
      controller: "multipleListSelectActionsCtrl as dssa",
      scope: {
        onSelect: "&",
        onDeselect: "&",
        keyFn: "&",
        total: "="
      },
      link: function (scope, element) {
        //look for toolbars
        var toolbar = element.parents(".affix-element");
        var disp = element.find(".disp");
        var revDisp = element.find(".reverse-disp");
        var multipleSelectOptions = revDisp.find("*");
        var disabledButtons = false;
        //watch for the selection state changing
        scope.$watch("dssa.state", function (nv, ov) {
          //if selecting mode
          //this logic is to make buttons disabled when count is zero
          if ((nv.count === 0 && ov.count > 0) && nv.selecting === true && nv.selectedFromCheckBox === true) {
            multipleSelectProvider.reset();
            if (disabledButtons === false) {
              for (var i = multipleSelectOptions.length - 1; i >= 0; i--) {
                if (multipleSelectOptions[i].disabled === false) {
                  multipleSelectOptions[i].disabled = true;
                }
              }
              disabledButtons = true;
            }
          } else if (nv.count > 0) {
            if (disabledButtons === true) {
              for (var j = multipleSelectOptions.length - 1; j >= 0; j--) {
                if (multipleSelectOptions[j].disabled === true) {
                  multipleSelectOptions[j].disabled = false;
                }
              }
              disabledButtons = false;
            }
          }
          if (nv.selecting) {
            //bind to esc key to exit.
            $document.off("keyup.multipleSelect").on("keyup.multipleSelect", function (e) {
              if (e.keyCode === 27) {
                multipleSelectProvider.cancel();
                scope.$apply();
              }
            });
            //if we are in a toolbar set the class
            if (toolbar.length) {
              toolbar.addClass("multiple-select-mode");
              disp.addClass("donot-disp");
              revDisp.removeClass("donot-disp");
            }
          } else {
            if (toolbar.length) {
              toolbar.removeClass("multiple-select-mode");
              disp.removeClass("donot-disp");
              revDisp.addClass("donot-disp");
            }
            $document.off("keyup.multipleSelect");
          }
        }, true);

        //watch for total count changes
        scope.$watch("total", function (nv) {

          multipleSelectProvider.total = nv;
          multipleSelectProvider.validateSelection();

        });

        //remove any bindings on destroy.
        scope.$on("$destroy", function () {
          $document.off("keyup.multipleSelect");
          multipleSelectProvider.cancel();
        });

      }
    };
  }
})();;
(function () {

  angular.module("hpe.elements.multipleListSelect").directive("multipleListSelectItem", multipleListSelectItem);
  multipleListSelectItem.$inject = ["multipleSelectProvider"];

  function multipleListSelectItem(multipleSelectProvider) {
    return {
      restrict: "A",
      priority: -1,
      link: function (scope, element, attrs) {
        //look for the parent row with class single-click to highlight when that row is selected
        var parentRow = element.parents(".single-select");
        var loaded = false;
        //multiple list select check box focus and row highlight 
        scope.$watch(
          function () {
            var receivedFocus = false;
            receivedFocus = receivedFocus || element.hasClass("preview-pane-selected-item");
            return receivedFocus;
          },
          function (nV) {

            if (nV) {
              element.attr("style", "opacity:1");
              element.parents("tr").addClass("highlight");
            } else {
              element.removeAttr("style");
              element.parents("tr").removeClass("highlight");
              if (!loaded) {
                var rowIndex = Number(element.parents("tr").attr("index") || 0);
                element.attr("index", rowIndex - 1);
                loaded = true;
              }
            }
          });

        scope.$watch(function () {
            return multipleSelectProvider.state.selecting;
          },
          function (nv, ov) {

            if (nv !== ov && nv === false) {
              element.parents("tr").removeClass("highlight");
            }
          });

        if (attrs.multipleListSelectItem) {
          var item = scope.$eval(attrs.multipleListSelectItem);
          if (item) {
            var clickFunction = function (e) {
              multipleSelectProvider.state.selecting = true;
              if (multipleSelectProvider.state.selectedFromButton === false) {
                multipleSelectProvider.state.selectedFromCheckBox = true;
              }
              scope.$apply();
              if (oldSelecting === true) {
                e.preventDefault();
                e.stopImmediatePropagation();
                if (multipleSelectProvider.itemClicked(item)) {
                  parentRow.addClass("single-select-selected-bg");
                  element.addClass("multi-select-checkbox-checked");

                } else {
                  parentRow.removeClass("single-select-selected-bg");
                  element.removeClass("multi-select-checkbox-checked");
                }
                scope.$apply();
              }
            };

            scope.state = multipleSelectProvider.state;
            var oldSelecting = scope.state.selecting;
            //set up click
            element.on("click.multiSelect", function (e) {
              clickFunction(e);
            });
            // for keyboard controls
            element.on("keyup.multiSelect", function (e) {
              parentRow.addClass("highlight");
              if (e.keyCode !== 32) {
                return;
              }
              clickFunction(e);
            });

            scope.$watch("state", function (nv) {
              if (nv.selecting && oldSelecting !== nv.selecting) {
                oldSelecting = true;
                parentRow.addClass("multiple-list-select-item--selecting");
              } else if (!nv.selecting) {
                oldSelecting = false;
                parentRow.removeClass("single-select-selected-bg");
                element.removeClass("multi-select-checkbox-checked");
                parentRow.removeClass("multiple-list-select-item--selecting");
              }

              //check if the item is still selected or not.
              if (nv.selecting && multipleSelectProvider.isSelected(item)) {
                parentRow.addClass("single-select-selected-bg");
                element.addClass("multi-select-checkbox-checked");
              } else {
                parentRow.removeClass("single-select-selected-bg");
                element.removeClass("multi-select-checkbox-checked");
              }


            }, true);

            //set up ui from current state
            if (oldSelecting === true) {
              parentRow.addClass("multiple-list-select-item--selecting");
              if (multipleSelectProvider.isSelected(item)) {
                parentRow.addClass("single-select-selected-bg");
                element.addClass("multi-select-checkbox-checked");
              }
            }



            scope.$on("destroy", function () {
              element.off("click.multiSelect");
              parentRow.removeClass("single-select-selected-bg");
              element.removeClass("multi-select-checkbox-checked");
            });
          }
        }
      }
    };
  }
})();;
(function () {  
  angular.module("hpe.elements.multipleRowSelect", ["hpe.elements.templates"]);
})();;
(function () {
  
  angular.module("hpe.elements.multipleListSelect").directive("multipleRowSelectItem", multipleRowSelectItem);
  multipleRowSelectItem.$inject = ["multipleSelectProvider"];

  function multipleRowSelectItem(multipleSelectProvider) {
    var SelectedClass = "shift-select-selected-bg";
    return {
      restrict: "A",
      link: function (scope, element, attrs) {
        if (attrs.multipleRowSelectItem) {
          // Prevent shift click from selecting text
          angular.element(element).children("*").css({
            "user-select": "none",
            "-ms-user-select": "none",
            "-moz-user-select": "none",
            "-webkit-user-select": "none"
          });
          var item = scope.$eval(attrs.multipleRowSelectItem);
          var itemIndex = scope.$index;
          if (item) {
            //set up click
            element.on("click.multiSelect", function (e) {
              if (e.shiftKey) {
                extendSelection();
              }
              else if (e.ctrlKey) {
                addToSelection();
              }
              else {
                startSelection();
              }
              e.preventDefault();
              e.stopImmediatePropagation();
            });

            // for keyboard controls
            element.on("keydown.multiSelect", function (e) {
              if (e.keyCode === 32) {
                addToSelection();
                e.preventDefault();
                e.stopImmediatePropagation();
              }
            });
            
            // Custom event triggered by keyboardNavigableTable to handle shift key extension
            element.on("receivedSelection.keyboardNavigableTable", function(e) {
              if (!e.ctrlKey) {
                if (e.shiftKey) {
                  extendSelection();
                }
                else {
                  startSelection();
                }
              }
            });

            // Prevent selection of text on shift click for IE
            element.on("selectstart", function(e) {
              e.preventDefault();
              return false;
            });

            scope.$watch(function() {
              return multipleSelectProvider.isSelected(item);
            }, function (nv) {
              //check if the item is still selected or not.
              if (nv) {
                element.addClass(SelectedClass);
              } else {
                element.removeClass(SelectedClass);
              }
            }, true);

            scope.$on("destroy", function () {
              element.off("click.multiSelect");
              element.removeClass(SelectedClass);
            });
          }
        }

        // Clear selection and select this row
        function startSelection() {
          multipleSelectProvider.state.selecting = true;
          if(multipleSelectProvider.state.selectedFromButton === false) {
            multipleSelectProvider.state.selectedFromCheckBox = true;
          }

          multipleSelectProvider.selectNone();

          multipleSelectProvider.multipleRowSelectItemPreviousSelectionDirection = undefined;
          if (multipleSelectProvider.itemClicked(item)) {
            multipleSelectProvider.multipleRowSelectOriginIndex = itemIndex;
            element.addClass(SelectedClass);
          }
          scope.$apply();
        }

        // Add this row to the current selection
        function addToSelection() {
          if (!multipleSelectProvider.state.selecting) {
            startSelection();
          }
          else {
            multipleSelectProvider.multipleRowSelectItemPreviousSelectionDirection = undefined;
            if (multipleSelectProvider.itemClicked(item)) {
              multipleSelectProvider.multipleRowSelectOriginIndex = itemIndex;
              element.addClass(SelectedClass);
            }
            else {
              element.removeClass(SelectedClass);
            }
            scope.$apply();
          }
        }

        // Add this row and all intermediate rows to the current selection
        function extendSelection() {
          if (!multipleSelectProvider.state.selecting) {
            startSelection();
          }
          else {
            var itemsToSelect = getItemsToSelect(multipleSelectProvider.multipleRowSelectOriginIndex, itemIndex);
            if (multipleSelectProvider.rangeClicked(itemsToSelect.itemIndices)) {
              for (var i in itemsToSelect.elements) {
                itemsToSelect.elements[i].addClass(SelectedClass);
              }
            } else {
              for (var j in itemsToSelect.elements) {
                itemsToSelect.elements[j].removeClass(SelectedClass);
              }
            }
            scope.$apply();
          }
        }
        
        function getItemsToSelect(lastIndex, currentIndex) {
          var result = {
            itemIndices: [],
            elements: []
          };
          //Ensure we have an index for the clicked item (expected)
          if (currentIndex !== null && currentIndex !== undefined){

            //If this is the first item clicked there's no previous index to look at
            if (lastIndex === null || lastIndex === undefined){
              result.itemIndices.push(getItemFromRow(currentIndex));
              result.elements.push(element);
            }
            else {
              var rowItems = [];
              var from = Math.min(lastIndex, currentIndex);
              var to = Math.max(lastIndex, currentIndex);

              for (var i = from; i <= to; i++){
                rowItems[i] = getItemFromRow(i);
                result.itemIndices.push(rowItems[i].item);
                result.elements.push(rowItems[i].element);
              }
            }
          }

          return result;
        }

        function getItemFromRow(index){
          var el = element.parent().children("tr").eq(index);
          return{
            item : el.scope().$eval(
              el.attr("multiple-row-select-item")
            ),
            element : el
          } ;
        }
      }
    };
  }
})();
;
(function () {
  angular.module("hpe.elements.multipleSelect", ["hpe.elements.templates"]);
})();;
(function () {
  
  angular.module("hpe.elements.multipleSelect").controller("MultipleSelectActionCtrl", MultipleSelectActionCtrl);
  MultipleSelectActionCtrl.$inject = ["$scope", "multipleSelectProvider"];

  function MultipleSelectActionCtrl($scope, multipleSelectProvider) {
    this.name = $scope.name;
    this.callback = $scope.action;
    this.provider = multipleSelectProvider;
    this.type = $scope.type || "white";
  }
  
  MultipleSelectActionCtrl.prototype.activate = function () {
    this.provider.action = this;
    this.provider.state.selecting = true;
    this.provider.state.selectedFromButton=true;
    this.provider.state.selectedFromCheckBox=false;
  };

})();;
(function () {
  
  angular.module("hpe.elements.multipleSelect").directive("multipleSelectAction", multipleSelectAction);

  function multipleSelectAction() {
    return {
      restrict: "E",
      require: "^^multipleSelectActions",
      templateUrl:"multipleSelect/multipleSelectAction/template/multipleSelectAction.html",
      transclude: true,
      replace: true,
      controller: "MultipleSelectActionCtrl as msa",
      scope: {
        name: "@",
        action: "&",
        type:"@"
      }
    };
  }
})();;
(function () {
  
  angular.module("hpe.elements.multipleSelect").controller("MultipleSelectActionsCtrl", MultipleSelectActionsCtrl);
  MultipleSelectActionsCtrl.$inject = ["$scope", "multipleSelectProvider"];

  function MultipleSelectActionsCtrl($scope, multipleSelectProvider) {
    this.provider = multipleSelectProvider;
    this.provider.onSelect = $scope.onSelect;
    this.provider.onDeselect = $scope.onDeselect;
    this.provider.total = $scope.total;
    //only override keyfn if one exists
    this.provider.keyFn = $scope.keyFn;

    this.state = this.provider.state;
  }

})();;
(function () {
  
  angular.module("hpe.elements.multipleSelect").directive("multipleSelectActions", multipleSelectActions);
  multipleSelectActions.$inject = ["$document", "multipleSelectProvider"];

  function multipleSelectActions($document, multipleSelectProvider) {
    return {
      restrict: "E",
      transclude: true,
      replace: true,
      templateUrl: "multipleSelect/multipleSelectActions/template/multipleSelectActions.html",
      controller: "MultipleSelectActionsCtrl as mssa",
      scope: {
        onSelect: "&",
        onDeselect: "&",
        keyFn: "&",
        total: "="
      },
      link: function (scope, element) {
        //look for toolbars
        var toolbar = element.parents(".affix-element");
        //watch for the selection state changing
        scope.$watch("mssa.state", function (nv) {
          //if selecting mode
          if (nv.selecting) {
            //bind to esc key to exit.
            $document.off("keyup.multipleSelect").on("keyup.multipleSelect", function (e) {
              if (e.keyCode === 27) {
                multipleSelectProvider.cancel();
                scope.$apply();
              }
            });
            //if we are in a toolbar set the class
            if (toolbar.length) {
              toolbar.addClass("multiple-select-mode");
            }
          } else {
            if (toolbar.length) {
              toolbar.removeClass("multiple-select-mode");
            }
            $document.off("keyup.multipleSelect");
          }
        }, true);

        //watch for total count changes
        scope.$watch("total", function (nv) {

          multipleSelectProvider.total = nv;
          multipleSelectProvider.validateSelection();

        });

        //remove any bindings on destroy.
        scope.$on("$destroy", function () {
          $document.off("keyup.multipleSelect");
          multipleSelectProvider.cancel();
        });

      }
    };
  }
})();;
(function () {

  angular.module("hpe.elements.multipleSelect").directive("multipleSelectItem", multipleSelectItem);
  multipleSelectItem.$inject = ["multipleSelectProvider"];

  function multipleSelectItem(multipleSelectProvider) {
    return {
      restrict: "A",
      priority: -1, //need -1 so that this executes before ng-click handlers
      link: function (scope, element, attrs) {
        if (attrs.multipleSelectItem) {
          var item = scope.$eval(attrs.multipleSelectItem);
          if (item) {

            scope.state = multipleSelectProvider.state;
            var oldSelecting = scope.state.selecting;

            var clickFunction = function (e) {

              if (oldSelecting === true) {
                e.preventDefault();
                e.stopImmediatePropagation();
                if (multipleSelectProvider.itemClicked(item)) {
                  element.addClass("multiple-select-item--selected");
                } else {
                  element.removeClass("multiple-select-item--selected");
                }
                scope.$apply();
              }
            };

            //set up click
            element.on("click.multiSelect", function (e) {
              clickFunction(e);
            });

            element.on("keyup.multiSelect", function (e) {
              if (e.keyCode !== 32) {
                return;
              }
              clickFunction(e);
            });

            scope.$watch("state", function (nv) {
              if (nv.selecting && oldSelecting !== nv.selecting) {
                element.addClass("multiple-select-item--selecting");
                oldSelecting = true;
              } else if (!nv.selecting) {
                oldSelecting = false;
                element.removeClass("multiple-select-item--selected");
                element.removeClass("multiple-select-item--selecting");
              }

              //check if the item is still selected or not.
              if (nv.selecting && multipleSelectProvider.isSelected(item)) {
                element.addClass("multiple-select-item--selected");
              } else {
                element.removeClass("multiple-select-item--selected");
              }


            }, true);

            //set up ui from current state
            if (oldSelecting === true) {
              element.addClass("multiple-select-item--selecting");
              if (multipleSelectProvider.isSelected(item)) {
                element.addClass("multiple-select-item--selected");
              }
            }



            scope.$on("destroy", function () {
              element.off("click.multiSelect");
              element.removeClass("multiple-select-item--selected");
            });
          }
        }
      }
    };
  }
})();;
(function () {

  angular.module("hpe.elements.multipleSelect").provider("multipleSelectProvider", multipleSelectProvider);

  function multipleSelectProvider() {


    multipleSelectFactory.$inject = ["$timeout"];

    function multipleSelectFactory($timeout) {
      return new MultipleSelect($timeout);
    }
    this.$get = multipleSelectFactory;

  }


  function MultipleSelect($timeout) {
    //$timeout for the display error
    this.$timeout = $timeout;
    this.showError = false;

    //state has to be an object so that when it changes
    //all references to it in $scopes will trigger a change
    this.state = {
      selecting: false,
      count: 0,
      selectAllMode: false,
      selectedFromButton: false,
      selectedFromCheckBox: false

    };
    this.selectedItems = [];
    this.deselectedItems = [];
    this.currentSelectedRange = [];
    //the multiple selection action ctrl that was clicked originally
    this.action = null;
    //called when item is selected (single item) pass null when selecting all
    this.onSelect = null;
    //called when item is deselected (single item) pass null when deselecting all
    this.onDeselect = null;

    //total count of items that should be displayed when select all is true
    this.total = 0;
    this.selectAllTotal = 0;

    this.cancelText = "Cancel";
    this.selectItemsText = "Select items or";
    this.selectedItemsText = "Selected";
    this.selectedItemsUnitText = "items.";
    this.selectedItemUnitText = "item.";
    this.selectAllText = "Select all";
    this.selectNoneText = "Select none";
    this.selectionInvalidText = "This selection is no longer valid";

    //used for us to keep track of total items selected.
    this.keyFn = null;

  }

  MultipleSelect.prototype.validateSelection = function () {
    if (this.state.selectAllMode === true && this.state.selecting === true) {
      this.selectNone();
      this.displayError();
    }
  };
  MultipleSelect.prototype.itemsSelected = function () {
    //check we are selecting
    if (this.state.selecting) {
      //if we are in select all mode
      if (this.state.selectAllMode) {
        //we must check if everything is deselected
        if (this.deselectedItems.length === this.selectAllTotal) {
          //return false if everything is selected but then deselected
          return false;
        }
        return true;
      } else {
        //return are there any items selected
        return this.selectedItems.length > 0;
      }
    }
    return false;
  };
  MultipleSelect.prototype.displayError = function () {
    this.showError = true;
    this.$timeout(function () {
      this.showError = false;
    }.bind(this), 2000);
  };
  MultipleSelect.prototype.reset = function () {
    this.action = null;
    this.state.selecting = false;
    this.selectedItems = [];
    this.deselectedItems = [];
    this.currentSelectedRange = [];
    this.state.count = this.selectAllTotal = 0;
    this.state.selectAllMode = false;
    this.state.selectedFromButton = false;
    this.state.selectedFromCheckBox = false;
  };

  MultipleSelect.prototype.cancel = function () {
    this.reset();
    this.onDeselect({
      item: null
    });
  };
  MultipleSelect.prototype.proceed = function () {
    this.action.callback();
    this.reset();
  };
  MultipleSelect.prototype.updateCount = function () {
    if (this.selectedItems.length) {
      this.state.count = this.selectedItems.length;
    } else if (this.state.selectAllMode) {
      this.state.count = this.selectAllTotal - this.deselectedItems.length;
    } else {
      this.state.count = 0;
    }
  };
  MultipleSelect.prototype.selectNone = function () {
    this.selectedItems = [];
    this.deselectedItems = [];
    this.currentSelectedRange = [];
    this.state.count = this.selectAllTotal = 0;
    this.state.selectAllMode = false;
  };
  MultipleSelect.prototype.selectAll = function () {
    this.state.selectAllMode = true;
    this.selectedItems = [];
    this.deselectedItems = [];
    this.currentSelectedRange = [];
    this.selectAllTotal = this.total;
    this.updateCount();
    this.onSelect({
      item: null
    });
  };

  MultipleSelect.prototype.isSelected = function (item) {
    if (this.keyFn) {
      var key = this.keyFn({
        item: item
      });
      if (key === undefined || key === null) {
        return false;
      }

      //if selected items has length
      //means we are selecting normally
      if (this.selectedItems.length) {
        return this.selectedItems.indexOf(key) >= 0;
      }
      //if in selectAll mode then we are using the deselect items.
      if (this.state.selectAllMode) {
        return this.deselectedItems.indexOf(key) === -1;
      }

    }
    return false;
  };

  /*
    Method for selecting a range of necessarily contiguous items simultaneously
  */
  MultipleSelect.prototype.rangeClicked = function (itemsCollection) {
    if (this.keyFn) {
      var keys = [];
      for (var i in itemsCollection) {
        var key = this.keyFn({
          item: itemsCollection[i]
        });
        if (key === undefined || key === null) {
          return false;
        } else {
          keys.push(key);
        }
      }

      // Deselect the previous range selection, if any.
      // This allows shift clicking to expand and contract a range without affecting selections elsewhere.
      for (var c in this.currentSelectedRange) {
        var index = this.selectedItems.indexOf(this.currentSelectedRange[c]);
        if (index >= 0) {
          this.selectedItems.splice(index, 1);
        }
      }
      this.updateCount();

      for (var j in keys) {
        if (!~this.selectedItems.indexOf(keys[j])) {
          this.selectedItems.push(keys[j]);
          this.updateCount();
          this.onSelect({
            item: itemsCollection[j]
          });
        }
      }

      this.currentSelectedRange = angular.copy(keys);

      return true;
    }

    return false;
  };

  MultipleSelect.prototype.itemClicked = function (item) {
    if (this.keyFn) {
      var key = this.keyFn({
        item: item
      });
      if (key === undefined || key === null) {
        return false;
      }
      this.currentSelectedRange = [];
      //normal selection mode.
      if (this.selectedItems.length) {
        //we know that we are selecting items into the selected items array.
        var index = this.selectedItems.indexOf(key);
        if (index >= 0) {
          this.selectedItems.splice(index, 1);
          this.updateCount();
          this.onDeselect({
            item: item
          });
          //deselect
          return false;
        } else {
          this.selectedItems.push(key);
          this.updateCount();
          this.onSelect({
            item: item
          });
          return true;
        }
      }
      //select all mode
      // keeps track of deselected items.
      if (this.state.selectAllMode) {

        var idx = this.deselectedItems.indexOf(key);
        if (idx >= 0) {
          this.deselectedItems.splice(idx, 1);
          this.updateCount();
          this.onSelect({
            item: item
          });
          //Select
          return true;
        } else {
          this.deselectedItems.push(key);
          this.updateCount();
          this.onDeselect({
            item: item
          });
          return false;
        }
      }
      //nothing in deselect or select items then start pushing on select items
      if (!this.selectedItems.length && !this.state.selectAllMode) {
        this.selectedItems.push(key);
        this.updateCount();
        this.onSelect({
          item: item
        });
        return true;
      }
    }
    return false;
  };
})();;
(function() {
  angular.module('hpe.elements.nestedDonut', []);
})();
;
(function () {

    angular.module('hpe.elements.nestedDonut').directive('nestedDonut', nestedDonut);

    nestedDonut.$inject = ['d3'];

    function nestedDonut(d3) {
        return {
            restrict: 'E',
            replace: true,
            template: '<div class="nested-donut-container"><div class="tooltip top" style="display: none; opacity: 1;" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div></div>',
            scope: {
                dataset: '=',
                options: '=?'
            },
            link: function (scope, element) {
                var vm = this;

                var container = element.get(0);

                // create tooltip references
                var tooltip = element.find('.tooltip');
                var tooltip_inner = tooltip.find('.tooltip-inner');
                var current_tooltip_text;
                var tooltip_dimensions = {
                    width: 0,
                    height: 0
                };

                var svg, paths, text_label;

                // store chart data after processing
                var chart_data;

                // chart options
                var default_options = {
                    size: 150,
                    donutWidth: 4,
                    donutSpacing: 4,
                    hoverAnimation: true,
                    onHover: angular.noop,
                    onClick: angular.noop,
                    centerLabel: {
                        show: false,
                        text: '',
                        color: '#333',
                        font: 'Metric',
                        fontSize: 20
                    },
                    tooltip: {
                        show: true,
                        content: function (data) {
                            return '<b>' + data.value + '</b> ' + data.label;
                        },
                        shifts: {
                            x: 0,
                            y: 0
                        }
                    }
                };

                // create chart options by extending the default options
                var chart_options = angular.extend(default_options, scope.options);

                // ensure values are valid
                if (!angular.isNumber(chart_options.size) || chart_options.size <= 0) throw 'Nested Donut - Chart size must be a positive greater than zero.';

                // set chart width and height attributes based on pixel ratio
                container.width = chart_options.size;
                container.height = chart_options.size;
                container.style.width = chart_options.size + 'px';
                container.style.height = chart_options.size + 'px';

                // process initial data
                process_data(scope.dataset);

                // initialise chart
                init_chart();

                // watch for any changes in data
                scope.$watch('dataset', function (nv, ov) {
                    if (!angular.equals(nv, ov)) {
                        process_data(nv);
                        reinit_chart();
                    }
                }, true);

                // watch for any changes in options
                scope.$watch('options', function (nv, ov) {
                    if (!angular.equals(nv, ov)) reinit_chart();
                }, true);

                // Private Functions

                function process_data(data) {

                    if (!data || data.length === 0) {
                        chart_data = [];
                        return;
                    }

                    // slice and sort the chart data
                    chart_data = data.slice(0).sort(function (a, b) {

                        // ensure they have a value
                        if (!a.value || !b.value) throw 'Nested Donut - Chart data must have a value property!';

                        // sort the list
                        if (a.value > b.value) return -1;
                        if (a.value < b.value) return 1;
                        return 0;
                    });
                }

                function init_chart() {
                    svg = d3.select(container).append("svg").attr("width", chart_options.size).attr("height", chart_options.size)
                        .append("g").attr("transform", "translate(" + chart_options.size / 2 + "," + chart_options.size / 2 + ")");

                    // draw initial chart
                    draw_chart();
                }

                function reinit_chart() {
                    element.find('svg').remove();

                    // call init to draw chart again
                    init_chart();
                }

                function draw_chart() {

                    // predefined function for calculating the arc path
                    var arc = d3.svg.arc().innerRadius(calculate_inner_radius).outerRadius(calculate_outer_radius).startAngle(0).endAngle(calculate_angle);

                    // add paths to svg element
                    paths = svg.selectAll('path').data(d3.values(chart_data)).enter().append('path')
                        .attr('fill', fill_color).attr('opacity', 1).attr('d', arc)
                        .on('mouseover', segment_hover_start)
                        .on('mousemove', segment_hover_move)
                        .on('mouseout', segment_hover_end)
                        .on('click', segment_click);

                    // if no text label is required then stop here
                    if (chart_options.centerLabel.show === false) return;

                    // add a text label if one is required
                    text_label = svg.append('text')
                        .text(chart_options.centerLabel.text)
                        .attr("font-family", chart_options.centerLabel.font)
                        .attr("font-size", chart_options.centerLabel.fontSize + "px")
                        .attr("fill", chart_options.centerLabel.color)
                        .style("text-anchor", "middle")
                        .style("dominant-baseline", "central");
                }

                // D3 Functions

                function calculate_inner_radius(data, index) {
                    var radius = chart_options.size / 2;
                    return (radius - chart_options.donutWidth) - ((chart_options.donutWidth + chart_options.donutSpacing) * index);
                }

                function calculate_outer_radius(data, index) {
                    var radius = chart_options.size / 2;
                    return radius - ((chart_options.donutWidth + chart_options.donutSpacing) * index);
                }

                function calculate_angle(data) {
                    var max_data = chart_data[0].value;
                    return (data.value / max_data) * (2 * Math.PI);
                }

                function fill_color(data) {
                    return data.color;
                }

                function segment_hover_start(data) {

                    // the path being hovered is provided as the context
                    var hovered_path = this;

                    if (chart_options.hoverAnimation)
                        d3.select(hovered_path).transition().ease("ease-in-out").duration("300").attr("opacity", 0.5);

                    // update the tooltip if enabled
                    update_tooltip.apply(hovered_path, [data]);

                    // call on hover event
                    chart_options.onClick.apply(vm, [data]);
                }

                function segment_hover_move(data) {
                    // if the tooltip is enabled then update the position
                    update_tooltip(data);
                }

                function segment_hover_end() {
                    // the path being hovered is provided as the context
                    var hovered_path = this;

                    // revent any states caused by hover event
                    if (chart_options.hoverAnimation)
                        d3.select(hovered_path).transition().ease("ease-in-out").duration("300").attr("opacity", 1);

                    // if tooltips are enabled then hide any visible tooltip
                    if (chart_options.tooltip.show === true) tooltip.hide();
                }

                function segment_click(data) {
                    // call on click event
                    chart_options.onClick.apply(vm, [data]);
                }

                function update_tooltip(data) {

                    // get mouse event
                    var mouse_event = d3.event;

                    var mouse_coordinates = {
                        x: mouse_event.clientX,
                        y: mouse_event.clientY
                    };

                    // if tooltips are not enabled then return
                    if (chart_options.tooltip.show === false) return;

                    // get the tooltip text
                    var tooltip_text = chart_options.tooltip.content(data);

                    // if the text is different that the text currently in the tooltip update the text
                    if (tooltip_text !== current_tooltip_text) {

                        // store the new text
                        current_tooltip_text = tooltip_text;

                        // update the html
                        tooltip_inner.html(tooltip_text);

                        // update the stored dimensions
                        tooltip_dimensions.width = tooltip.width();
                        tooltip_dimensions.height = tooltip.height();
                    }

                    // set tooltip position
                    tooltip.css({
                        position: "fixed",
                        top: mouse_coordinates.y - (tooltip_dimensions.height + 10) + chart_options.tooltip.shifts.y,
                        left: mouse_coordinates.x - (tooltip_dimensions.width / 2) + chart_options.tooltip.shifts.x
                    });

                    // make tooltip visible if it is not already
                    tooltip.show();

                }

            }
        };
    }
})();;
(function() {  
  angular.module('hpe.elements.numberPicker', []);
})();
;
(function () {

	angular.module("hpe.elements.numberPicker").directive("numberPicker", numberPicker);

	function numberPicker() {
		return {
			restrict: 'E',
			replace: true,
			require: 'ngModel',
			templateUrl: "numberPicker/template/numberPicker.tmpl.html",
			scope: {
				step: "=?",
				max: "=?",
				min: "=?",
				validate: "=?"
			},
			controller: numberPickerCtrl,
			controllerAs: 'vm',
			link: numberPickerLink
		};
	}

	numberPickerCtrl.$inject = ['$scope'];

	function numberPickerCtrl($scope) {
		var vm = this;

		vm.value = 0;
		vm.validate = {};
		vm.ngModelCtrl = {};

		// define the default values in none provided
		var step = $scope.step ? parseFloat($scope.step) : 1;
		var max = parseFloat($scope.max);
		var min = parseFloat($scope.min);

		// get the number of decimal places the step has
		var decimals = (countDecimals(step) === 0) ? 1 : countDecimals(step);

		// listen for input and then validate the input
		$scope.$watch('vm.value', function (nV) {
			vm.ngModelCtrl.$setViewValue(nV);
			// if custom validation specified, then do it
			if ($scope.validate) {
				var customValidateError = $scope.validate(nV);
				if (customValidateError) {
					invalidAll();
					return;
				}
			}

			validate(nV);
		});

		// if its not a number, or an out of range number then apply the invalid-entry class to the input and the disabled classes to the buttons
		function validate(value, customValidation) {

			vm.validate = customValidation ? vm.validate : {};

			value = (value === "" || isNaN(value)) ? value : parseFloat(value);

			if (value === max || (value + step) > max) {
				vm.validate.upDisabled = true;
				vm.validate.downDisabled = false;
			} else if (value === min || (value - step) < min) {
				vm.validate.downDisabled = true;
				vm.validate.upDisabled = false;
			}

			if (isNaN(value) || value > $scope.max || value < $scope.min || value === "") {
				invalidAll();
			}
		}


		// apply validation to buttons and input field
		function invalidAll() {
			vm.validate.inputError = true;
			vm.validate.upDisabled = true;
			vm.validate.downDisabled = true;
		}

		// trigger upButton click if up key pressed and vice versa
		vm.keyPressed = function (e) {
			if (e.keyCode === 38)
				vm.upClick();
			else if (e.keyCode === 40)
				vm.downClick();
		};

		// increments the input value
		vm.upClick = function () {
			if (vm.validate.upDisabled) return;

			var incrementedValue = parseFloat((parseFloat(vm.value) + parseFloat(step)).toFixed(decimals));
			vm.value = incrementedValue;
		};

		// decrements the input value
		vm.downClick = function () {
			if (vm.validate.downDisabled) return;

			var decrementedValue = parseFloat((parseFloat(vm.value) - parseFloat(step)).toFixed(decimals));
			vm.value = decrementedValue;
		};

		// calculate the how many decimal places the step has. 
		// used to avoid javascript precision problems (where 0.2 + 0.4 = 0.600000000001)
		function countDecimals(value) {
			if (Math.floor(value) !== parseFloat(value))
				return value.toString().split(".")[1].length || 0;
			return 0;
		}

	}


	function numberPickerLink(scope, element, attrs, ngModelCtrl) {
		scope.vm.ngModelCtrl = ngModelCtrl;

		// when model value changes, update input model value
		ngModelCtrl.$render = function () {
			scope.vm.value = ngModelCtrl.$viewValue;
		};
	}

})();;
(function () {
  angular.module("hpe.elements.overflowTooltip", []);
})();;
(function () {
  
  angular.module("hpe.elements.overflowTooltip").directive("overflowTooltip", overflowTooltip);

  function overflowTooltip() {
    return {
      restrict: "A",
      link: function (scope, element) {

        // store the original text
        var originalText = element.text();

        // remember if text is truncated or not
        var textTruncated = false;

        // create ellipsis if required
        element.dotdotdot({
          ellipsis: "â¦",
          wrap: "word",
          fallbackToLetter: true,
          watch: true,
          callback: function (truncated) {

            // only update tooltip if changes have been detected
            if (truncated !== textTruncated) {

              // remember whether or not the text is truncated for next time
              textTruncated = truncated;

              // either create or destroy the tooltip accordingly
              updateTooltip();
            }
          }
        });

        //watch for changes to the content
        var observer = new MutationObserver(function () {

          // get the element text
          var text = element.text();

          // check if it ends in an ellipsis
          var ellipsisIndex = text.lastIndexOf('â¦');

          // if there is no ellipsis then update the original text
          if (text !== originalText && ellipsisIndex === -1) {

            // reset the original text and remember we currently have no truncation
            originalText = text;
            textTruncated = false;

            // update the original content
            element.trigger("rebindText.dot", element);

            // perform truncation
            element.trigger("update.dot");
          }
        });

        // pass in the target node, as well as the observer options
        observer.observe(element.get(0), {
          characterData: true,
          subtree: true,
          childList: true
        });

        scope.$on('$destroy', function () {
          // stop watching for changes
          observer.disconnect();

          // destroy the tooltip
          element.tooltip('destroy');

          // destroy the dotdotdot
          element.trigger('destroy.dot');
        });

        function updateTooltip() {

          // if the text is now truncated then create a tooltip
          if (textTruncated === true) {

            // if a tooltip has already been added to element - destroy its data first
            if (element.data('bs.tooltip') !== null) {
              element.tooltip('hide');
              element.removeData('bs.tooltip');
            }

            // create tooltip
            element.tooltip({
              title: originalText,
              container: 'body'
            });

          } else {
            element.tooltip('destroy');
          }
        }

      }
    };
  }
})();;
(function () {

    angular.module("hpe.elements.overflowTooltip").directive("singleLineOverflowTooltip", singleLineOverflowTooltip);

    singleLineOverflowTooltip.$inject = ['safeTimeout', '$window', '$resize'];

    function singleLineOverflowTooltip(safeTimeout, $window, $resize) {
        return {
            restrict: "A",
            link: function (scope, element) {

                var nativeElement = element.get(0);
                var tooltipReady = false;

                var safeTimeoutInstance = safeTimeout.create(scope);

                //apply next cycle so bound elements will have been processed - updated to use scope safe timeout
                safeTimeoutInstance.timeout(function () {
                    //ensure element has correct styling
                    applyStyles();

                    //initially create a tooltip
                    createTooltip();
                });

                //recheck for overflow after any binding have updated
                updateTooltip();

                // watch for changes to the element size
                $resize.bind(nativeElement, updateTooltip.bind(this));

                //watch for changes to the content
                var observer = new MutationObserver(function () {
                    updateTooltip();
                });

                // pass in the target node, as well as the observer options
                observer.observe(element.get(0), {
                    characterData: true,
                    subtree: true
                });


                //watch for changes to window size
                $window.addEventListener('resize', updateTooltipFn);

                scope.$on('$destroy', function () {
                    element.tooltip('destroy');
                    $window.removeEventListener('resize', updateTooltipFn);
                    $resize.unbind(nativeElement, updateTooltip.bind(this));
                });

                function updateTooltipFn() {
                    updateTooltip();
                }

                function applyStyles() {

                    //this will not work on inline elements - needs to change to inline block
                    var style = $window.getComputedStyle(nativeElement);

                    if (style.display === 'inline') {
                        nativeElement.style.display = 'inline-block';
                    }

                    nativeElement.style.overflow = 'hidden';
                    nativeElement.style.textOverflow = 'ellipsis';
                    nativeElement.style.whiteSpace = 'nowrap';
                }

                function createTooltip() {
                    var text = element.text();

                    element.tooltip({
                        title: text,
                        container: 'body'
                    });

                    tooltipReady = true;
                }

                function updateTooltip() {

                    if (!tooltipReady) return;

                    var scrollWidth = nativeElement.scrollWidth;
                    var width = nativeElement.offsetWidth + 1; //add 1 for weird IE size issue

                    if (scrollWidth > width) {
                        var elementText = element.text();
                        var previousText = nativeElement.getAttribute('data-original-title');

                        if (elementText !== previousText) {
                            nativeElement.setAttribute('data-original-title', elementText);
                        }

                        element.tooltip('enable');
                    } else {
                        element.tooltip('disable');
                    }
                }

            }
        };
    }
})();;
(function () {

  angular.module('hpe.elements.pagetitle', []).directive("pageTitle", ["$rootScope", pageTitle]);

  function pageTitle($rootScope) {
    return {
      link: function (scope, element, attrs) {
        //set title to default;
        var title = attrs.pageTitle;

        var listener = function (event, toState) {
          if (toState.data && toState.data.pageTitle) {
            title = toState.data.pageTitle;
          }

          //title element in head
          element.text(title);

        };
        $rootScope.$on('$stateChangeStart', listener);
      }
    };
  }
})();;
(function () {
  angular.module("hpe.elements.partitionMap", []);
})();
;
(function() {
  
  angular.module("hpe.elements.partitionMap").directive("partitionEditing", ['$window', 'safeInterval', partitionEditing]);

  function partitionEditing($window, safeInterval) {
    return {
      restrict: "E",
      replace: true,
      templateUrl: "partitionMap/template/editTemplate.html",
      link: function(scope, element) {

        var vm = scope.editing = {};

        //globals
        vm.list = element[0].getElementsByClassName('segment-list')[0];
        vm.previousWidth = element.width();
        vm.previousHeight = element.height();

        //set up event listeners
        document.addEventListener("mouseup", endDrag);
        document.addEventListener("mousemove", onDrag);

        scope.$watch('chart.editMode', function(value) {
          //show or hide the edit container accordingly
          if(value === true) show();
          else hide();

        });

        scope.$on('$destroy', destroy);

        safeInterval.create(scope).interval(onResize, 200);

        function onResize() {
          if(scope.chart.editMode === false) return;

          if(element.width() !== vm.previousWidth || element.height() !== vm.previousHeight) {
            resizeSegments();
            vm.previousWidth = element.width();
            vm.previousHeight = element.height();
          }

        }

        vm.done = function() {

          //get sorted groups after dragging and changing
          var output = getSortedGroups();

          //inform the callback if there is one - which there should be
          if(scope.chart.onFinish) scope.chart.onFinish(output);

          //hide the edit mode
          scope.chart.editMode = false;
        };

        function resizeSegments() {
          var numOfRows = scope.chart.maxRows;
          var listHeight = vm.list.offsetHeight;
          vm.rowHeight = Math.ceil(listHeight / numOfRows);

          var segments = getSortedSegments();

          //set the correct height
          for(var i = 0; i < segments.length; i++) {
            segments[i].style.height = vm.rowHeight + 'px';
            segments[i].style.top = (i * vm.rowHeight) + 'px';
          }
        }

        function getSortedGroups() {
          var groups = [];

          var segments = getSortedSegments();

          for(var i = 0; i < segments.length; i++) {
            if(segments[i].getAttribute('group') !== null) groups.push(segments[i].getAttribute('group'));
          }

          return groups;
        }

        function getSortedSegments() {
          var segmentNodes = vm.list.children;

          var segments = [];
          for(var i = 0; i < segmentNodes.length; i++) segments.push(segmentNodes[i]);

          //sort the segments based on top offset
          segments.sort(function(a, b) { return a.offsetTop - b.offsetTop; });

          return segments;
        }


        function destroy() {
          document.removeEventListener("mousemove", onDrag);
          document.removeEventListener("mouseup", endDrag);
        }


        function show() {

          element.show();
          element.addClass('fade-in');

          //store groups excluding the root
          vm.groups = (scope.chart.groups && scope.chart.groups.length > 1) ? scope.chart.groups.slice(1) : [];

          if(vm.groups.length >= scope.chart.maxRows) {
            vm.groups = vm.groups.slice(0, scope.chart.maxRows);
          }

          //update segments
          updateSegments();

        }

        function hide() {
          element.hide();
          element.removeClass('fade-in');
        }

        function updateSegments(previousColors) {

          //calculate number of rows
          var numOfRows = scope.chart.maxRows; // take into account root node which we have no group for

          //ensure we consider at least one row
          if (numOfRows <= 0) numOfRows = 1;

          //calculate height
          var listHeight = vm.list.offsetHeight;
          vm.rowHeight = Math.ceil(listHeight / numOfRows);

          //remove old segments
          while (vm.list.firstChild) vm.list.removeChild(vm.list.firstChild);

          //loop through each group and add the segment
          for (var sgmt = 0; sgmt < Math.min(vm.groups.length, numOfRows); sgmt += 1) {

            var color = null;

            if(previousColors) {
              for(var i = 0; i < previousColors.length; i++) {
                if(previousColors[i].item === vm.groups[sgmt]) {
                  color = previousColors[i].color;
                  break;
                }
              }
            }

            if(!color) color = getColor(sgmt);

            var segment = createSegment(vm.groups[sgmt], color, sgmt);
            vm.list.appendChild(segment);
          }

          //if not all rows occupied then add a selection segment
          if (vm.groups.length < numOfRows) createSelectionSegment();
        }

        function getColor(index) {
          var newIndex = index % scope.chart.colors.length;
          var subIndex = Math.floor(index / scope.chart.colors.length);

          if(subIndex > scope.chart.colors[newIndex].length) subIndex -= scope.chart.colors[newIndex].length;

          return scope.chart.colors[newIndex][subIndex];
        }

        function createSegment(text, color, index) {

          //create elements
          var segment = document.createElement('li');

          var groupText = document.createElement('span');
          var groupIcon = document.createElement('span');
          var groupLabel = document.createElement('p');

          var dragBox = document.createElement('div');
          var dragIcon = document.createElement('div');
          var moveUpIcon = document.createElement('div');
          var moveDownIcon = document.createElement('div');
          var closeBox = document.createElement('div');
          var closeIcon = document.createElement('div');

          //set the classes
          segment.className = "segment";
          groupIcon.className = "hpe-icon hpe-down icon";
          groupLabel.className = "group-label";
          groupText.className = "group-name";
          dragBox.className = "drag-box";
          dragIcon.className = "icon";
          moveUpIcon.className = "up-icon";
          moveDownIcon.className = "down-icon";
          closeBox.className = "close-box";
          closeIcon.className = "icon";

          //set attributes
          segment.setAttribute("group", text);

          //set value
          groupText.innerHTML = text;

          //set calculated size and position
          segment.style.height = vm.rowHeight + 'px';
          segment.style.top = (vm.rowHeight * index) + 'px';

          //add event handlers
          moveUpIcon.addEventListener("click", arrowUp);
          moveDownIcon.addEventListener("click", arrowDown);
          dragIcon.addEventListener("mousedown", beginDrag);
          closeIcon.addEventListener("click", removeSegment);
          groupIcon.addEventListener("click", showDropdown);

          //nest elements
          if(vm.groups.length > scope.chart.minRows) 
            closeBox.appendChild(closeIcon);

          dragBox.appendChild(moveUpIcon);
          dragBox.appendChild(dragIcon);
          dragBox.appendChild(moveDownIcon);
          segment.appendChild(dragBox);
          segment.appendChild(closeBox);

          groupLabel.appendChild(groupText);
          groupLabel.appendChild(groupIcon);
          segment.appendChild(groupLabel);
          segment.appendChild(createDropdown());

          //set color
          segment.style.backgroundColor = color;

          //return element
          return segment;
        }

        function createDropdown() {
          //create the dropdown list element
          var dropdown = document.createElement('ul');

          //set dropdown class
          dropdown.className = "dropdown-menu";

          return dropdown;
        }

        function createSelectionSegment() {

          //create elements
          var segment = document.createElement('li');
          var icon = document.createElement('span');
          var text = document.createElement('span');
          var label = document.createElement('p');

          //set classes
          segment.className = "selection-segment";
          icon.className = "hpe-icon hpe-down icon";
          label.className = "selection-label";

          //set values
          text.innerHTML = "Select";

          //set position
          segment.style.top = (Math.min(vm.groups.length, scope.chart.maxRows) * vm.rowHeight) + 'px';
          segment.style.height = vm.rowHeight + 'px';

          //add click event to show dropdown
          icon.addEventListener("click", function(evt) { showDropdown(evt, true); });

          label.appendChild(text);
          label.appendChild(icon);
          segment.appendChild(label);
          segment.appendChild(createDropdown());
          vm.list.appendChild(segment);

        }

        function calculateHoveredRow(evt) {
          //get the position of the container element
          var containerY = vm.list.getBoundingClientRect().top;

          //get mouse position
          var mouseY = evt.clientY;

          //calculate difference
          var offsetY = mouseY - containerY;

          if (offsetY <= 0) return 0;

          //get number of rows
          var numberOfRows = Math.ceil(vm.list.offsetHeight / vm.rowHeight);

          if (offsetY > vm.list.getBoundingClientRect().bottom) return numberOfRows - 1;

          //get row mouse is over
          var row = Math.floor(offsetY / vm.rowHeight);

          //ensure calculated row exists
          if (row > (numberOfRows - 1)) return numberOfRows - 1;

          return row;
        }

        function arrowUp(evt) {
          var row = calculateHoveredRow(evt);

          //if it is already at the top then we shouldnt be doing anything
          if (row === 0) return;

          //get target element
          var dragBox = evt.target.parentNode;

          //get segment
          var segment = dragBox.parentElement;

          vm.selectedSegment = segment;

          //move segment to the correct position
          moveSegment(row - 1, function() {
            //when finished animating update the colours
            updateColors();
          });

        }

        function arrowDown(evt) {
          var row = calculateHoveredRow(evt);

          //if it is already at the bottom then we shouldnt be doing anything
          if (row === (vm.groups.length - 1)) return;

          //get target element
          var dragBox = evt.target.parentNode;

          //get segment
          var segment = dragBox.parentElement;

          vm.selectedSegment = segment;

          //move segment to the correct position
          moveSegment(row + 1, function() {
            //when finished animating update the colours
            updateColors();
          });
        }

        function beginDrag(evt) {

          //ensure that it is mouse button 1 only
          if (evt.button !== 0) return;

          //ensure we hide any dropdowns
          hideAllDropdowns();

          //get target element
          var dragBox = evt.target.parentNode;

          //get segment
          var segment = dragBox.parentElement;

          //set segment class
          segment.className = "segment dragging";

          //ensure event is handled correctly
          evt.preventDefault();

          //remember we are dragging
          vm.dragging = true;

          //remember the initial position in list and segment element
          vm.initialPosition = calculateHoveredRow(evt);
          vm.selectedSegment = segment;
        }

        function onDrag(evt) {
          //if we are not dragging then we dont do anything
          if (!vm.dragging) return;

          var row = calculateHoveredRow(evt);

          //if the current position is not the initialPosition then we need to reorder
          if (row !== vm.initialPosition) {

            //move segment to the correct position
            moveSegment(row);

            //update position
            vm.initialPosition = row;
          }
        }

        function endDrag() {

          //get segment
          var segment = vm.list.getElementsByClassName('dragging')[0];

          //remove dragging class
          if (segment) segment.className = "segment";

          updateColors();

          vm.dragging = false;

          vm.groups = getSortedGroups();
        }

        function showDropdown(evt, selection) {
          //determine element heirarchy
          var icon = evt.target;
          var label = icon.parentNode;
          var segment = label.parentNode;

          //Hide all dropdowns
          hideAllDropdowns();

          var dropdowns = segment.getElementsByClassName('dropdown-menu');

          //if no dropdown menu has been found then don't do anything
          if(dropdowns.length === 0) return;

          //get the dropdown element
          var dropdown = dropdowns[0];

          //update dropdown items
          updateDropdown(dropdown, selection);

          dropdown.style.display = 'block';
          dropdown.style.top = 'calc(50% + 10px)';
          dropdown.style.left = 'calc(50% - ' + (dropdown.offsetWidth / 2) + 'px)';
          dropdown.className = "dropdown-menu show-groups";

          //we need to detect clicks inside and out of the dropdown
          var removeDropdown = function() {
            dropdown.className = "dropdown-menu";
            dropdown.style.display = 'none';
            document.removeEventListener('click', removeDropdown);
          };

          //stop event propagation
          evt.stopPropagation();

          document.addEventListener('click', removeDropdown);
        }

        function updateDropdown(dropdown, selection) {

          //find the groups that havent been selected
          var unselectedItems = [];

          for(var i = 0; i < scope.chart.availableGroups.length; i++) {
            if(vm.groups.indexOf(scope.chart.availableGroups[i]) === - 1) {
              unselectedItems.push(scope.chart.availableGroups[i]);
            }
          }

          //remove all child elements from the dropdown
          while(dropdown.firstChild) dropdown.removeChild(dropdown.firstChild);

          //if no items are available inform the user
          if(unselectedItems.length === 0) {
            var noItemsLink = document.createElement('a');
            var noItemsGroup = document.createElement('li');

            //set the link text and href
            noItemsLink.innerHTML = scope.chart.noGroupsText;

            noItemsGroup.className = 'disabled';

            //add link to group and group to dropdown
            noItemsGroup.appendChild(noItemsLink);
            dropdown.appendChild(noItemsGroup);
          }

          //function called when a dropdown item is selected
          var dropdownSelect = function(evt) {
            //get the attribute required
            var dropdownItem = evt.target;
            var group = dropdownItem.getAttribute('select-group');

            if(selection && selection === true) {
              addGroup(group);
              return;
            }

            //get elements
            var segment = dropdown.parentNode;
            var segmentGroup = segment.getAttribute('group');
            var segmentLabels = segment.getElementsByClassName('group-name');

            if(segmentLabels.length === 0) return;

            //get the label element
            var segmentLabel = segmentLabels[0];

            //replace item in array
            var index = vm.groups.indexOf(segmentGroup);
            vm.groups[index] = group;

            //now replace the label text and the attribute
            segmentLabel.innerHTML = group;
            segment.setAttribute('group', group);
          };

          //add a li to the dropdown for each group
          for(i = 0; i < unselectedItems.length; i++) {

            //create list element
            var link = document.createElement('a');
            var group = document.createElement('li');

            //set the link text and href
            link.innerHTML = unselectedItems[i];
            link.setAttribute('select-group', unselectedItems[i]);
            link.addEventListener('click', dropdownSelect);

            //add link to group and group to dropdown
            group.appendChild(link);
            dropdown.appendChild(group);
          }
        }

        function hideAllDropdowns() {
          $(element[0]).find('.dropdown-menu').removeClass('show-groups').hide();
        }

        function addGroup(group) {
          vm.groups.push(group);
          updateSegments();
        }

        function updateColors() {
          var segments = getSortedSegments();

          for(var i = 0; i < segments.length; i++) {
            if(segments[i].className === 'selection-segment') continue;

             segments[i].style.backgroundColor = getColor(i);
          }
        }

        function moveSegment(position, callback) {
          //find segments
          var segments = vm.list.getElementsByClassName('segment');

          //remove selected segment from list
          var unselected = [];

          for (var sgmt = 0; sgmt < segments.length; sgmt++) {
            //if the segment is not selected then push it
            if (segments[sgmt] !== vm.selectedSegment) unselected.push(segments[sgmt]);
          }

          //sort the unselected segments based on top position
          unselected.sort(function(a, b) {
            return a.offsetTop - b.offsetTop;
          });

          //insert selected at specified position
          var sorted = [],
            idx = 0;

          for (sgmt = 0; sgmt < segments.length; sgmt++) {
            if (sgmt === position) sorted.push(vm.selectedSegment);
            else {
              sorted.push(unselected[idx]);
              idx++;
            }
          }

          vm.groups = getSortedGroups();

          //recalculate positions based on new order
          for (sgmt = 0; sgmt < segments.length; sgmt++) {
            var segment = sorted[sgmt];

            $(segment).animate({
              top: vm.rowHeight * sgmt
            }, {
              duration: 100,
              queue: false,
              complete: callback
            });
          }
        }

        function removeSegment(evt) {
          var target = evt.target;
          var closeBox = target.parentNode;
          var segment = closeBox.parentNode;

          var group = segment.getAttribute("group");

          //remove group
          var idx = vm.groups.indexOf(group);

          //if not found do nothing
          if(idx === -1) return;

          vm.groups.splice(idx, 1);

          var segments = getSortedSegments();

          var colors = [];

          for(var i = 0; i < segments.length; i++) {
            var sgmt = segments[i];

            //dont do this for selection segment
            if(sgmt.className === 'selection-segment') continue;

            var name = sgmt.getElementsByClassName('group-name')[0].innerHTML;
            var color = sgmt.style.backgroundColor;

            colors.push({ item: name, color: color });
          }

          updateSegments(colors);

          setTimeout(updateColors, 170);
        }

      }
    };
  }
})();
;
(function() {
  
  angular.module("hpe.elements.partitionMap").directive("partitionMap", partitionMap);

  partitionMap.$inject = ['d3PartitionMap'];

  function partitionMap(d3PartitionMap) {
    return {
      restrict: "E",
      scope: {
        chartData: '=',
        chartOptions: '=?',
        chartLoading: '=?'
      },
      templateUrl: "partitionMap/template/partitionMap.html",
      link: function(scope, element) {
        var vm = scope;

        //find chrt container element
        var chartContainer = element.find('div.partition-map');

        //remove any graphics previously drawn in container
        chartContainer.find('svg').remove();

        //if no options are set instantiate an empty object
        var options = vm.chartOptions ? vm.chartOptions : {};

        //initialise chart
        vm.chart = d3PartitionMap.getChart(chartContainer, scope)
          .init(options);

        //if should show loading overlay do it now
        if (vm.chartLoading) {
          vm.chart.setLoading(vm.chartLoading);
        }

        //if we have some data then draw
        if (vm.chartData) {
          vm.chart.draw(angular.copy(vm.chartData));
        }

        //when data source changes update the chart to reflect the new data
        scope.$watch('chartData', function(newData, oldData) {
          if(newData !== oldData) {
            vm.chart.updateData(newData);
          }
        });

        //when loading state changes update the chart to show or hide loading overlay
        scope.$watch('chartLoading', function(newData, oldData) {
          if(newData !== oldData) {
            vm.chart.setLoading(newData);
          }
        });

        //on destroy we should cleanup
        scope.$on("$destroy", function() {
          vm.chart.destroy();
        });
      }

    };
  }

})();
;
(function () {
  
  angular.module("hpe.elements.partitionMap").factory('d3PartitionMap', d3PartitionMap);

  d3PartitionMap.$inject = ['d3', '$rootScope', '$compile', '$templateRequest', '$timeout'];

  function d3PartitionMap(d3, $rootScope, $compile, $templateRequest, $timeout) {

    var service = {
      getChart: getChart
    };

    return service;

    function getChart($container, $scope) {
      return new PartitionMap($container, $scope, $rootScope, $compile, $templateRequest, $timeout);
    }
  }

  //used to maintain scope
  var chart;

  function PartitionMap($container, $scope, $rootScope, $compile, $templateRequest, $timeout) {
    chart = this;

    //angular
    this.scope = $scope;
    this.rootScope = $rootScope;
    this.compile = $compile;
    this.timeout = $timeout;
    this.templateRequest = $templateRequest;

    // element properties
    this.container = $container;
    this.element = $container[0];
    this.parent = this.element.parentElement;
    this.top = 0;
    this.left = 0;
    this.width = this.element.clientWidth;
    this.height = this.element.clientHeight;
    this.x = d3.scale.linear().range([0, this.width]);
    this.y = d3.scale.linear().range([0, this.height]);
    this.currentDepth = 0;

    //global properties
    this.hoverTimeout = null;
    this.hoverDuration = 650;
    this.hoverLeaveTimeout = null;
    this.hoverLeaveDuration = 250;
    this.isDrawing = false;
    this.isAnimating = false;
    this.isRedrawing = false;
    this.isTransitioning = false;
    this.hoveredElement = null;
    this.noData = true;
    this.calloutVisible = true;

    this.mouseX = 0;
    this.mouseY = 0;

    //find maximize container if one exists
    var container = document.getElementsByClassName("partition-container");
    this.maximizedContainer = container.length !== 0 ? container[0] : null;
    this.isMaximized = false;
    this.allowMaximize = this.maximizedContainer !== null;
    this.scrollLocationX = 0;
    this.scrollLocationY = 0;
    this.hasDrawn = false;
    this.calloutTimout = null;
    this.popoverShowTimeout = null;

    //popover
    this.popoverVisible = false;
    this.popoverElement = null;
    this.popoverItem = null;
    this.popoverTemplate = null;

    //docked popover
    this.dockedPopover = null;
    this.dockedUserContent = null;
    this.dockedPopoverItem = null;
    this.selectedItem = null;

    //check if partition map is inside a modal
    var modalParent = angular.element(this.parent).parents('.modal-content');
    this.modalChart = modalParent.length === 1;

    this.rootColor = '#60798d';
    //colors
    this.colors = [
      ['#425563', '#877b75', '#614767', '#617d78', '#565672', '#878787', '#724f5d', '#6b7559', '#32404b', '#665d58', '#49354e', '#495e5a', '#414156', '#666666', '#563b46', '#515843'],
      ['#1c899a', '#18a6df', '#98c972', '#839de8', '#839b9d', '#126aa5', '#77c0d1', '#605e89', '#7fa4bb', '#60798d', '#2fbea3', '#10777f', '#9fc6ee', '#7f7fd7', '#74a265', '#c7e0b4'],
      ['#e7a263', '#ecd491', '#97579a', '#c19fd3', '#989856', '#c7cc87', '#d775a4', '#cabfbd', '#9d8583', '#e5a3c7', '#e57b76', '#e0b852', '#b17f77', '#eebcba', '#d58853', '#d0c655'],
      ['#7fa4bb', '#60798d', '#2fbea3', '#10777f', '#9fc6ee', '#7f7fd7', '#74a265', '#c7e0b4', '#1c899a', '#18a6df', '#98c972', '#839de8', '#839b9d', '#126aa5', '#77c0d1', '#605e89'],
    ];

    this.usedColors = [];

    //editing
    this.editMode = false;
    this.groups = [];

    //editor options
    this.editorEnabled = false;
    this.finishText = 'Done';
    this.noGroupsText = 'No groups available';
    this.availableGroups = [];
    this.maxRows = 3;
    this.minRows = 0;
    this.onFinish = null;

    //options
    this.edit = null;
    this.onSelect = null;
    this.popoverEnabled = true;
    this.valueFormatter = function (v) {
      return v;
    };
    this.noDataLabel = null;
    this.isLoading = false;

    //maximize/minimize button
    this.buttonOffset = null;
    this.toggleButton = this.parent.getElementsByClassName('partition-expand')[0];
    this.toggleButtonDefault = {
      minimize: {
        x: -20,
        y: -20
      },
      maximize: {
        x: 25,
        y: -20
      }
    };

    //data
    this.data = null;
    this.originalData = null;
    this.childList = [];
    this.dockedChildList = [];

    //offset
    this.previousLeftOffset = 0;
    this.previousTopOffset = 0;

    // document width (allows monitoring of width without resizing, i.e. appearance of scrollbars)
    this.previousDocumentWidth = 0;

    //bindings
    window.addEventListener("resize", this.redraw);
    document.addEventListener("mousemove", this.checkPopover);
    document.addEventListener('mousedown', this.handleWheelClick, false);

    //this is required because other elements can change on screen eg. side bar and the chart will not get resized even though it should
    this.resizeInterval = setInterval(function () {
      if (chart.isMaximized && chart.maximizeOptions.shouldResize === true) {
        if (chart.maximizedContainer.offsetLeft !== chart.previousLeftOffset ||
          chart.maximizedContainer.offsetTop !== chart.previousTopOffset ||
          chart.element.offsetWidth !== chart.width ||
          document.documentElement.clientWidth !== chart.previousDocumentWidth) {
          chart.redraw();
        }
      } else {
        if (chart.element.offsetWidth !== chart.width) chart.redraw();
      }
    }, 200);
  }

  // store any settings we are given
  PartitionMap.prototype.init = function (options) {
    this.edit = options.edit;
    this.onSelect = options.select;
    this.popoverEnabled = options.popoverEnabled !== null && options.popoverEnabled !== undefined ? options.popoverEnabled : true;
    this.noDataLabel = options.noDataLabel !== null ? options.noDataLabel : 'No data to display';
    this.loadingLabel = options.loadingLabel !== null ? options.loadingLabel : 'Loading';
    this.buttonOffset = options.buttonOffset ? options.buttonOffset : {
      minimize: {
        x: 0,
        y: 0
      },
      maximize: {
        x: 0,
        y: 0
      }
    };
    this.hoverDuration = options.popoverDelay ? options.popoverDelay : 650;

    //editor options
    if (options.edit && options.edit.editor) {
      this.editorEnabled = this.valueOrDefault(options.edit.editor.enabled, false);
      this.finishText = this.valueOrDefault(options.edit.editor.finishText, 'Done');
      this.noGroupsText = this.valueOrDefault(options.edit.editor.noGroupsText, 'No groups available');
      this.availableGroups = this.valueOrDefault(options.edit.editor.availableGroups, []);
      this.maxRows = this.valueOrDefault(options.edit.editor.maxRows, 3);
      this.minRows = this.valueOrDefault(options.edit.editor.minRows, 0);
      this.onFinish = this.valueOrDefault(options.edit.editor.onFinish, null);

      //ensure max rows is 3 or less
      if (this.maxRows < 0) {
        console.log('Partition Map - Max rows must be a positive number');
        this.maxRows = 3;
      }
      if (this.maxRows > 3) {
        console.log('Partition Map - Maximimum number of rows is 3');
        this.maxRows = 3;
      }
    }

    if (options.valueFormatter)
      this.valueFormatter = options.valueFormatter;

    //get docked popover container
    this.dockedPopover = this.parent.getElementsByClassName('partition-docked-popover')[0];
    this.dockedUserContent = this.dockedPopover.getElementsByClassName('user-content')[0];

    //if a template has been specified then load the template
    if (options.popoverTemplate) {

      chart.templatePromise = chart.templateRequest(options.popoverTemplate);
      //after request set data
      chart.templatePromise.then(function (template) {
        chart.popoverTemplate = template;
      });
    } else {
      this.popoverEnabled = false;
    }

    //set up maximize options
    if (options.maximize) {
      this.maximizeOptions = {
        disableScrolling: this.valueOrDefault(options.maximize.disableScrolling, false),
        buttonVisible: this.valueOrDefault(options.maximize.buttonVisible, true),
        isMaximized: this.valueOrDefault(options.maximize.isMaximized, false),
        fillScreen: this.valueOrDefault(options.maximize.fillScreen, false),
        onToggle: this.valueOrDefault(options.maximize.onToggle, null),
        sidePanelWidth: this.valueOrDefault(options.maximize.sidePanelWidth, 235),
        shouldResize: this.valueOrDefault(options.maximize.shouldResize, true)
      };
    } else {
      this.maximizeOptions = {
        disableScrolling: false,
        buttonVisible: true,
        isMaximized: false,
        fillScreen: false,
        onToggle: null,
        sidePanelWidth: 235,
        shouldResize: true
      };
    }

    this.processOptions();

    //position toggle button
    this.positionToggleButton();

    return chart;
  };

  PartitionMap.prototype.processOptions = function () {
    //process the maximize options

    //allow maximize might already be disabled if no container was specified - take this into account
    chart.allowMaximize = chart.allowMaximize && chart.maximizeOptions.buttonVisible || chart.maximizeOptions.buttonVisible && chart.maximizeOptions.shouldResize === false;
  };

  // when the object is no longer on screen we should remove any bindings
  PartitionMap.prototype.destroy = function () {

    //stop partition sizing interval
    clearInterval(chart.resizeInterval);

    //clear any timeouts - prevents errors when leaving the page
    clearTimeout(chart.hoverTimeout);
    clearTimeout(chart.hoverLeaveTimeout);
    clearTimeout(chart.calloutTimout);
    clearTimeout(chart.popoverShowTimeout);

    //ensure we enable scrollbars if they have been disabled
    if (chart.isMaximized) {
      document.getElementsByTagName("html")[0].style.overflow = '';
    }

    window.removeEventListener("resize", this.redraw);
    document.removeEventListener("mousemove", this.checkPopover);
    document.removeEventListener("mousedown", this.handleWheelClick);
  };

  PartitionMap.prototype.updateData = function (data) {
    chart.originalData = null;
    chart.usedColors = [];

    //reset the data in popover
    chart.popoverItem = null;
    chart.selectedItem = null;
    chart.currentDepth = 0;

    chart.redraw(data, function () {
      //reset selected segment to root node once redraw has completed
      if (chart.segments.length > 0) {
        var rootData = d3.select(chart.segments[0][0]).data()[0];
        if (rootData) chart.selectSegment(rootData);
      }
    });
  };

  // Draw our chart
  PartitionMap.prototype.draw = function (data) {
    if (!chart.originalData) {
      chart.originalData = data;
      chart.data = chart.processData(data);
    }

    //if we have no data then dont draw anything
    if (chart.noData) return;

    chart.isDrawing = true;

    //create our svg object to draw in
    var partitionMap = d3.select(chart.element).append("svg:svg")
      .attr("width", chart.width)
      .attr("height", chart.height);

    // create our partition layout
    var partition = d3.layout.partition()
      .children(function (data) {
        return isNaN(data.value) ? d3.entries(data.value) : null;
      })
      .value(function (data) {
        return data.value;
      });

    // create a graphics grouping for each node in the JSON
    var g = partitionMap.selectAll("g")
      .data(partition(d3.entries(chart.data)[0]))
      .enter().append("svg:g");

    //for each node draw a rectangle and fill it will a color matching its key
    chart.segments = g.append("svg:rect")
      .attr('stroke', '#000')
      .attr('stroke-width', '0.5')
      .attr('stroke-opacity', '0.2')
      .attr("x", function (data) {
        return chart.x(chart.calculateX(data));
      })
      .attr("y", function (data) {
        return chart.y(data.y);
      })
      .attr("width", function (data) {
        return chart.x(chart.calculateWidth(data));
      })
      .attr("height", function (data) {
        return chart.y(data.dy);
      })
      .attr("fill", function (data) {
        if (data.key === '__zero__') {
          data.color = '#ffffff';
          return data.color;
        }
        data.color = chart.segmentColor(data);
        return data.color;
      })
      .on("click", chart.selectSegment)
      .on('mouseover', chart.onSegmentHover)
      .on('mouseout', chart.onSegmentLeave);

    //add text to each grouping with the text to be displayed on each rectangle
    chart.segmentLabels = g.append("svg:text")
      .style('fill', 'white')
      .style('font-family', 'Metric')
      .style('opacity', '1')
      .style("text-anchor", "middle")
      .style("cursor", "default")
      .append('tspan').text(function (data) {
        return data.key;
      }).each(chart.wrap)
      .attr("x", function (data) {
        return chart.x(chart.calculateX(data)) + chart.x(chart.calculateWidth(data) / 2);
      })
      .attr("y", function (data) {

        var detailedData = chart.getDetailedDataFromData(data);

        //if there is no icon then center the label vertically
        if (!detailedData.image) {
          var labelHeight = this.getBoundingClientRect().height;
          return chart.y(data.y) + (chart.y(data.dy) / 2) + (labelHeight / 2) - 5;
        }

        return chart.y(data.y) + ((chart.y(data.dy) / 12) * 8);
      })
      .attr("width", function (data) {
        return chart.x(chart.calculateWidth(data));
      })
      .attr("height", function (data) {
        return chart.y(data.dy);
      })
      .attr('opacity', function (data) {
        return chart.x(chart.calculateWidth(data)) <= 10 || chart.y(data.dy) < 25 ? 0 : 1;
      });


    chart.segmentImages = g.append("svg:image")
      .attr('xlink:href', function (data) {
        var detailedData = chart.getDetailedDataFromData(data);
        return detailedData.image ? detailedData.image : "";
      })
      .attr("preserveAspectRatio", "xMidYMax meet")
      .attr("x", function (data) {
        return (chart.x(chart.calculateX(data)) + chart.x(chart.calculateWidth(data) / 2)) - 10;
      })
      .attr("y", function (data) {
        return chart.y(data.y) + (((chart.y(data.dy) / 12)) * 8) - 45;
      })
      .attr("width", 20)
      .attr("height", 20)
      .attr("opacity", function (data) {
        var detailedData = chart.getDetailedDataFromData(data);
        if (!detailedData.image) return 0;

        var chartYPos = chart.y(data.y) + 10;
        var iconYPos = chart.y(data.y) + (((chart.y(data.dy) / 12)) * 8) - 45;
        return iconYPos < chartYPos ? 0 : 1;
      });

    //we we have an edit action specified then add it to the chart
    if (chart.edit) {
      var rootGroup = g[0][0];

      chart.editBlock = d3.select(rootGroup).append("svg:rect")
        .style('opacity', '0.2')
        .attr("x", 0)
        .attr("y", 0)
        .attr("width", 64)
        .attr("height", function (data) {
          return chart.y(data.dy);
        })
        .on("click", function (data) {
          //if the root is selected and we have an edit action then perform it
          if (data.depth >= chart.currentDepth && chart.edit.click) {
            //perform edit action
            chart.edit.click(chart.getDetailedDataFromData(data));

            //show edit container and allow editing
            if (chart.editorEnabled) chart.beginEditing();

          } else if (data.depth < chart.currentDepth) {
            //if we are on a lower depth then propagate the click action
            chart.selectSegment(data, 0);
          }
        })
        .on("mouseover", function (data) {
          //only perform these functions if root node is selected
          if (data.depth >= chart.currentDepth) {
            d3.select(this)
              .style('opacity', '0.3')
              .style('cursor', 'pointer');
            chart.hidePopover();
          }
        })
        .on("mouseout", function (data) {
          //only perform this if the root node is selected
          if (data.depth >= chart.currentDepth) {
            d3.select(this)
              .style('opacity', '0.2')
              .style('cursor', 'default');
          }
        });

      chart.editText = d3.select(rootGroup).append("svg:text")
        .style('fill', 'white')
        .style('font-family', 'Metric')
        .style('opacity', '1')
        .style("text-anchor", "middle")
        .style("cursor", "default")
        .attr("x", 32)
        .attr("y", function (data) {
          return (chart.y(data.dy) / 12) * 8;
        })
        .attr("width", 32)
        .text(chart.edit.text)
        .each(chart.wrapEditText);

      chart.editImage = d3.select(rootGroup).append("svg:image")
        .attr('xlink:href', chart.edit.image)
        .attr("preserveAspectRatio", "xMidYMax meet")
        .attr("x", 0)
        .attr("y", function (data) {
          return ((chart.y(data.dy) / 12) * 8) - 40;
        })
        .attr("width", 64)
        .attr("height", 15)
        .attr("opacity", function (data) {
          if (!chart.edit || !chart.edit.image) return 0;
          var chartYPos = chart.y(data.y) + 15;
          var iconYPos = chart.y(data.y) + (((chart.y(data.dy) / 12)) * 8) - 40;
          return iconYPos < chartYPos ? 0 : 1;
        });
    }

    //once drawn we should call the select function giving them the root element
    if (chart.onSelect) {
      var segmentElement = d3.select(chart.element).selectAll("g")[0][0];
      var selectData = chart.getDetailedDataFromData(data);

      if (Object.prototype.toString.call(selectData) === '[object Array]' && selectData.length > 0) {
        selectData = selectData[0];
      }

      selectData.parents = chart.getParentsData(data);
      chart.onSelect(selectData, segmentElement);
    }

    //calculate the max depth
    var maxDepth = chart.calculateDepth(chart.getSegmentData(0));

    //get callout
    var callout = document.getElementsByClassName('callout')[0];

    if (callout) {
      //if there are going to be more than 4 rows then we need to hide the callout as it will cause alignment troubles
      chart.calloutVisible = maxDepth <= 3 && chart.height / (maxDepth + 1) >= 145;
      callout.style.display = chart.calloutVisible ? 'block' : 'none';
      callout.style.borderLeftColor = chart.rootColor;

    }

    //after the chart has first been rendered we need to take into account some settings that couldnt be processed before rendering
    if (!chart.hasDrawn) {

      if (chart.maximizeOptions.isMaximized) {
        chart.maximize();
      }

      //give page a chance to render
      setTimeout(function () {
        chart.selectedItem = chart.getSegmentData(0);

        // the template may not have loaded yet - perform update when it has
        if (!chart.popoverTemplate && chart.templatePromise) {
          chart.templatePromise.then(function () {
            chart.updateDockedPopover(chart.selectedItem);
          });
        } else {
          //we also want to re-render the user content in the docked popover
          chart.updateDockedPopover(chart.selectedItem);
        }

        //required to update docked popover list
        chart.apply();

        chart.hasDrawn = true;
      }, 1);
    }

    setTimeout(function () {
      chart.isTransitioning = false;
      chart.isDrawing = false;
    }, 1);

    return chart;
  };

  PartitionMap.prototype.beginEditing = function () {
    var chart = this;

    //get the group names to display
    chart.groups = chart.getGroupNames();
    // chart.groups = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight'];
    chart.editMode = true;

    chart.apply();

  };

  PartitionMap.prototype.getGroupNames = function () {
    var chart = this;

    //get data and root node
    var data = chart.originalData;
    var rootNode = data.length > 0 ? data[0] : null;

    //if there is no data return empty array
    if (!rootNode) return [];

    //initial data
    var nodeGroups = [];

    //level count
    var maxLevel = 0;

    //traverse nodes storing group names
    var nodeTraverse = function (node, level) {

      //if there is no node then we cannot do anything
      if (!node) return;

      //if level is higher than known max level then store
      if (level > maxLevel) maxLevel = level;

      //if there is a group name, store it along with the level
      if (node.groupName) {
        nodeGroups.push({
          groupName: node.groupName,
          level: level
        });
      }

      //if there are children then traverse!
      if (node.children)
        for (var i = 0; i < node.children.length; i++) nodeTraverse(node.children[i], level + 1);
    };

    //traverse the nodes
    nodeTraverse(rootNode, 0);

    //if no groups return
    if (maxLevel === 0) return [];

    //actual groups
    var groups = [];

    //consolodate all the duplicates
    for (var lvl = 0; lvl <= maxLevel; lvl++) {

      //store any found group
      var group = null;

      for (var i = 0; i < nodeGroups.length; i++) {

        //get node group information
        var level = nodeGroups[i].level;

        //try and find the corresponding group
        if (level === lvl) {
          group = nodeGroups[i].groupName;
          break;
        }
      }

      //if we have a group then push otherwise we must stop!
      if (group !== null) groups.push(group);
      else break;
    }

    return groups;
  };

  // when a rectangle is clicked we want to start zoom in or out animation
  PartitionMap.prototype.selectSegment = function (data, elementIndex, popoverAction) {
    //if user has specified a select function call it!
    if (chart.onSelect) {
      var segmentElement = d3.select(chart.element).selectAll("g")[0][elementIndex];
      var selectData = chart.getDetailedDataFromData(data);
      selectData.parents = chart.getParentsData(data);
      chart.onSelect(selectData, segmentElement);
    }

    //set our initial hovered element
    chart.hoveredElement = elementIndex;

    //hide any popovers
    chart.hidePopover();

    //if we click on the selected node again - bring us back up to its parent if possible
    //popover action will only be true when selecting child from popover - if this is the case dont perform this action
    if (!popoverAction && data.depth === chart.currentDepth && data.parent && !chart.isRedrawing) {

      //ensure the node clicked is the same node as the current one
      if (chart.selectedItem.key === data.key && chart.selectedItem.x === data.x) {

        //calculate parent element index
        var parentIndex = chart.getElementIndex(data.parent);

        //simulate parent click event
        chart.selectSegment(data.parent, parentIndex);
        return;
      }
    }

    //if selected item is zero or has no value then do nothing
    if (data.key === '__zero__' || data.value === 0) return;

    var selectedData = data;

    var collapsedRowHeight = function () {
      return 35;
    };

    var newDepth = data.depth;
    var topOffset = data.y ? collapsedRowHeight() * data.depth : 0;

    //set our new ranges
    chart.x.domain([chart.calculateX(data), chart.calculateX(data) + chart.calculateWidth(data)]);
    chart.y.domain([data.y, 1]).range([topOffset, chart.height]);

    //calculate animation durations
    var animationDuration = chart.isRedrawing ? 0 : 500;

    // begin transition of rectangles
    chart.segments.transition()
      .duration(animationDuration)
      .attr("x", function (data) {
        return chart.x(chart.calculateX(data));
      })
      .attr("y", function (data) {
        if (data.depth < newDepth) {
          return data.depth * collapsedRowHeight();
        }
        return chart.y(data.y);
      })
      .attr("width", function (data) {
        return chart.x(chart.calculateX(data) + chart.calculateWidth(data)) - chart.x(chart.calculateX(data));
      })
      .attr("height", function (data) {
        if (data.depth < newDepth) {
          return collapsedRowHeight();
        }
        return chart.y(data.y + data.dy) - chart.y(data.y);
      })
      .each('start', function () {
        chart.isAnimating = true;
        clearTimeout(chart.hoverTimeout);
      })
      .each('end', function () {
        if (chart.isAnimating) {
          chart.isAnimating = false;
          chart.onSegmentHover(null, null);
        }
      });

    //begin transition of text - then recalculate ellipsis
    chart.segmentLabels.transition()
      .duration(animationDuration)
      .attr("x", function (data) {
        if (data.depth < newDepth) {
          if (chart.isParentOf(data, selectedData)) {
            return chart.x(chart.calculateX(selectedData)) + ((chart.x(chart.calculateX(selectedData) + chart.calculateWidth(selectedData)) - chart.x(chart.calculateX(selectedData))) / 2);
          }
        }

        return chart.x(chart.calculateX(data)) + ((chart.x(chart.calculateX(data) + chart.calculateWidth(data)) - chart.x(chart.calculateX(data))) / 2);
      })
      .attr("y", function (data) {
        if (data.depth < newDepth) {
          return (data.depth * collapsedRowHeight()) + ((collapsedRowHeight() / 2) + 5);
        }
        var topOffset = chart.y(data.y);
        var height = chart.y(data.y + data.dy) - chart.y(data.y);

        var detailedData = chart.getDetailedDataFromData(data);

        //if there is no icon then center the label vertically
        if (!detailedData.image) {
          var labelHeight = this.getBoundingClientRect().height;
          return topOffset + (height / 2) + (labelHeight / 2) - 5;
        }

        //otherwise positition it 2/3 down
        return topOffset + ((height / 12) * 8);
      })
      .attr("width", function (data) {
        return chart.x(chart.calculateX(data) + chart.calculateWidth(data)) - chart.x(chart.calculateX(data));
      })
      .attr('opacity', function (data) {
        var width = chart.x(chart.calculateX(data) + chart.calculateWidth(data)) - chart.x(chart.calculateX(data));
        var height = data.depth < newDepth ? collapsedRowHeight() : chart.y(data.y + data.dy) - chart.y(data.y);
        return width <= 10 || height < 25 ? 0 : 1;
      })
      .each(newDepth < chart.currentDepth ? 'start' : 'end', chart.wrap);

    //begin transition of images
    chart.segmentImages.transition()
      .duration(animationDuration)
      .attr("x", function (data) {
        if (data.depth < newDepth && chart.isParentOf(data, selectedData)) {
          return chart.x(chart.calculateX(selectedData)) + ((chart.x(chart.calculateX(selectedData) + chart.calculateWidth(selectedData)) - chart.x(chart.calculateX(selectedData))) / 2) - 10;
        }
        return (chart.x(chart.calculateX(data)) + ((chart.x(chart.calculateX(data) + chart.calculateWidth(data)) - chart.x(chart.calculateX(data))) / 2)) - 10;
      })
      .attr("y", function (data) {
        if (data.depth < newDepth) {
          return (collapsedRowHeight() / 2) - 45;
        }
        return (chart.y(data.y) + ((((chart.y(data.y + data.dy) - chart.y(data.y))) / 12) * 8)) - 45;
      })
      .attr("opacity", function (data) {

        var detailedData = chart.getDetailedDataFromData(data);
        if (!detailedData.image) return 0;

        if (data.depth < newDepth) return 0;

        //if icon is too large for its segment - fade out
        var chartYPos = chart.y(data.y) + 10;
        var iconYPos = (chart.y(data.y) + ((((chart.y(data.y + data.dy) - chart.y(data.y))) / 12) * 8)) - 45;

        return (iconYPos < chartYPos) ? 0 : 1;
      });

    //if chart had edit region then we need to animate it
    if (chart.edit) {

      chart.editBlock.transition()
        .duration(animationDuration)
        .style("opacity", function (data) {
          return data.depth < newDepth ? 0 : 0.2;
        })
        .attr("x", function () {
          return 0;
        })
        .attr("y", function (data) {
          return data.depth < newDepth ? 0 : chart.y(data.y);
        })
        .attr("width", function () {
          return 64;
        })
        .attr("height", function (data) {
          if (data.depth < newDepth) return collapsedRowHeight();

          return chart.y(data.y + data.dy) - chart.y(data.y);
        })
        .each('start', function (data) {
          if (data.depth >= newDepth) this.style.display = "block";
        })
        .each('end', function (data) {
          if (data.depth < newDepth) this.style.display = "none";
        });

      chart.editText.transition()
        .duration(animationDuration)
        .style("opacity", function (data) {
          return data.depth < newDepth ? 0 : 1;
        })
        .attr("x", function () {
          return 32;
        })
        .attr("y", function (data) {
          if (data.depth < newDepth) {
            return (collapsedRowHeight() / 2) + 7;
          }
          return chart.y(data.y) + ((((chart.y(data.y + data.dy) - chart.y(data.y))) / 12) * 8);
        })
        .attr("width", function () {
          return 32;
        });

      chart.editImage.transition()
        .duration(animationDuration)
        .attr("x", function () {
          return 0;
        })
        .attr("y", function (data) {
          if (data.depth < newDepth) {
            return -20;
          }
          return (chart.y(data.y) + ((((chart.y(data.y + data.dy) - chart.y(data.y))) / 12) * 8)) - 40;
        })
        .attr("width", function () {
          return 64;
        })
        .attr("opacity", function (data) {
          //if no icon specified then hide - should prevent IE 9 issue
          if (!chart.edit || !chart.edit.image) return 0;

          if (data.depth < newDepth) return 0;

          //if icon is too large for its segment - fade out
          var chartYPos = chart.y(data.y) + 15;
          var iconYPos = (chart.y(data.y) + ((((chart.y(data.y + data.dy) - chart.y(data.y))) / 12) * 8)) - 40;
          return iconYPos < chartYPos ? 0 : 1;
        });
    }

    //only do this if callout is visible
    if (chart.calloutVisible) {
      //update callout color
      var callout = document.getElementsByClassName('callout')[0];

      //timeout will depend on whether or not we are moving to a higher or lower segment
      var colorTimeout = chart.isRedrawing ? 0 : (newDepth < chart.currentDepth ? (newDepth === 0 ? 198 : 145) : 280);

      //timeout require to give the illusion of changing color with the chart transition
      chart.calloutTimout = setTimeout(function () {

        //ensure callout exists before trying to style it
        if (!callout) return;

        //set color correctly
        callout.style.borderLeftColor = data.color;
      }, colorTimeout);
    }

    chart.currentDepth = newDepth;

    //if the selected segment is the current one then dont need to do anything more
    //comparing the two objects does not always work however position properties will be unique
    if (chart.selectedItem && chart.selectedItem.key === data.key && chart.selectedItem.x === data.x && chart.selectedItem.y === data.y) return;

    //store the clicked item
    chart.selectedItem = data;

    //if maximized we want to update the child list
    if (chart.isMaximized) {

      chart.childList = chart.getChildren(data);

      //we also want to re-render the user content in the docked popover
      chart.updateDockedPopover(data);

      //required to update docked popover list
      chart.apply();
    }
  };

  PartitionMap.prototype.onSegmentHover = function (data, elementIndex) {

    //if the hovered element changes while we are animating record the new highlighted segment
    //but dont do anything until animation is finished
    if (chart.isAnimating) {
      chart.hoveredElement = elementIndex;
      return;
    }

    //if an element has been specified then it was trigged by the hover event
    //otherwise we have finished animating and my want to retrigger the event manually
    var targetElement = elementIndex !== null ? elementIndex : chart.hoveredElement;

    //if we have no target element then we can stop here
    if (targetElement === null) return;

    //if this was triggered by the finished animation and we have an element then we should fetch its data
    if (data === null) {
      data = chart.getSegmentData(targetElement);
    }

    chart.hoverTimeout = setTimeout(function () {

      //ensure the we still have values
      if (data === null || data === undefined || targetElement === null || targetElement === undefined) return;

      //get the corresponding text element
      chart.popoverElement = targetElement;
      chart.selectItem(data, targetElement);

      //if data is a zero item dont show the popover
      if (data.value === 0) return;

      //we do not want to show the popover if chart is maximized and the details of the segment are in the docked panel
      if (chart.isMaximized && chart.segmentsEqual(chart.dockedPopoverItem, data)) return;

      //position and show the popover
      chart.showPopover();

    }, chart.hoverDuration);
  };

  PartitionMap.prototype.onSegmentLeave = function () {
    chart.hoveredElement = null;
    clearTimeout(chart.hoverTimeout);
  };

  //IE doesnt support foreignObjects so we must use svg text which doesnt support CSS - therefore no ellipsis
  //we must calculate the width of the text and see if it will fit comfortably within its bounds, if not add '...'
  PartitionMap.prototype.wrap = function (data) {

    var x = chart.x(data.x);
    var width = chart.x(data.x + data.dx) - x;

    var self = d3.select(this);

    //reset text to original to calculate correct width
    self.text(data.key);

    //we should check if the segment is on screen before doing anything
    if (x < 0 || x > chart.width) return;

    //performance - if width is less than 55 px, ellipsis!!
    if (width < 55) {
      self.text('...');
      return;
    }

    //each character has an approx width of 7px - but we will assume 10 to be sure
    //if approx text width will fit then we dont need to clip
    if ((data.key.length * 10) < (width - 40)) {
      self.text(data.key);
      return;
    }

    //required because if element isnt in visible DOM IE will throw and error - animations wont work
    if (!chart.element.contains(self.node())) return;

    var textLength = self.node().getComputedTextLength();

    var text = data.key;

    while (textLength > (width - (2 * 20)) && text.length > 0) {
      text = text.slice(0, -1);
      self.text(text + '...');
      textLength = self.node().getComputedTextLength();
    }
  };

  PartitionMap.prototype.wrapEditText = function () {

    var self = d3.select(this);

    //get edit text
    var text = chart.edit && chart.edit.text ? chart.edit.text : "";

    //reset text to original to calculate correct width
    self.text(text);

    //if there is not text we dont need to do anything
    if (text === "") return;

    //required because if element isnt in visible DOM IE will throw and error - animations wont work
    if (!chart.element.contains(self.node())) return;

    var textLength = self.node().getComputedTextLength();

    while (textLength > 42 && text.length > 0) {
      text = text.slice(0, -1);
      self.text(text + '...');
      textLength = self.node().getComputedTextLength();
    }
  };

  //if a color has been used before for a specific key then use it, otherwise pick the next available one
  PartitionMap.prototype.segmentColor = function (data) {

    //if a color was specified for the item by the user then use it instead
    var originalData = chart.getDetailedDataFromData(data);
    if (originalData.color) {
      return originalData.color;
    }

    var key = data.key;

    //root node will always be this color
    if (data.depth === 0) return chart.rootColor;

    var selectedPalette = (data.depth <= 4) ? data.depth - 1 : ((data.depth - 2) % 3) + 1;

    for (var i = 0; i < chart.usedColors.length; i++) {
      if (chart.usedColors[i].name === key && chart.usedColors[i].depth === data.depth) {
        return chart.usedColors[i].color;
      }
    }


    //sort the order of items in the row
    var allSiblings = chart.getAllSegmentSiblings(data);

    //group by parent and sort each group
    var groups = {};

    allSiblings.forEach(function (element, index) {
      var parent = element.parent.key + index;

      if (!groups[parent]) groups[parent] = [];
      groups[parent].push(element);
    });


    var siblings = [];

    var siblingContains = function (data) {
      for (var i = 0; i < siblings.length; i++) {
        if (siblings[i].key === data.key) return true;
      }
      return false;
    };

    //now sort each group
    for (var group in groups) {
      var currentGroup = groups[group];

      currentGroup.sort(function (a, b) {
        if (a.value < b.value) return 1;
        if (a.value > b.value) return -1;
        return 0;
      });

      for (var j = 0; j < currentGroup.length; j++) {
        var segment = currentGroup[j];

        if (!siblingContains(segment)) siblings.push(segment);
      }
    }

    var offset = -1;

    siblings.forEach(function (element, index) {
      if (element.key === data.key) offset = index;
    });

    if (offset >= chart.colors[selectedPalette].length) offset = offset % chart.colors[selectedPalette].length;

    var color = chart.colors[selectedPalette][offset];
    chart.usedColors.push({
      name: key,
      color: color,
      depth: data.depth
    });
    return color;
  };

  /*
    Find all segments at the same depth
  */
  PartitionMap.prototype.getAllSegmentSiblings = function (data) {
    var depth = data.depth;

    //we need to find the root node
    var rootNode = data;
    while (rootNode.parent) rootNode = rootNode.parent;

    //iterate through all child nodes and find all segments at the target depth
    var segments = [];

    var checkDepth = function (node) {
      if (node.depth === depth) {
        segments.push(node);
        return;
      }

      //if not correct depth but has children then check them
      if (node.children && node.children.length > 0) {
        for (var i = 0; i < node.children.length; i++) checkDepth(node.children[i]);
      }
    };

    //begin recursive check - starting with root node
    checkDepth(rootNode);

    return segments;
  };

  PartitionMap.prototype.getSegmentData = function (index) {
    return d3.select(chart.segments[0][index]).data()[0];
  };

  PartitionMap.prototype.getElementIndex = function (data) {
    for (var i = 0; i < chart.segments[0].length; i++) {
      //get data of element
      var elementData = d3.select(chart.segments[0][i]).data()[0];

      //compare datas
      if (elementData.key === data.key && elementData.x === data.x && elementData.y === data.y) return i;
    }
    return 0;
  };

  PartitionMap.prototype.toggleMaximized = function () {
    if (chart.isMaximized) chart.minimize();
    else chart.maximize();
  };

  PartitionMap.prototype.disableMaximize = function () {
    chart.allowMaximize = false;
  };

  //perform actions to maximize partition
  PartitionMap.prototype.maximize = function () {

    if (chart.isMaximized) return;

    chart.isMaximized = true;

    //if we have a toggle action then call it here in case we should prevent any more action
    if (chart.maximizeOptions.onToggle) {
      var stopPropagation = chart.maximizeOptions.onToggle(true);
      if (stopPropagation === true) return;
    }

    if (!this.maximizeOptions.shouldResize) {
      chart.element.className = "partition-map maximized";
      chart.dockedPopover.style.display = "inline-block";
      chart.redraw();
      chart.adjustPopoverDisplay();
      return;
    }

    if (!chart.maximizedContainer) {
      throw 'Page requires a "partition-container" if you wish to maximize partition chart';
    }

    chart.isTransitioning = true;

    //hide scrollbars
    if (chart.maximizeOptions.disableScrolling)
      document.getElementsByTagName("html")[0].style.overflow = 'hidden';

    //add the maximized class in here as we need the layout to update before angular does its stuff - reduce flickering
    chart.element.className = "partition-map maximized";

    //show the docked popover
    chart.dockedPopover.style.display = "inline-block";

    //if no item has ever been selected we should select the root node
    if (!chart.selectedItem) {
      chart.selectedItem = chart.getSegmentData(0);
    }

    //update the child list with the children of the selected item
    chart.childList = chart.getChildren(chart.selectedItem);

    //also lets update the user content
    chart.updateDockedPopover(chart.selectedItem);

    //redraw chart
    chart.redraw();

    //Set the side panel to the correct width
    chart.adjustPopoverDisplay();
  };

  PartitionMap.prototype.adjustPopoverDisplay = function () {
    //Set the side panel to the correct width
    chart.dockedPopover.style.width = this.maximizeOptions.sidePanelWidth + 'px';
    chart.element.style.width = 'calc(100% - ' + this.maximizeOptions.sidePanelWidth + 'px)';
  };

  //perform actions to minimize partition
  PartitionMap.prototype.minimize = function () {
    if (!chart.isMaximized) return;

    chart.isMaximized = false;

    //if we have a toggle action then call it here in case we should prevent any more action
    if (chart.maximizeOptions.onToggle) {
      var stopPropagation = chart.maximizeOptions.onToggle(false);
      if (stopPropagation === true) return;
    }

    //show scrollbars
    document.getElementsByTagName("html")[0].style.overflow = '';

    //remove the maximized class in here as we need the layout to update before angular does its stuff - reduce flickering
    chart.element.className = "partition-map";

    //hide the docked popover
    this.dockedPopover.style.display = "none";

    chart.isTransitioning = true;

    chart.element.style.width = '';

    //redraw chart
    chart.redraw();

  };

  // on resize calculate the layout
  PartitionMap.prototype.calculateLayout = function () {

    var disableScrolling = chart.maximizeOptions.disableScrolling;

    if (chart.isMaximized) {

      if (disableScrolling) {
        //store scroll location
        chart.scrollLocationX = window.pageXOffset;
        chart.scrollLocationY = window.pageYOffset;

        //scroll to top of page
        window.scrollTo(0, 0);
      }

      var dockedPopoverWidth = this.maximizeOptions.sidePanelWidth;

      //if we should resize to the container then do this
      if (chart.maximizeOptions.shouldResize) {

        //The chart wrapper needs to move to the position of the page container
        var top = ((chart.parent.offsetTop - chart.maximizedContainer.offsetTop) * -1);
        var left = ((chart.parent.offsetLeft - chart.maximizedContainer.offsetLeft) * -1);

        var documentWidth = (document.documentElement.clientWidth || document.body.clientWidth);
        var targetWidth = chart.maximizeOptions.fillScreen ? documentWidth - (chart.parent.getBoundingClientRect().left + left) : chart.maximizedContainer.offsetWidth;
        var targetHeight = chart.maximizeOptions.fillScreen ? window.innerHeight - (chart.parent.getBoundingClientRect().top + top) : chart.maximizedContainer.offsetHeight;

        chart.width = targetWidth - dockedPopoverWidth;
        chart.height = targetHeight;

        if (chart.width < 0) chart.width = 0;
        if (chart.height < 0) chart.height = 0;

        chart.parent.style.width = chart.width + dockedPopoverWidth + 'px';
        chart.parent.style.height = chart.height + 'px';

        if (Math.abs(top) !== 0) {
          chart.top += top;
          chart.parent.style.top = chart.top + 'px';
        }

        if (Math.abs(left) !== 0) {
          chart.left = left;
          chart.parent.style.left = chart.left + 'px';
        }

        //record the previous values to watch for changes
        chart.previousLeftOffset = chart.maximizedContainer.offsetLeft;
        chart.previousTopOffset = chart.maximizedContainer.offsetTop;
        chart.previousDocumentWidth = documentWidth;

      } else {
        //if we should only show the docked popover do this
        chart.width = chart.element.clientWidth;
        chart.height = chart.element.clientHeight;
      }


    } else {
      //remove any old maximized properties
      chart.parent.style.position = 'relative';
      chart.parent.style.top = '';
      chart.parent.style.left = '';
      chart.parent.style.width = '';
      chart.parent.style.height = '';

      chart.top = 0;
      chart.left = 0;
      chart.width = chart.element.clientWidth;
      chart.height = chart.element.clientHeight;

      if (disableScrolling) {
        //store to previous location
        window.scrollTo(chart.scrollLocationX, chart.scrollLocationY);
      }
    }

    //update button position
    chart.positionToggleButton();

    //update the popover position if possible
    chart.positionPopover();
  };

  // clear down and redraw
  PartitionMap.prototype.redraw = function (data, callback) {

    //recalculate the size of the chart
    chart.calculateLayout();

    if (chart.width === 0 || chart.height === 0) return;

    chart.container.find('svg').remove();
    chart.x = d3.scale.linear().range([0, chart.width]);
    chart.y = d3.scale.linear().range([0, chart.height]);
    chart.draw(data ? data : chart.data);

    //make sure we reselect the selected node if there was one
    chart.isRedrawing = true;
    if (chart.selectedItem) chart.selectSegment(chart.selectedItem);
    chart.isRedrawing = false;

    //if we have a callback call it
    if (callback) callback();

  };

  PartitionMap.prototype.showPopover = function () {

    //if the map is maximized we do not want to show the popover
    if (chart.popoverEnabled === false || chart.popoverVisible) return;

    //set styling
    chart.getPopover().style.visibility = 'hidden';
    chart.getPopover().style.display = 'block';

    //if the chart has no children then resize it before positioning
    var popoverContainer = chart.getPopover().getElementsByClassName('popover-container');

    //ensure we have found it - then resize it accordingly
    if (popoverContainer && popoverContainer.length > 0) {
      popoverContainer[0].style.width = (chart.childList && chart.childList.length === 0) ? '285px' : '';
    }

    //this is required to let flot and scrollbar render without any flickering
    chart.popoverShowTimeout = setTimeout(function () {
      chart.getPopover().style.visibility = '';
    }, 200);

    //position popover after showing it - needed to calculate correct size of popover for positioning
    chart.positionPopover();

    //record popover visibility
    chart.popoverVisible = true;
  };

  PartitionMap.prototype.hidePopover = function () {

    //record popover visibility
    chart.popoverVisible = false;

    //set styling
    var popover = chart.getPopover();

    if (popover) {
      popover.style.display = 'none';
    }
  };

  PartitionMap.prototype.positionPopover = function () {

    // if we dont have a selected segment - dont calculate
    if (chart.popoverElement === null || chart.popoverElement === undefined) return;

    //get data of segment element
    var segmentData = chart.getSegmentData(chart.popoverElement);

    // check we have segmentData
    if (segmentData === null || segmentData === undefined) return;

    //calculate position
    var segmentY = chart.y(segmentData.y);

    //if off screen hide and reset
    if (segmentY < 0) {
      //if the segment is also not the visible parent segment
      if (!(segmentData.depth < chart.currentDepth && chart.isParentOf(segmentData, chart.selectedItem)) || chart.selectedItem === null) {
        chart.hidePopover();
        return;
      }
    }

    //get our popover element
    var popoverElement = chart.getPopover();

    //get containing element
    var partitionBox = chart.parent;
    var partitionBoxBounds = partitionBox.getBoundingClientRect();

    //get the corresponding text element to calculate the position from
    var textElement = chart.segmentLabels[0][chart.popoverElement];

    //get the position and size of the text element - cant use on getBoundingClientRect on tspan - IE10 wont work
    var textBounds = textElement.parentNode.getBoundingClientRect();

    //get the position and size of the popover element
    var popoverBounds = popoverElement.getBoundingClientRect();

    //Calculate new position of popover
    var popoverX = ((textBounds.left + (textBounds.width / 2)) - (popoverBounds.width / 2));
    var popoverY = (textBounds.top + textBounds.height);

    //take into account the partition box
    popoverX -= partitionBoxBounds.left;
    popoverY -= partitionBoxBounds.top;

    //reset popover classes
    popoverElement.className = "popover bottom partition-popover";

    //reset arrow margin to default
    chart.popoverArrow.style.marginLeft = '-11px';

    //store current window size for later
    var windowWidth = window.innerWidth;
    var windowHeight = window.innerHeight;

    //store the container size for later - (for use if we are within a modal)
    var containerWidth = this.parent.offsetWidth;
    var containerHeight = this.parent.offsetHeight;

    var overlap = 0;

    if (chart.modalChart === true) {

      //if popover position is below the bottom of the window then adjust
      if ((popoverY + popoverBounds.height) > containerHeight) {
        popoverElement.className = "popover top partition-popover";
        popoverY -= (popoverBounds.height + 15);
      }

      //if popover calculated position is off screen then reposition accordingly
      if (popoverX < 20) {
        //position popover arrow to middle of text
        chart.popoverArrow.style.marginLeft = (popoverX - 31) + 'px';
        popoverX = 20;
      } else if ((popoverX + popoverBounds.width) > (containerWidth - 60)) {
        overlap = (containerWidth - (popoverX + popoverBounds.width)) - 60;
        chart.popoverArrow.style.marginLeft = ((overlap * -1) - 11) + 'px';
        popoverX += overlap;
      }

    } else {
      //if popover position is below the bottom of the window then adjust
      if (((popoverY + partitionBoxBounds.top) + popoverBounds.height) > windowHeight) {
        popoverElement.className = "popover top partition-popover";
        popoverY -= (popoverBounds.height + 15);
      }

      //if popover calculated position is off screen then reposition accordingly
      if ((popoverX + partitionBoxBounds.left) < 20) {
        //position popover arrow to middle of text
        chart.popoverArrow.style.marginLeft = ((popoverX + partitionBoxBounds.left) - 31) + 'px';
        popoverX = 20 - partitionBoxBounds.left;
      } else if ((popoverX + partitionBoxBounds.left + popoverBounds.width) > (windowWidth - 60)) {
        overlap = (windowWidth - (popoverX + partitionBoxBounds.left + popoverBounds.width)) - 60;
        chart.popoverArrow.style.marginLeft = ((overlap * -1) - 11) + 'px';
        popoverX += overlap;
      }
    }

    //now update the position of the popover
    popoverElement.style.top = popoverY + "px";
    popoverElement.style.left = popoverX + "px";
  };

  PartitionMap.prototype.getPopover = function () {
    //this is required because the directive has not be applied yet and popover element will be referenced incorrectly
    if (!chart.popover) {
      chart.popover = chart.parent.getElementsByClassName('partition-popover')[0];

      if (chart.popover === null || chart.popover === undefined) return;

      //get popover top arrow
      chart.popoverArrow = chart.popover.getElementsByClassName("arrow")[0];
    }
    return chart.popover;
  };

  PartitionMap.prototype.checkPopover = function (e) {
    if (chart.popoverVisible) {
      chart.mouseX = e.clientX;
      chart.mouseY = e.clientY;

      //check if the mouse is within the rect
      var rectElement = chart.segments[0][chart.popoverElement];
      var rectBounds = rectElement.getBoundingClientRect();

      //if it is within then do nothing
      if (chart.mouseX > rectBounds.left && chart.mouseX < rectBounds.right && chart.mouseY > rectBounds.top && chart.mouseY < rectBounds.bottom) return;

      // otherwise check if mouse is over the popover
      var popoverElement = chart.getPopover();
      var popoverBounds = popoverElement.getBoundingClientRect();

      //if mouse is over the popover or between the segment and the popover
      if (chart.mouseX > popoverBounds.left && chart.mouseX < popoverBounds.right && chart.mouseY > (popoverBounds.top - 2) && chart.mouseY < popoverBounds.bottom) return;

      if (chart.hoverLeaveTimeout) return;

      chart.hoverLeaveTimeout = setTimeout(function () {
        //recheck bounds
        //if it is within then do nothing
        if (chart.mouseX > rectBounds.left && chart.mouseX < rectBounds.right && chart.mouseY > rectBounds.top && chart.mouseY < rectBounds.bottom) {
          chart.hoverLeaveTimeout = null;
          return;
        }

        //if mouse is over the popover or between the segment and the popover
        if (chart.mouseX > popoverBounds.left && chart.mouseX < popoverBounds.right && chart.mouseY > (popoverBounds.top - 2) && chart.mouseY < popoverBounds.bottom) {
          chart.hoverLeaveTimeout = null;
          return;
        }

        // hide the popovers
        chart.hidePopover();

        chart.hoverLeaveTimeout = null;

      }, chart.hoverLeaveDuration);

    }
  };

  PartitionMap.prototype.selectItem = function (data) {

    //if popover is not enabled, do not update popover data
    if (this.popoverEnabled === false) return;

    //if the item is the same as the previously rendered item dont re-render
    //object equality is not guaranteed, but position is unique so use it instead
    if (data && chart.popoverItem && chart.popoverItem.key === data.key && chart.popoverItem.x === data.x && chart.popoverItem.y === data.y) return;

    //generate new child list
    chart.childList = chart.getChildren(data);

    //store data of popover item
    chart.popoverItem = data;

    //let the popover know to update
    var popoverData = data;
    popoverData.data = chart.getDetailedDataFromData(data);
    popoverData.data.parents = chart.getParentsData(popoverData);

    chart.rootScope.$broadcast('popover-update', popoverData);
  };

  //object equality is not guaranteed, but position is unique so use it instead
  PartitionMap.prototype.segmentsEqual = function (segmentOne, segmentTwo) {
    return (segmentOne && segmentTwo && segmentOne.key === segmentTwo.key && segmentOne.x === segmentTwo.x && segmentOne.y === segmentTwo.y);
  };

  PartitionMap.prototype.cloneObject = function (obj) {
    if (null === obj || "object" !== typeof obj) return obj;
    var copy = obj.constructor();
    for (var attr in obj) {
      if (obj.hasOwnProperty(attr)) copy[attr] = obj[attr];
    }
    return copy;
  };

  PartitionMap.prototype.getChildren = function (root) {

    var children = [];

    if (!root || !root.children) return [];

    //generate formatted value
    root.formattedValue = chart.valueFormatter(root.value);

    var zeroNode;

    for (var nd = 0; nd < root.children.length; nd++) {

      //generate formatted value
      var childNode = root.children[nd];
      childNode.formattedValue = chart.valueFormatter(childNode.value);

      if (root.children[nd].key === '__zero__') {
        zeroNode = root.children[nd];
      } else {
        //push current item on to list
        children.push(childNode);
      }
    }

    if (zeroNode) {
      var rootData = chart.getDetailedDataFromData(root);

      //find all zero nodes and merge with the zero node
      for (var i = 0; i < rootData.children.length; i++) {
        var node = rootData.children[i];

        if (node.value === 0) {

          //clone object
          var newNode = chart.cloneObject(zeroNode);
          newNode.key = node.label;
          newNode.value = 0;
          newNode.formattedValue = chart.valueFormatter(0);
          children.push(newNode);
        }
      }
    }

    //return child nodes sorted
    return children;
  };

  //This will get the original data for all the parent segments
  PartitionMap.prototype.getParentsData = function (data) {

    var currentSegment = data;

    var parents = [];

    while (currentSegment.hasOwnProperty('parent')) {
      parents.push(chart.getDetailedDataFromData(currentSegment.parent));
      currentSegment = currentSegment.parent;
    }

    return parents;
  };

  PartitionMap.prototype.updateDockedPopover = function (data) {

    //store the docked popover item
    chart.dockedPopoverItem = data;

    var userContentScope = chart.rootScope.$new(true);

    //add all the properties from data to scope
    for (var key in data) {
      userContentScope[key] = data[key];
    }

    //add this extra property containing the original data
    userContentScope.data = chart.getDetailedDataFromData(data);

    //add the parent information to data
    userContentScope.data.parents = chart.getParentsData(data);

    //update list of children
    chart.dockedChildList = chart.getChildren(data);

    if (chart.popoverTemplate) {
      //compile the template with the latest values

      //find the target area for the template
      var contentArea = angular.element(chart.dockedUserContent);

      //compile template and add it to the popover
      contentArea.empty().append(chart.popoverTemplate);
      chart.compile(contentArea)(userContentScope);

      //apply the scope if needed
      chart.apply();

      chart.timeout(chart.scope.pane.reinitialise);
    }
  };

  //this method will allow us to take in a detailed json string and
  //convert it to a simplifed one compatible with d3
  PartitionMap.prototype.processData = function (data) {

    var output = {};
    for (var key in data) {
      var label = data[key].label ? data[key].label : "";

      if (data.hasOwnProperty(key)) {
        if (data[key].value) {
          output[label] = data[key].value;
        } else if (data[key].children) {
          output[label] = chart.processData(data[key].children);
        } else if (data[key].value === 0) {
          output.__zero__ = 0;
        }
      }
    }

    //if we have no data specified, store this fact
    chart.noData = chart.isEmpty(output);

    //required to ensure we update the UI on data change
    chart.apply();

    return output;
  };

  PartitionMap.prototype.isEmpty = function (obj) {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop))
        return false;
    }
    return true;
  };


  //we may want to get the original detailed data from simplifed data
  PartitionMap.prototype.getDetailedDataFromData = function (data) {

    //lets get the heirarchy
    var steps = [data.key];
    var node = data;

    while (node.parent) {
      steps.push(node.parent.key);
      node = node.parent;
    }

    //we now have the heirarchy required - now reverse and traverse!
    node = chart.originalData;
    for (var i = steps.length - 1; i >= 0; i--) {

      for (var j = 0; j < node.length; j++) {
        var obj = node[j];

        if (obj.label === steps[i]) {
          if (!obj.children || i === 0) {
            node = obj;
          } else {
            node = obj.children;
          }
        }
      }
    }

    return node;
  };

  PartitionMap.prototype.isParentOf = function (parent, child) {
    var node = child;

    while (node.parent) {
      //using === doesnt always return correct value so check against unique properties
      if (node.parent.key === parent.key && node.parent.x === parent.x && node.parent.y === parent.y)
        return true;

      node = node.parent;
    }


    return false;
  };

  //check if segment has any zero siblings
  PartitionMap.prototype.hasZeroSibling = function (data) {
    //if root node then always will be false
    if (!data.parent) return false;

    //get sibling segments
    var siblings = data.parent.children;

    for (var i = 0; i < siblings.length; i++) {
      var sibling = siblings[i];

      //if a zero sibling exists
      if (sibling.key === '__zero__') {
        return true;
      }
    }
    return false;
  };

  //calculate x position based on if the row has any zero values in it
  PartitionMap.prototype.calculateX = function (data) {

    //if root node or no zero siblings then return normal position
    if (!data.parent) return data.x;

    //get the x position of the parent segment
    var parentX = chart.calculateX(data.parent);

    //get siblings
    var siblings = data.parent.children;

    //set initial start position equal to that of the parent
    var startPos = parentX;

    for (var i = 0; i < siblings.length; i++) {
      siblings[i].x = startPos;
      startPos += chart.calculateWidth(siblings[i]);

      if (siblings[i].key === data.key) return siblings[i].x;
    }
  };

  //calculate width based on if the row has any zero values in it
  PartitionMap.prototype.calculateWidth = function (data) {

    //if root node then return 1 always
    if (!data.parent) return 1;

    //get width of parent
    var parentWidth = chart.calculateWidth(data.parent);
    var parentOffset = parentWidth / data.parent.dx;

    //check if there are any zero siblings
    var siblings = data.parent.children;
    var hasZero = chart.hasZeroSibling(data);

    if (hasZero) {

      //calculate width of zero item - 1/20th of its parent
      var zeroWidth = parentWidth / 20;

      //calculate how much we need to reduce each sibling by - share reduction between all
      var siblingReduction = (zeroWidth / (siblings.length - 1));

      if (data.key === '__zero__') {
        return zeroWidth * parentOffset;
      }
      return (data.dx - siblingReduction) * parentOffset;
    }

    return data.dx * parentOffset;
  };

  PartitionMap.prototype.setLoading = function (loading) {
    chart.isLoading = loading;
    chart.hidePopover();
    chart.updateToggleVisibility();
    chart.apply();
  };

  PartitionMap.prototype.updateToggleVisibility = function () {
    if (chart.isLoading) {
      chart.allowMaximize = false;
    } else {
      chart.allowMaximize = true && chart.maximizeOptions.buttonVisible;
    }
  };

  PartitionMap.prototype.apply = function () {
    //only apply scope if we need to
    if (!chart.rootScope.$$phase) {
      chart.rootScope.$apply();
    }
  };

  PartitionMap.prototype.calculateDepth = function (root, value) {
    //value is optional - if not specified default to 0
    if (!value) value = 0;

    //traverse nodes
    if (root.depth !== null) {
      //if the node has a depth greater than the currently known one then record this
      if (root.depth > value) value = root.depth;

      //if it has children then lets process them too!
      if (root.children) {

        //iterate each child and process
        for (var child = 0; child < root.children.length; child++) {
          var newVal = chart.calculateDepth(root.children[child], value);

          //if greater then store child greatest depth
          if (newVal > value) value = newVal;
        }
      }

      return value;
    }
  };

  PartitionMap.prototype.valueOrDefault = function (value, defaultValue) {
    return (value === null || value === undefined) ? defaultValue : value;
  };

  PartitionMap.prototype.handleWheelClick = function (e) {
    if (e.which === 2 && chart.isMaximized && chart.maximizeOptions.disableScrolling) {
      e.stopPropagation();
      e.preventDefault();
      e.cancelBubble = false;
      return false;
    }
  };

  PartitionMap.prototype.positionToggleButton = function () {
    //get the default button position depending on maximized state
    //var defaultPosition = chart.isMaximized ? chart.toggleButtonDefault.maximize : chart.toggleButtonDefault.minimize;

    //set default button position to the 'maximize' offset it the map should resize, otherwise keep the same.
    var defaultPosition;
    if (chart.isMaximized && chart.maximizeOptions.shouldResize) {
      defaultPosition = chart.toggleButtonDefault.maximize;
    } else defaultPosition = chart.toggleButtonDefault.minimize;

    //get the specified offset for the button
    var buttonOffset = chart.isMaximized ? chart.buttonOffset.maximize : chart.buttonOffset.minimize;

    //calculate the new positions based on the offset specified
    var x = defaultPosition.x + (buttonOffset.x * -1); //invert to provide expected behaviour
    var y = defaultPosition.y + buttonOffset.y;

    //position the button accordingly
    chart.toggleButton.style.right = x + 'px';
    chart.toggleButton.style.top = y + 'px';
  };

})();;
(function () {
  
  angular.module("hpe.elements.partitionMap").directive("partitionPopover", partitionPopover);

  partitionPopover.$inject = ['$compile', '$timeout'];

  function partitionPopover($compile, $timeout) {
    return {
      restrict: "E",
      transclude: true,
      templateUrl: "partitionMap/template/popoverTemplate.html",
      scope: true,
      link: function (scope, element) {
        var vm = scope;

        //find the target area for the template
        var contentArea = angular.element(element[0].getElementsByClassName('user-content')[0]);

        scope.$watch('chart.childList', function (newValue, oldValue) {
          if (newValue === oldValue) {
            return;
          }

          // update scroll pane
          if(vm.pane) {
            $timeout(vm.pane.reinitialise);
          }
        });

        scope.$on('popover-update', function (event, data) {
          var userContentScope = scope.$new(true);

          for (var key in data) {
            userContentScope[key] = data[key];
          }

          if (vm.chart.popoverTemplate) {
            //compile the template with the latest values

            //compile template and add it to the popover
            contentArea.empty().append(vm.chart.popoverTemplate);
            $compile(contentArea)(userContentScope);

            //apply the scope
            if (!userContentScope.$$phase) {
              userContentScope.$digest();
            }
          }
        });
      }
    };
  }
})();;
(function () {

    angular.module('hpe.elements.updatingLinechart', []).directive('updatingLinechart', updatingLinechart);

    function updatingLinechart() {
        return {
            restrict: 'E',
            scope: {
                data: "=",
                options: "=",
                method: "=",
                updateinterval: "="
            },
            link: function (scope, element, attrs) {

                var options = {};
                var chartType = "line";
                if (scope.options) {
                    options = scope.options;
                }

                scope.span = document.createElement('span');
                var span = scope.span;
                scope.chartType = chartType;
                span.textContent = scope.data.join();

                if (!attrs.class) {
                    span.className = "";
                } else {
                    span.className = attrs.class;
                }

                if (element[0].nodeType === 8) {
                    element.replaceWith(span);
                } else {
                    element[0].appendChild(span);
                }

                scope.updatingChart = jQuery(span).peity(chartType, options);
                setInterval(function () {
                    scope.data = scope.method(scope.data);
                    scope.span.textContent = [scope.data.join(",")];
                    scope.updatingChart.change();
                }, scope.updateinterval);
            }

        };

    }

})();;
(function () {
  angular.module("hpe.elements.previewPanes", ["hpe.elements.templates"]);
})();;
(function () {

  angular.module('hpe.elements.previewPanes').controller("PreviewPaneCtrl", PreviewPaneCtrl);
  PreviewPaneCtrl.$inject = ["$scope", "$rootScope", "previewPaneProvider", "windowCommunicationService"];

  function PreviewPaneCtrl($scope, $rootScope, previewPaneProvider, windowCommunicationService) {
    var vm = this;
    vm.previewpane = $scope;
    vm.provider = previewPaneProvider;
    vm.previewOn = previewPaneProvider.preview.previewOn;

    // if name if broadcast from previewPaneWindow directive, then open preview pane window
    $scope.$on(vm.previewpane.previewName, function () {
      vm.openInNewWindow();
    });

    vm.previewWindow = null;

    // if preview file changes while window open, reload window to show the new file
    $scope.$watch(function () {
      return vm.previewpane.previewFile;
    }, function (nV, oV) {
      if (nV === oV) return;
      if (vm.previewWindow === null || vm.previewWindow.closed) return;

      windowCommunicationService.updateContent(vm.previewpane.$parent, nV);

    });

    vm.updatePreviewOn = function (nv) {
      vm.previewOn = nv;
    };

    vm.updateHasPreviewFile = function (nv) {

      vm.provider.preview.previewFile = nv;
      vm.previewpane.previewFile = vm.provider.preview.previewFile;

      return vm.previewpane.previewFile;
    };

    vm.openInNewWindow = function () {
      //if the button is clicked while the preview window is open, return 
      if (vm.previewWindow && !vm.previewWindow.closed)
        return;
      else
        vm.previewWindow = windowCommunicationService.createWindow('Preview', vm.previewpane.$parent, vm.previewpane.previewFile);
    };

  }

})();;
(function () {

  angular.module("hpe.elements.previewPanes").directive("previewPane", previewPane);
  previewPane.$inject = ["$document", "$window", "previewPaneProvider", "$q", "$compile", "$templateRequest", "$timeout"];

  function previewPane($document, $window, previewPaneProvider, $q, $compile, $templateRequest, $timeout) {
    return {
      restrict: "E",
      templateUrl: "previewPanes/previewPane/template/previewPane.html",
      controller: "PreviewPaneCtrl as pp",
      scope: {
        previewFile: "=",
        previewTitle: "=?",
        previewSubtitle: "=?",
        previewEmptyText: "=",
        childScope: "=",
        shadow: "=",
        previewName: "=?"
      },
      replace: true,
      link: function (scope) {

        var modalDomEl = "";
        // extended in the future to opt between template and templateUrl.
        function getTemplatePromise(options) {
          return $templateRequest(options);
        }

        //extended in the future to accomodate angular resolves// if needed.
        function getResolvePromises() {
          return [];
        }

        scope.preview = previewPaneProvider.preview;
        scope.$watch("preview", function (nv, ov) {

          if (nv.previewOn !== ov.previewOn) {
            scope.pp.updatePreviewOn(nv.previewOn);
          }

          scope.pp.updateHasPreviewFile(nv.previewFile);
          if (nv.previewFile !== ov.previewFile) {

            if (nv.previewFile === "") {
              angular.element('.preview-pane-selected-item').removeClass('preview-pane-selected-item');
            }

          }
        }, true);

        scope.$watch("previewFile", function (nv) {
          if (scope.previewFile !== "") {
            var templateAndPromise = $q.all([getTemplatePromise(nv)].concat(getResolvePromises()));
            var value = "";
            templateAndPromise.then(function resolveSuccess(tpl) {
              if (scope.childScope !== null) {
                value = $compile(tpl[0])(scope.childScope);
              } else {
                value = tpl[0];
              }
              modalDomEl = value;
            });

            templateAndPromise.finally(function () {
              $timeout(function () {
                var el = angular.element('.previewFile');
                el.empty();
                el.append(modalDomEl);
              });
            });
          } else {
            scope.pp.updateHasPreviewFile(nv);
          }
        });
      }
    };
  }
})();;
(function () {

  angular.module('hpe.elements.previewPanes').controller("PreviewPaneItemCtrl", PreviewPaneItemCtrl);
  PreviewPaneItemCtrl.$inject = ["$scope"];

  function PreviewPaneItemCtrl($scope) {
    var vm = this;
    vm.selectCallback = $scope.previewPaneItem;
    vm.tabIndex = 0;
  }

  PreviewPaneItemCtrl.prototype.updateIndex = function (val) {
    this.tabIndex = val;
  };

  PreviewPaneItemCtrl.prototype.select = function (val) {
    this.selectCallback({
      itemIndex: val
    });
  };
})();;
(function () {

  angular.module("hpe.elements.previewPanes").directive("previewPaneItem", previewPaneItem);
  previewPaneItem.$inject = ["keyboardNavigationService"];

  function previewPaneItem(keyboardNavigationService) {
    return {
      restrict: "A",
      controller: "PreviewPaneItemCtrl as pptc",
      scope: {
        previewPaneItem: "&",
        keydownSelect: "=?"
      },
      link: function (scope, element) {
        var keyService = keyboardNavigationService;

        function appendClass(el) {
          angular.element('.preview-pane-selected-item').removeClass('preview-pane-selected-item');
          angular.element(el).addClass('preview-pane-selected-item');
        }

        // on click, select the item
        element.on('click', function() {
          selectItem(element);
        });

        // up keypress - go to previous item
        keyService.keydown(element, 38, function(evt) {
          evt.preventDefault();
          var goToItem = element.prev('[preview-pane-item]');
          goToItem.focus();
          appendClass(goToItem);
          keyDownSelect(goToItem);
        });
        
        // down key press - go to next item
        keyService.keydown(element, 40, function(evt) {
          evt.preventDefault();
          var goToItem = element.next('[preview-pane-item]');
          goToItem.focus();
          appendClass(goToItem);
          keyDownSelect(goToItem);
        });

        // pg up key press - go to 10th previous item or 1st item if not possible
        keyService.keydown(element, 33, function(evt) {
          evt.preventDefault();
          var itemToJumpTo = element.prevAll('[preview-pane-item]');
          if (itemToJumpTo.length) {
            var goToItem = element.prevAll('[preview-pane-item]:eq(10)').length ? element.prevAll('[preview-pane-item]:eq(10)') : itemToJumpTo.slice(-1);
            goToItem.focus();
            appendClass(goToItem);
            keyDownSelect(goToItem);
          }
        });

        // pg down key press - go to 10th next item or last item if not possible
        keyService.keydown(element, 34, function(evt) {
          evt.preventDefault();
          var itemToJumpTo = element.nextAll('[preview-pane-item]');
          if (itemToJumpTo.length) {
            var goToItem = element.nextAll('[preview-pane-item]:eq(10)').length ? element.nextAll('[preview-pane-item]:eq(10)') : itemToJumpTo.slice(-1);
            goToItem.focus();
            appendClass(goToItem);
            keyDownSelect(goToItem);
          }
        });

        // home key press - go to the first item
        keyService.keydown(element, 36, function(evt) {
          evt.preventDefault();
          var goToItem = element.prevAll('[preview-pane-item]:last');
          goToItem.focus();
          appendClass(goToItem);
          keyDownSelect(goToItem);
        });

        // end key press - go to the last item
        keyService.keydown(element, 35, function(evt) {
          evt.preventDefault();
          var goToItem = element.nextAll('[preview-pane-item]:last');
          goToItem.focus();
          appendClass(goToItem);
          keyDownSelect(goToItem);
        });

        // remove focus from item
        keyService.keydown(element, 27, function(evt) {
          evt.preventDefault();
          element.blur();
        });

        // select the item
        keyService.keydown(element, 13, function() {
          selectItem(element);
        });

        function keyDownSelect(item) {
          if (scope.keydownSelect && item.length)
            selectItem(item);
        }

        function selectItem(item) {
          appendClass(item);
          scope.pptc.select(item.index());
          scope.$apply();
        }

      }
    };
  }

})();;
(function () {

  angular.module("hpe.elements.previewPanes").provider("previewPaneProvider", previewPaneProvider);


  function previewPaneProvider() {

    function previewPaneFactory() {
      return new PreviewPane();
    }

    this.$get = previewPaneFactory;
  }


  function PreviewPane() {
    this.preview = {
      previewOn: false,
      previewFile: ""
    };
  }
})();;
(function () {

  angular.module('hpe.elements.previewPanes').controller("PreviewPaneToggleCtrl", PreviewPaneToggleCtrl);
  PreviewPaneToggleCtrl.$inject = ["$scope", "previewPaneProvider"];

  function PreviewPaneToggleCtrl($scope, previewPaneProvider) {
    var vm = this;
    vm.previewpanetoggle = $scope;
    vm.provider = previewPaneProvider;
    $scope.setPreview = previewPaneProvider.preview.previewOn;
  }

  PreviewPaneToggleCtrl.prototype.togglePreview = function () {
    this.provider.preview.previewOn = !this.provider.preview.previewOn;
    this.previewpanetoggle.setPreview = this.provider.preview.previewOn;

    return this.previewpanetoggle.setPreview;
  };

})();;
(function () {

  angular.module("hpe.elements.previewPanes").directive("previewPaneToggle", previewPaneToggle);

  function previewPaneToggle() {
    return {
      restrict: "EA",
      templateUrl: "previewPanes/previewPaneToggle/template/previewPaneToggle.html",
      controller: "PreviewPaneToggleCtrl as ppt",
      replace: true,
      scope: {
        setPreview: "="
      },
      link: function (scope, element) {
        element.on('click', function () {
          scope.ppt.togglePreview();
          scope.$digest();
        });
      }
    };
  }
})();;
(function () {

  angular.module("hpe.elements.previewPanes").directive("previewPaneWindow", previewPaneWindow);
  previewPaneWindow.$inject = ["$rootScope"];

  function previewPaneWindow($rootScope) {
    return {
      restrict: "E",
      replace: true,
      template: '<a class="preview-pane-new-window" tooltip="Standalone Viewer" ng-click="openInNewWindow()">' +
        '<i class="hp-icon hp-clone"></i>' +
        '</a>',
      //controller: "PreviewPaneCtrl as pp",
      scope: {
        previewName: "="
      },
      link: function (scope) {
        // boradcast name so PreviewPaneCtrl can watch 
        scope.openInNewWindow = function () {
          $rootScope.$broadcast(scope.previewName);
        };

      }
    };
  }

})();;
(function() {
    angular.module('hpe.elements.radiobutton', []);
})();;
(function() {

    angular.module('hpe.elements.checkbox').controller('RadiobuttonCtrl', RadiobuttonCtrl);

    function RadiobuttonCtrl() {
        var vm = this;

        vm.toggleChecked = function() {

            // if disabled then do nothing
            if(vm.ngDisabled === true) {
                return;
            }

            vm.ngModel = vm.ngValue;
        };

        vm.keydown = function(event) {
            
            // if spacebar is pressed toggle state
            if(event.keyCode === 32) {
                vm.toggleChecked();
                event.stopPropagation();
                event.preventDefault();
            }
        };
    }

})();;
(function() {
    angular.module('hpe.elements.radiobutton').directive('radiobutton', radiobutton);

    function radiobutton() {
        return {
            restrict: 'E',
            transclude: true,
            templateUrl: 'radiobutton/radiobutton.html',
            controller: 'RadiobuttonCtrl as vm',
            bindToController: true,
            replace: true,
            scope: {
                ngModel: '=',
                ngValue: '=',
                ngDisabled: '=?',
                simplified: '=?',
                name: '@?',
                id: '@?'
            },
            compile: function(element, attrs) {

                // check if we have a name attribute
                if(attrs.name !== undefined) {
                    
                    // replace the name attribute with a for attribute
                    element.removeAttr('name').attr('for', attrs.name);
                }
            }
        };
    }

})();;
(function () {
    angular.module('hpe.elements.reorderableTable', []);
})();;
(function () {

    angular.module('hpe.elements.reorderableTable').directive('reorderableTable', reorderableTable);

    reorderableTable.$inject = ['safeTimeout', 'safeEventListener'];

    function reorderableTable(safeTimeout, safeEventListener) {
        return {
            restrict: 'A',
            scope: {
                onReorder: '=?',
                onReorderComplete: '=?'
            },
            require: 'ngModel',
            link: function (scope, element, attrs, ngModel) {

                // create instances of scope safe handlers
                var safeTimeoutInstance = safeTimeout.create(scope);
                var safeEventListenerInstance = safeEventListener.create(scope);

                // wait for element to be rendered
                safeTimeoutInstance.timeout(init);

                // store some information when dragging
                var selected_table_row;
                var table_body = element.find('tbody');

                // ensure there is a tbody - otherwise make a fuss
                if (table_body.length === 0) throw 'Reorderable Table - The table must have a <tbody>.';

                // prepare scope values
                var on_reorder = scope.onReorder || angular.noop;
                var on_reorder_complete = scope.onReorderComplete || angular.noop;

                function init() {

                    // create unique ids
                    create_unique_ids();

                    // any any required event listeners
                    add_event_listeners();

                    // watch for any new rows being added
                    var observer = new MutationObserver(function (mutations) {
                        mutations.forEach(function (mutation) {

                            // look for any new nodes
                            if (mutation.addedNodes && mutation.addedNodes.length > 0) {

                                // iterate each node
                                for (var idx = 0; idx < mutation.addedNodes.length; idx++) {

                                    // get the current node
                                    var node = mutation.addedNodes.item(idx);

                                    // if node name is a tr then we need to prepare it
                                    if (node.nodeName.toLowerCase() === 'tr') {
                                        add_new_row(node);
                                    }
                                }

                            }
                        });
                    });

                    // configuration of the observer:
                    var config = {
                        childList: true,
                        subtree: true
                    };

                    // watch for any new rows being added
                    observer.observe(element[0], config);
                }

                function add_new_row(element) {

                    // if the element has an id it has been moved not created so skip this bit
                    if (element.id && element.id !== "") return;

                    var table_row = angular.element(element);

                    // give the row a unique id
                    table_row.uniqueId();

                    // find drag elements
                    var drag_controls = table_row.find('[reorder-drag]');
                    var reorder_up_controls = table_row.find('[reorder-up]');
                    var reorder_down_controls = table_row.find('[reorder-down]');

                    // add event handlers to drag handle
                    drag_controls.mousedown(on_drag_begin);

                    // add event handler to reorder buttons
                    reorder_up_controls.click(on_move_up);
                    reorder_down_controls.click(on_move_down);

                    // add mouse over event to each table row
                    table_row.mouseover(on_mouse_over_row);
                }

                function create_unique_ids() {

                    // get all the table rows and add a unique id to them
                    table_body.find('tr').uniqueId();
                }

                function add_event_listeners() {

                    // find any reorder controls
                    var table_rows = table_body.find('tr');
                    var drag_controls = table_body.find('[reorder-drag]');
                    var reorder_up_controls = table_body.find('[reorder-up]');
                    var reorder_down_controls = table_body.find('[reorder-down]');

                    // add mouse move event handler to the document - use safeEventListener to ensure disposal
                    safeEventListenerInstance.bind(document, 'mousemove', on_drag);
                    safeEventListenerInstance.bind(document, 'mouseup', on_drag_end);

                    // add event handlers to drag handle
                    drag_controls.mousedown(on_drag_begin);

                    // add event handler to reorder buttons
                    reorder_up_controls.click(on_move_up);
                    reorder_down_controls.click(on_move_down);

                    // add mouse over event to each table row
                    table_rows.mouseover(on_mouse_over_row);
                }

                function on_drag_begin(evt) {

                    // clear any text selection
                    clear_selection();

                    // get the table row from the event target
                    var table_row = table_row_from_event(evt);

                    // store the currently dragged element
                    selected_table_row = table_row;

                    // add the 'dragging' class to the table row
                    angular.element(table_row).addClass('dragging');

                    // set the cursor to a dragging state
                    document.body.style.cursor = 'ns-resize';
                }

                function on_drag() {

                    // clear any text selection if we are dragging
                    if (selected_table_row) clear_selection();
                }

                function on_drag_end() {

                    // dont do anything if we were not dragging
                    if (!selected_table_row) return;

                    // remove the 'dragging' class from the row
                    angular.element(selected_table_row).removeClass('dragging');

                    // remove any reference of the dragging row
                    selected_table_row = null;

                    // remove dragging cursor
                    document.body.style.cursor = '';

                    // call callback
                    on_reorder_complete(ngModel.$viewValue);
                }

                function on_move_up(evt) {
                    var table_row = table_row_from_event(evt);

                    // try to find a previous row if there is one
                    var previous_row = angular.element(table_row).prev('tr');

                    // if there is a previous row then swap with it
                    if (previous_row.length !== 0) swap_rows(table_row, previous_row.get(0), false);

                    // call callback
                    on_reorder_complete(ngModel.$viewValue);
                }

                function on_move_down(evt) {
                    var table_row = table_row_from_event(evt);

                    // try to find a next row if there is one
                    var next_row = angular.element(table_row).next('tr');

                    // if there is a next row then swap with it
                    if (next_row.length !== 0) swap_rows(table_row, next_row.get(0), false);

                    // call callback
                    on_reorder_complete(ngModel.$viewValue);
                }

                function on_mouse_over_row(evt) {

                    var table_row = table_row_from_event(evt);

                    // if we are not dragging anything then or the mouse is over the current dragging item return
                    if (!selected_table_row || table_row.id === selected_table_row.id) return;

                    swap_rows(selected_table_row, table_row, false);
                }

                function table_row_from_event(evt) {

                    // return the first table row element that is a parent of the click target
                    return angular.element(evt.target).parents('tr').get(0);
                }

                function swap_rows(row_one, row_two, is_hopping) {

                    // angular element wrappers
                    var wrapped_row_one = angular.element(row_one);
                    var wrapped_row_two = angular.element(row_two);

                    // get the positions of the elements within it's parent
                    var row_one_index = wrapped_row_one.index();
                    var row_two_index = wrapped_row_two.index();

                    // we need to check if the two rows are immediate siblings - if not then we need to hop each one in order
                    if (wrapped_row_one.prev('tr').attr('id') !== wrapped_row_two.attr('id') &&
                        wrapped_row_one.next('tr').attr('id') !== wrapped_row_two.attr('id')) {

                        // perform hopping action to move all rows in between up or down without reordering them
                        perform_hopping(row_one, row_two, row_one_index > row_two_index ? 'up' : 'down');

                        return;
                    }

                    // get the current ngmodel value
                    var model = ngModel.$viewValue.slice(0);

                    // get the current data of the elements
                    var row_one_data = model[row_one_index];
                    var row_two_data = model[row_two_index];

                    // swap data in array
                    model[row_one_index] = row_two_data;
                    model[row_two_index] = row_one_data;

                    // next update the model
                    ngModel.$setViewValue(model);

                    // perform render to update the 
                    ngModel.$render();

                    // call event handler if not hopping
                    if (is_hopping === false) on_reorder(model);
                }

                function perform_hopping(source_row, target_row, direction) {

                    // create wrapped elements
                    var wrapped_source_row = angular.element(source_row);

                    // keep track of progress
                    var moving_complete = false;
                    var iterator = 0;

                    // find the maximum possible number of swaps
                    var max_iteration_count = table_body.find('tr').length;

                    // we are attempting to move a row up - until the previous sibling is row two keep swapping
                    while (moving_complete === false && iterator < max_iteration_count) {

                        // get the next/previous table row
                        var sibling_row = direction === 'up' ? wrapped_source_row.prev('tr') : wrapped_source_row.next('tr');

                        // if there is no previous row then stop looping
                        if (sibling_row.length === 0) break;

                        // if the previous row matches the target row then mark as complete
                        if (sibling_row.attr('id') === target_row.id) moving_complete = true;

                        // otherwise swap the two rows
                        swap_rows(source_row, sibling_row.get(0), !moving_complete);

                        // keep track of iteration count to avoid infinite loop
                        iterator++;
                    }

                }

                function clear_selection() {
                    // unhighlight any text that may be selected - often happens when dragging
                    if (document.selection) document.selection.empty();
                    else if (window.getSelection) window.getSelection().removeAllRanges();
                }
            }
        };
    }
})();;
(function () {
  angular.module("hpe.elements.sankey", ["hpe.elements.templates"]);
})();;
(function () {

  angular.module("hpe.elements.sankey").directive("sankey", sankey);

  sankey.$inject = ['d3Sankey', '$timeout', '$compile', '$window'];

  function sankey(d3Sankey, $timeout, $compile, $window) {
    return {
      restrict: "E",
      scope: {
        chartSize: '=?',
        chartData: '=',
        options: '=',
        click: '=?'
      },
      templateUrl: "sankey/template/sankey.html",
      link: function (scope, element) {
        var vm = scope;
        var initialRender = true;
        var isDestroyed = false;

        var chartContainer = element.find('div.sankey');

        //record original width and height so we know if if changes
        var width = chartContainer[0].offsetWidth;
        var height = chartContainer[0].offsetHeight;

        //prepare event to be fired every time repaint occurs
        $window.requestAnimFrame = (function () {
          return $window.requestAnimationFrame || $window.webkitRequestAnimationFrame || $window.mozRequestAnimationFrame ||
            function (callback) {
              $window.setTimeout(callback, 1000 / 60);
            };
        })();

        $timeout(function () {
          $compile(chartContainer)(vm);
        });

        if (!vm.chartSize) {
          vm.chartSize = {};
        }

        scope.$watch('chartSize', function (newVal, oldVal) {

          if (!vm.chart || !angular.equals(newVal, oldVal)) {
            chartContainer.height(vm.chartSize.height);
            chartContainer.width(vm.chartSize.width);

            reloadChart();
          }
        }, true);

        scope.$watch('chartData', function (newVal, oldVal) {
          if (!angular.equals(newVal, oldVal)) {
            reloadChart();

          }
        }, true);

        //when destroyed we need to stop the resize loop
        scope.$on('$destroy', function () {
          isDestroyed = true;
        });


        //start out resize checks
        checkForResize();

        function checkForResize() {
          //if width or height changed then redraw
          if (width !== chartContainer[0].offsetWidth || height !== chartContainer[0].offsetHeight) {

            //store new size values
            width = chartContainer[0].offsetWidth;
            height = chartContainer[0].offsetHeight;

            //reload and redraw
            reloadChart();
          }
          //continue looping until control has been destroyed
          if (!isDestroyed) {
            $window.requestAnimFrame(checkForResize);
          }
        }

        function reloadChart() {

          var createSankey = function () {
            chartContainer.find('svg').remove();
            chartContainer.find('div').remove();

            if (!vm.chartData) {
              return;
            }

            var options = vm.options ? vm.options : {};
            vm.chart = d3Sankey.getChart(chartContainer)
              .init(options, vm.click)
              .draw(angular.copy(vm.chartData));

            $timeout(function () {
              $compile(chartContainer)(vm);
            });
          };

          //on the first render we need a delay to ensure fonts have loaded so truncation can be correctly calculated
          if (initialRender) {

            //delay before drawing
            $timeout(createSankey);

            //set initial render state
            initialRender = false;
          } else {
            createSankey();
          }
        }
      }
    };
  }


})();;
(function () {

	angular.module("hpe.elements.sankey").factory('d3Sankey', d3Sankey);

	function d3Sankey() {
		var service = {
			getChart: getChart
		};

		return service;

		function getChart($container) {
			return new Sankey($container);
		}
	}

	/**
	 * Sankey charting
	 *
	 *  Supported Option Properties:
	 *  =============================
	 * 	var defaultChartOptions = {
	 *    paddingX: 30,										// padding on first col left-edge and last col right-edge
	 *		linkHoverHL: true,							// whether to do link hover highlight
	 *		col: {
	 *				headerHeight: 60,
	 *				headerLabelSpacing: 10,
	 *				headerLabelLength: 18,
	 *				paddingTop: 30,
	 *				paddingBottom: 30
	 *			},
	 *			block:{
	 *				minHeight: 70,								// minimum node height
	 *				minWidth: 100,								// minimum node width
	 *				spacingY: 15,									// vertical space between nodes
	 *				paddingX: 10,									// horizontal padding inside a node
	 *				paddingY: 7,									// veritcal padding inside a node
	 *				calloutData: {								// data to display inside a node
	 *					topLeft: {									// Settings for data  to be shown in the top-left corner, if needed
	 *						key: 'datasize',					// the property of the node item to be shown
	 *						nodeLabel: false,					// is the data to be shown as node label (i.e., not values with unit and label). If true, the valueUnit and label settings will be ignored.
	 *						defaultShow: true,				// 'true' to always show the data, 'false' to only show the data on node hover highlight.
	 *						valueUnit: 'b',						// the unit for the data, e.g., 'b' for byte in '80Mb'. Will be ignored if 'nodeLabel=true'
	 *						label: 'data'							// the label of the data. . Will be ignored if 'nodeLabel=true'
	 *					},
	 *					bottomLeft: {								// Settings for data  to be shown in the bottom-left corner, if needed
	 *						...
	 *			  	},
	 *					topRight: {									// Settings for data  to be shown in the top-right corner, if needed
	 *						...
	 *			  	},
	 *					bottomRight: {							// Settings for data  to be shown in the bottom-right corner, if needed
	 *						...
	 *			  	}
	 *			  }
	 *			}
	 *	 }
	 *
	 *
	 */

	var defaultChartOptions = {
		paddingX: 30,
		linkHoverHL: true,
		col: {
			headerHeight: 60,
			headerLabelSpacing: 10,
			paddingTop: 30,
			paddingBottom: 30
		},
		linkTooltip: {
			show: true,
			label: 'items'
		},
		block: {
			minHeight: 70,
			minWidth: 100,
			spacingY: 15,
			paddingX: 10,
			paddingY: 7,
			calloutData: {
				topLeft: {
					key: 'datasize',
					nodeLabel: false,
					defaultShow: true,
					valueUnit: 'b',
					binary: false,
					label: 'data'
				},
				topRight: {
					key: 'value',
					nodeLabel: false,
					defaultShow: true,
					valueUnit: null,
					label: 'items'
				},
				bottomRight: {},
				bottomLeft: {
					key: 'name',
					nodeLabel: true,
					defaultShow: true
				}
			}
		},
		overflow: {
			tooltip: {
				label: 'items',
				showTooltip: true
			}
		}
	};

	var hover_hl_delay = 10;

	function Sankey($container) {
		this.$container = $container;
		this.element = $container[0];
		this.width = this.element.clientWidth;
		this.height = this.element.clientHeight;
		this.cols = [];
		this.blocks = [];
		this.links = [];
		this.overflows = [];
		this.options = {};
		this.clickFn = null;
		this.inited = false;
	}


	Sankey.prototype.init = function (options, click) {
		var chart = this;

		chart.options = $.extend(true, defaultChartOptions, options);
		if (click) {
			chart.clickFn = function (scope, node) {
				return click(node.currentTarget.__data__);
			};
		}
		chart.inited = true;

		if (chart.options.showColNumber === undefined) {
			chart.options.showColNumber = false;
			chart.options.col.headerLabelSpacing = 0;
		} else {
			if (chart.options.showColNumber === false) {
				chart.options.col.headerLabelSpacing = 0;
			}
		}

		chart.colPrefix = "elements-sankey-";

		return chart;
	};

	Sankey.prototype.draw = function (dataset) {
		var chart = this;

		if (!chart.inited) {
			chart.init({});
		}

		chart._loadColumns(dataset.columns)
			._loadBlocks(dataset.nodes)
			._loadLinks(dataset.links)
			._calculateLayout();

		chart.tooltip = d3.select(chart.element).append("div")
			.attr("class", "tooltip hidden");

		var svg = d3.select(chart.element).append("svg")
			.attr("width", chart.width)
			.attr("height", chart.height)
			.attr("viewBox", [0, 0, chart.width, chart.height].join(' '));

		//add gradient
		var defs = svg.append("defs");
		var overflowGradient = defs.append("linearGradient");
		overflowGradient.attr("id", "overflowGradient")
			.attr("x1", "0%")
			.attr("y1", "0%")
			.attr("x2", "0%")
			.attr("y2", "100%");
		overflowGradient.append("stop")
			.attr("class", "stop1")
			.attr("offset", "25%");
		overflowGradient.append("stop")
			.attr("class", "stop2")
			.attr("offset", "100%");

		var nodeGradient = defs.append("linearGradient");
		nodeGradient.attr("id", "nodeGradient")
			.attr("x1", "0%")
			.attr("y1", "0%")
			.attr("x2", "0%")
			.attr("y2", "100%");
		nodeGradient.append("stop")
			.attr("class", "stop1")
			.attr("offset", "0%");
		nodeGradient.append("stop")
			.attr("class", "stop2")
			.attr("offset", "100%");


		chart._drawColumns(svg);
		chart._drawBlocks(svg);
		chart._drawLinks(svg);
		chart._drawOverflows(svg);

		return chart;
	};

	Sankey.prototype._loadColumns = function (columns) {
		var chart = this;
		chart.colsDef = d3.map(columns, function (d) {
			return d.id;
		});

		return chart;
	};

	Sankey.prototype._loadBlocks = function (nodes) {
		var chart = this;
		chart.blocks = nodes;

		chart.cols = d3.nest()
			.key(function (d) {
				return chart.colsDef.get(d.type).ordinal;
			})
			.sortKeys(d3.ascending)
			.rollup(function (leaves) {
				var col = {
					name: leaves && leaves[0] ? chart.colsDef.get(leaves[0].type).name : '',
					nodes: leaves,
					width: 0,
					x: 0
				};

				return col;
			})
			.entries(nodes);

		return chart;
	};

	Sankey.prototype._loadLinks = function (links) {
		var chart = this;

		chart.links = links;

		//assosciate links with the blocks
		links.forEach(function (link) {
			var block = chart.blocks.filter(function (block) {
				return block.id === link.source;
			})[0];
			var exit = block.exit || [];
			exit.push(link);
			block.exit = exit;
			link.sourceData = block;

			block = chart.blocks.filter(function (block) {
				return block.id === link.target;
			})[0];

			var enter = block.enter || [];
			enter.push(link);
			block.enter = enter;
			link.targetData = block;
		});

		return chart;

	};

	Sankey.prototype._calculateLayout = function () {
		var chart = this;

		chart._calculateColumnLayout();
		chart._calculateBlockLayout();
		chart._calculateLinkLayout();

		return chart;
	};

	Sankey.prototype._calculateColumnLayout = function () {
		var chart = this;

		var MIN_GRID_UNIT = 60;

		var numOfCols = chart.cols.length;

		var colGridUnit = (chart.width - (chart.options.paddingX * 2)) / ((numOfCols * 4.5) - 2);
		if (colGridUnit < MIN_GRID_UNIT) {
			colGridUnit = MIN_GRID_UNIT;
		}

		//get block min width
		var minBlockWidth = chart.options.block.minWidth;

		chart.blockWidth = colGridUnit * 2.5;
		chart.blockSpacing = colGridUnit * 2;

		var colWidth = chart.blockWidth + chart.blockSpacing;

		//ensure that the block width is acceptable
		if (chart.blockWidth < minBlockWidth) chart.blockWidth = minBlockWidth;

		//count the number of inner and outer columns
		var innerCols = (numOfCols - 2) < 0 ? 0 : numOfCols - 2;
		var outerCols = (numOfCols > 2) ? 2 : numOfCols;

		//calculate the projected width
		var projectedWidth = ((colWidth - colGridUnit + chart.options.paddingX) * innerCols) + (colWidth * outerCols);

		//projected width is greater than contain width then we need to try and resize
		if (projectedWidth > chart.element.offsetWidth) {

			//calculate how much we need to reduce by
			var shrinkAmount = projectedWidth - chart.element.offsetWidth;

			//how much would be need to shrink each block
			var blockShrink = shrinkAmount / numOfCols;

			//shrink each block as much as possible
			chart.blockWidth -= blockShrink;

			//ensure that the block width is acceptable
			if (chart.blockWidth < minBlockWidth) chart.blockWidth = minBlockWidth;

			//recalculate colWidth
			colWidth = chart.blockWidth + chart.blockSpacing;
		}

		var maxX = 0;
		chart.cols.colBlockX = [];
		chart.cols.forEach(function (obj, i) {
			var col = obj.values;
			col.width = (i !== 0 && i !== numOfCols - 1) ? colWidth : colWidth - colGridUnit + chart.options.paddingX;
			col.x = (i > 0) ? i * colWidth - colGridUnit + chart.options.paddingX : 0;

			maxX += col.width;

			chart.cols.colBlockX[i] = chart.options.paddingX + i * (chart.blockWidth + chart.blockSpacing);

		});

		if (maxX > chart.element.offsetWidth) {

			chart.width = maxX;
			chart.$container.css("overflow-x", "auto");

		} else {
			chart.width = chart.element.offsetWidth;
			chart.$container.css("overflow-x", "initial");
		}

	};

	Sankey.prototype._calculateBlockLayout = function () {
		var chart = this;

		chart.blocks.forEach(function (block) {
			var colId = chart.colsDef.get(block.type).ordinal;

			block.enter = block.enter || [];
			block.exit = block.exit || [];
			block.x = chart.cols.colBlockX[colId];
			//width
			block.width = chart.blockWidth;
			//calculate the total data, if not available
			if (typeof block.value === "undefined") {
				var total = 0;
				if (block.enter && block.enter.length) {
					block.enter.forEach(function (link) {
						total += link.value;
					});
				} else if (block.exit) {
					block.exit.forEach(function (link) {
						total += link.value;
					});
				}
				block.value = total;
			}
		});

		//Get the highest sum total across each column; we'll use this to determine a normalised height for each block
		var colTotals = [];
		chart.cols.forEach(function (col, colIndex) {
			colTotals[colIndex] = d3.sum(col.values.nodes, function (n) {
				return n.value;
			});
		});
		var maxColTotal = d3.max(colTotals, function (ct) {
			return ct;
		});

		var maxTotalNum = d3.max(chart.cols, function (d) {
			return d.values.nodes.length;
		});
		var availableMaxHeight = (chart.height - chart.options.col.headerHeight - chart.options.col.paddingTop - chart.options.col.paddingBottom - ((maxTotalNum - 1) * chart.options.block.spacingY));
		var maxHeight = d3.max([chart.options.block.minHeight, availableMaxHeight / maxTotalNum]);

		var maxBlockY = 0;
		//ok now try and calculate the y and height of the blocks

		chart.cols.forEach(function (col) {
			var nodes = col.values.nodes;

			//keep track of y
			var currenty = chart.options.col.headerHeight + chart.options.col.paddingTop;

			var maxExtraSpacingPerBlock = (maxTotalNum * chart.options.block.spacingY);

			//This part is important for keeping the heights of columns with the same total consistent with each other
			//If there is more than one node in the column, remove some height from each node proportionate to
			//the number of codes in the column and the extra space needed for the vertical spacing.
			var maxExtraSpacingForColumn = ((nodes.length - 1) * chart.options.block.spacingY);
			//i.e. when this value is non-zero
			if (maxExtraSpacingForColumn) {
				//determine how much each block needs to be reduced by
				maxExtraSpacingForColumn = maxExtraSpacingForColumn / nodes.length;
			}

			//In the following, "overflow" refers to a block which had its size increased above the calculated value

			//overflowHeight = the difference between a block's calculated height and the minHeight where the calculated height was too small
			col.overflowHeight = [];
			//nonOverflowHeight = the calculated blockheights where it was above the minHeight
			col.nonOverflowHeight = [];

			nodes.forEach(function (block, index) {
				//calculate height
				var blockPercentOfColTotal = (block.value / maxColTotal);
				//The block's value as a percentage of the available space
				var proposedHeight = (blockPercentOfColTotal * (availableMaxHeight - maxExtraSpacingPerBlock)) - maxExtraSpacingForColumn;

				//Record whether this height was usable or not and keep a running total
				block.proposedHeight = proposedHeight;
				if (proposedHeight < chart.options.block.minHeight) {
					col.overflowHeight[index] = chart.options.block.minHeight - proposedHeight;
				} else {
					col.nonOverflowHeight[index] = proposedHeight;
				}
			});

			col.overflowHeight.total = d3.sum(col.overflowHeight);
			col.nonOverflowHeight.total = d3.sum(col.nonOverflowHeight);


			nodes.forEach(function (block, index) {

				//Adjust node scaling to accomodate nodes enlargened to the min size
				if (col.overflowHeight.length && !col.overflowHeight[index]) {
					//to be precise this node's sizing was fine
					//but it must be adjusted regardless to accommodate the ones which had to be increased up to the minHeight
					var blockPercentageOfBlocksAboveMinHeight = (block.proposedHeight / col.nonOverflowHeight.total);
					var totalMinHeightOverflowToRedistribute = col.overflowHeight.total;
					block.proposedHeight -= blockPercentageOfBlocksAboveMinHeight * totalMinHeightOverflowToRedistribute;
				}

				block.height = d3.max([block.proposedHeight, chart.options.block.minHeight]);

				block.y = currenty;
				currenty += block.height + chart.options.block.spacingY;

				maxBlockY = d3.max([maxBlockY, currenty]);
			});
		});

		maxHeight = d3.max([chart.height, maxBlockY + 20]);
		if (maxHeight > chart.height) {
			chart.height = maxHeight;
			chart.$container.css("overflow-y", "auto");
		} else {
			chart.$container.css("overflow-y", "initial");
		}

		return chart;
	};

	Sankey.prototype._calculateLinkLayout = function () {
		var chart = this;

		chart.blocks.forEach(function (block) {
			var currenty = 0;
			//do enter first
			var totalExit = 0;
			var colId = chart.colsDef.get(block.type).ordinal;

			if (block.enter && block.enter.length) {
				currenty = block.y;
				block.enter.forEach(function (link) {
					link.tr = [block.x, currenty];
					link.br = [block.x, link.tr[1] + ((link.value / block.value) * block.height)];
					currenty = link.br[1];
				});
			}
			if (block.exit && block.exit.length) {
				currenty = block.y;
				block.exit.forEach(function (link) {
					link.tl = [block.x + block.width, currenty];
					link.bl = [block.x + block.width, link.tl[1] + ((link.value / block.value) * block.height)];
					currenty = link.bl[1];

					totalExit += link.value;
				});
				//check for missed data
				//not sure i am happy with this check
				if (block.value > totalExit) {
					var overflow = {};
					var x = (block.x + block.width);
					var r = 20;
					var remainingHeight = block.y + block.height - currenty;
					overflow.path = "M" + x + "," + currenty +
						"A" + r + "," + r + " 0 0,1" +
						(x + r) + "," + (currenty + r) + " " +
						"v" + Math.max(r, remainingHeight) + "h-" + r + "Z";
					if (chart.options.overflow.tooltip.showTooltip) {
						overflow.tooltip = (block.value - totalExit) + " " + chart.options.overflow.tooltip.label;
					}
					chart.overflows.push(overflow);
				}
			} else if (colId !== chart.cols.length - 1) {
				//if there is no exit blocks
				//check if bloack is last col
				currenty = block.y;
				var blockOverflow = {};
				var blockX = (block.x + block.width);
				var blockR = 20;
				var remainingBlockHeight = block.y + block.height - currenty;
				blockOverflow.path = "M" + blockX + "," + currenty +
					"A" + blockR + "," + blockR + " 0 0,1" +
					(blockX + blockR) + "," + (currenty + blockR) + " " +
					"v" + Math.max(blockR, remainingBlockHeight) + "h-" + blockR + "Z";
				chart.overflows.push(blockOverflow);
			}
		});

		chart.links.forEach(function (link) {
			var dist = chart.blockSpacing / 2,
				tl = link.tl,
				tr = link.tr,
				br = link.br,
				bl = link.bl,
				tlcp = [tl[0] + dist, tl[1]],
				trcp = [tr[0] - dist, tr[1]],
				blcp = [bl[0] + dist, bl[1]],
				brcp = [br[0] - dist, br[1]];

			link.path = "M" + tl[0] + "," + tl[1] +
				"C" + tlcp[0] + "," + tlcp[1] +
				" " + trcp[0] + "," + trcp[1] +
				" " + tr[0] + "," + tr[1] +
				"L" + br[0] + "," + br[1] +
				"C" + brcp[0] + "," + brcp[1] +
				" " + blcp[0] + "," + blcp[1] +
				" " + bl[0] + "," + bl[1] +
				"L" + tl[0] + "," + tl[1];
		});

		return chart;

	};

	function createSVGtext(caption, x, y, classname, colNumber, dx, headerlength) {
		//  This function attempts to create a new svg "text" element, chopping
		//  it up into "tspan" pieces, if the caption is too long
		//
		var svgText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
		svgText.setAttributeNS(null, 'x', x + dx);
		svgText.setAttributeNS(null, 'y', y);

		//  The following two variables should really be passed as parameters

		var MAXIMUM_CHARS_PER_LINE = headerlength;

		var LINE_HEIGHT = 22;

		var words = caption.split(" ");
		var line = "";
		if (colNumber !== null) {
			var svgTSpan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
			svgTSpan.setAttributeNS(null, 'x', x);
			svgTSpan.setAttributeNS(null, 'y', y);
			svgTSpan.setAttributeNS(null, 'class', 'col-num');
			var tSpanTextNode = document.createTextNode(colNumber + 1);
			svgTSpan.appendChild(tSpanTextNode);
			svgText.appendChild(svgTSpan);
		}

		var truncated = false;
		var numOfRows = 0;

		for (var n = 0; n < words.length; n++) {
			var testLine = line + words[n] + " ";
			if (testLine.length > MAXIMUM_CHARS_PER_LINE) {
				if (colNumber === null) {
					if (numOfRows < 1) {
						//  Add a new <tspan> element
						var svgTextSpanElement = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
						svgTextSpanElement.setAttributeNS(null, 'x', x);
						svgTextSpanElement.setAttributeNS(null, 'y', y);
						svgTextSpanElement.setAttributeNS(null, 'dx', dx);
						svgTextSpanElement.setAttributeNS(null, 'class', classname);

						var tSpanTextElement = document.createTextNode(line);
						svgTextSpanElement.appendChild(tSpanTextElement);
						svgText.appendChild(svgTextSpanElement);

						line = words[n] + " ";
						y += LINE_HEIGHT;
					}
				}
				numOfRows = numOfRows + 1;
			} else {
				if (colNumber !== null) {
					if (numOfRows < 1) {
						line = testLine;
					}
				} else {
					line = testLine;
				}
			}
		}

		if (!truncated && numOfRows > 1) {
			line = line + "...";
			truncated = true;
		}
		var svgTextSpan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
		svgTextSpan.setAttributeNS(null, 'x', x);
		svgTextSpan.setAttributeNS(null, 'y', y);
		svgTextSpan.setAttributeNS(null, 'dx', dx);
		svgTextSpan.setAttributeNS(null, 'class', classname);
		var textSpanTextNode = document.createTextNode(line);
		svgTextSpan.appendChild(textSpanTextNode);

		svgText.appendChild(svgTextSpan);
		if (truncated) {
			svgText.setAttributeNS(null, 'tooltip', caption);
		}
		return svgText;
	}

	Sankey.prototype._drawColumns = function (svg) {
		var chart = this;

		var cols = svg.append("g").selectAll(".column")
			.data(chart.cols)
			.enter().append("g")
			.attr("class", function (d) {
				return "column " + chart.colPrefix + chart.getColumnType(d);
			});

		var colHeader = cols.append("g")
			.attr("class", "col-header");

		colHeader.append("rect")
			.attr("height", chart.options.col.headerHeight)
			.attr("width", function (d) {
				return d.values.width;
			})
			.attr("transform", function (d) {
				return "translate(" + d.values.x + "," + 0 + ")";
			})
			.on("mouseenter", function () {
				if (chart.hoverId) {
					clearTimeout(chart.hoverId);
					chart.hoverId = null;
				}
				chart.hlClearId = setTimeout(function () {
					chart._clearHover();
					chart.hlClearId = null;
				}, hover_hl_delay);
			})
			.on("mouseout", function () {
				if (chart.hlClearId) {
					clearTimeout(chart.hlClearId);
				}
			});

		var colBodyHeight = chart.height - chart.options.col.headerHeight;
		var colBody = cols.append("g")
			.attr("class", "col-body");

		colBody.append("rect")
			.attr("height", colBodyHeight)
			.attr("width", function (d) {
				return d.values.width;
			})
			.attr("transform", function (d) {
				return "translate(" + d.values.x + "," + chart.options.col.headerHeight + ")";
			})
			.on("mouseenter", function () {
				if (chart.hoverId) {
					clearTimeout(chart.hoverId);
					chart.hoverId = null;
				}
				chart.hlClearId = setTimeout(function () {
					chart._clearHover();
					chart.hlClearId = null;
				}, hover_hl_delay);
			})
			.on("mouseout", function () {
				if (chart.hlClearId) {
					clearTimeout(chart.hlClearId);
				}
			});
		var headerInnerText = [];

		cols.append("line")
			.attr("class", function (d, i) {
				return i ? "header-seperator" : '';
			})
			.attr("x1", function (d) {
				return d.values.x;
			})
			.attr("y1", "0")
			.attr("x2", function (d, i) {
				if (chart.options.showColNumber) {
					d.values.array = createSVGtext(d.values.name, chart.cols.colBlockX[i], (chart.options.col.headerHeight - chart.options.col.headerLabelLength - 10), "col-title", i, chart.options.col.headerLabelSpacing, chart.options.col.headerLabelLength);
				} else {
					d.values.array = createSVGtext(d.values.name, chart.cols.colBlockX[i], (chart.options.col.headerHeight - chart.options.col.headerLabelLength - 10), "col-title", null, chart.options.col.headerLabelSpacing, chart.options.col.headerLabelLength);
				}

				headerInnerText.push(new Array(d.values.array.childNodes));
				return d.values.x;
			})
			.attr("y2", chart.height);

		headerInnerText.forEach(function (val) {
			val.forEach(function () {
				colHeader.append(function (d) {
						return d.values.array;
					})
					.attr("class", "header-text")
					.attr("x", function (d, i) {
						return chart.cols.colBlockX[i];
					})
					.attr("y", chart.options.col.headerHeight - chart.options.col.headerLabelLength);
			});
		});
	};

	Sankey.prototype._drawBlocks = function (svg) {
		var chart = this;

		var node = svg.append("g").selectAll(".node")
			.data(chart.blocks)
			.enter().append("g")
			.attr("class", "node")
			.attr("transform", function (d) {
				return "translate(" + d.x + "," + d.y + ")";
			})
			.each(function (d) {
				d.element = this;
			});

		node.append("rect")
			.attr("class", "node-body")
			.attr("height", function (d) {
				return d.height;
			})
			.attr("width", function (d) {
				return d.width;
			})
			.on("mouseover", function (d) {
				if (!d3.select(this.parentNode).classed("target-node")) {
					chart.hoverId = setTimeout(function () {
						var hlNodes = d3.selectAll('.target-node').selectAll('.hover');
						if (hlNodes.length > 0 && hlNodes[0].parentNode) {
							chart._hoverBlock(hlNodes[0].parentNode.__data__, false);
						}
						chart._hoverBlock(d, true);
						chart.hoverId = null;
					}, hover_hl_delay);
				}
			})
			.on("mouseout", function (d) {
				var coords = d3.mouse(this);
				var mouseX = Math.floor(coords[0]);
				var mouseY = Math.floor(coords[1]);

				var xOut = mouseX <= 0 || mouseX >= Math.floor(d.width);
				var yOut = mouseY <= 0 || mouseY >= Math.floor(d.height);

				if (xOut || yOut) {
					if (chart.hoverId) {
						clearTimeout(chart.hoverId);
						chart.hoverId = null;

					} else {
						chart._clearHover();
					}
				}
			});

		var calloutOptions = chart.options.block.calloutData;
		if (calloutOptions.topLeft && calloutOptions.topLeft.key) {
			chart._addCalloutData(calloutOptions.topLeft, node, true, true);
		}

		if (calloutOptions.topRight && calloutOptions.topRight.key) {
			chart._addCalloutData(calloutOptions.topRight, node, false, true);
		}

		if (calloutOptions.bottomLeft && calloutOptions.bottomLeft.key) {
			chart._addCalloutData(calloutOptions.bottomLeft, node, true, false);
		}

		if (calloutOptions.bottomRight && calloutOptions.bottomRight.key) {
			chart._addCalloutData(calloutOptions.bottomRight, node, false, false);
		}

		if (chart.clickFn) {
			node.attr("ng-click", "chart.clickFn(this, $event)");
		}
		return chart;

	};

	Sankey.prototype.getColumnFromBlock = function (svg, nodeType) {
		var chart = this;
		var cols = chart.cols;

		var col = null;
		cols.some(function (nodeLists, colIndex) {
			return nodeLists.values.nodes.some(function (node) {
				if (node.type === nodeType) {
					col = cols[colIndex];
				}
				return (node.type === nodeType);
			});
		});

		return col;
	};

	Sankey.prototype.getColumnType = function (col) {
		if (col && col.values) {
			if (col.values.nodes && col.values.nodes.length) {
				return col.values.nodes[0].type;
			}

		}
		return "";
	};


	Sankey.prototype.truncateText = function (node) {

		//if we have no text then return
		if (!node.name) return node.name;

		//get block name
		var textElement = d3.select(this);

		//set the text to the node name
		textElement.text(node.name);

		//padding text should be from left and right
		var paddingLeft = 10;
		var paddingRight = 10;

		//get text node
		var textNode = d3.select(this).node();

		//required because if element isnt in visible DOM IE will throw and error - animations wont work
		if (!document.body.contains(textNode)) return;

		//calculate text width
		var textLength = textNode.getComputedTextLength();

		//get block width
		var blockWidth = node.width;

		//maximum text size - take padding into account
		var maxTextLength = blockWidth - (paddingLeft + paddingRight);

		if (textLength > maxTextLength) {

			//store current shortened text
			var shortenedText = node.name;

			//we need to ellipsis text
			while (textLength > maxTextLength && shortenedText.length > 0) {
				shortenedText = shortenedText.slice(0, -1);
				textElement.text(shortenedText + '...');
				textLength = textNode.getComputedTextLength();
			}

			//add tooltip to element
			$(this).attr('tooltip', node.name);

			//return shortenedText (plus ellipsis) is truncation is required.
			return shortenedText + '...';
		}

		//return original string if no truncation required
		return node.name;
	};

	Sankey.prototype._addCalloutData = function (calloutOption, svgNode, isLeft, isTop) {
		var chart = this;

		var dataText = svgNode.append("text");
		var classes;
		if (calloutOption.nodeLabel) {
			classes = isLeft ? "node-label node-label-left" : "node-label node-label-right";
			dataText.text(function (d) {
				return d[calloutOption.key];
			});

		} else {
			classes = isLeft ? "callout callout-left" : "callout callout-right";

			var valuesMedian = d3.median(chart.blocks, function (block) {
				return block[calloutOption.key];
			});
			var valueUnitPrefix = calloutOption.binary ? chart._formatBinaryPrefix(valuesMedian) : d3.formatPrefix(valuesMedian, 1);

			var dy = isTop ? '1.1em' :
				calloutOption.label ? '-1.1em' : '-' + chart.options.block.paddingY + 'px';

			if(calloutOption.click) {
				dataText.on("click", function(data) {
				    d3.event.stopPropagation();
				    calloutOption.click(data);
				});		
			}

			dataText.append("tspan")
				.attr("class", "callout-value")
				.attr("dy", dy)
				.text(function (d) {
					var val = d3.round(valueUnitPrefix.scale(d[calloutOption.key]));
					if (val > 0) {
						if (angular.isFunction(calloutOption.valueFormatter)) {
							var formattedValue = calloutOption.valueFormatter(val);
							return angular.isDefined(formattedValue) ? formattedValue : val;
						}
						return val;
					}
					return "\ufe64" + 1;
				});

			var unit = valueUnitPrefix.symbol;
			if (calloutOption.valueUnit) {
				unit += calloutOption.valueUnit;
			}
			dataText.append("tspan")
				.attr("class", "callout-unit")
				.text(unit);

			if (calloutOption.label) {
				dy = '0.9em';
				var labelText = dataText.append("tspan")
					.attr("class", "callout-label")
					.attr("dy", dy)
					.text(calloutOption.label);

				if (isLeft) {
					labelText.attr("x", chart.options.block.paddingX);
				} else {
					labelText.attr("x", function (d) {
						return d.width - chart.options.block.paddingX;
					});
				}
			}
		}

		if (!calloutOption.defaultShow) {
			classes += ' default-hide';
		}

		dataText.attr("class", classes);
		if (isLeft) {
			dataText.attr("x", chart.options.block.paddingX);
		} else {
			dataText.attr("x", function (d) {
				return d.width - chart.options.block.paddingX;
			});
		}

		if (calloutOption.nodeLabel) {
			if (isTop) {
				dataText.attr("y", chart.options.block.paddingY);
			} else {
				dataText.attr("y", function (d) {
					return d.height - chart.options.block.paddingY;
				});
			}
			dataText.each(chart.truncateText);
		} else {
			if (isTop) {
				dataText.attr("y", 0);
			} else {
				dataText.attr("y", function (d) {
					return d.height;
				});
			}

		}

		return chart;

	};

	Sankey.prototype._formatBinaryPrefix = function (valuesMedian) {
		var result = {
			symbol: ""
		};
		if (valuesMedian < 1024) {
			result.symbol = "";
		} else if (valuesMedian < 1024 * 1024) {
			result.symbol = "k";
		} else if (valuesMedian < 1024 * 1024 * 1024) {
			result.symbol = "M";
		} else if (valuesMedian < 1024 * 1024 * 1024 * 1024) {
			result.symbol = "G";
		} else if (valuesMedian < 1024 * 1024 * 1024 * 1024 * 1024) {
			result.symbol = "T";
		} else if (valuesMedian < 1024 * 1024 * 1024 * 1024 * 1024 * 1024) {
			result.symbol = "P";
		} else if (valuesMedian < 1024 * 1024 * 1024 * 1024 * 1024 * 1024 * 1024) {
			result.symbol = "E";
		}
		result.scale = function (v) {
			switch (result.symbol) {
				case "k":
					return v / 1024;
				case "M":
					return v / 1024 / 1024;
				case "G":
					return v / 1024 / 1024 / 1024;
				case "T":
					return v / 1024 / 1024 / 1024 / 1024;
				case "P":
					return v / 1024 / 1024 / 1024 / 1024 / 1024;
				case "E":
					return v / 1024 / 1024 / 1024 / 1024 / 1024 / 1024;
			}
			return v;
		};
		return result;
	};

	Sankey.prototype._drawLinks = function (svg) {
		var chart = this;

		var link = svg.append("g").selectAll(".link")
			.data(chart.links)
			.enter().append("path")
			.attr("class", "link")
			.attr("title", function (d) {
				if (chart.options.linkTooltip.show) {
					return d.value + " " + chart.options.linkTooltip.label;
				} else return "";
			})
			.attr("d", function (d) {
				return d.path;
			})
			.each(function (d) {
				d.element = this;
			})
			.sort(function (a, b) {
				return b.height - a.height;
			});
		link.forEach(function (l) {
			$(l).tooltip({
				container: 'body',
				html: true,
				template: '<div class="tooltip linkTooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
				animation: false,
				delay: 0

			});
		});
		if (chart.options.linkHoverHL) {
			link.on("mouseover", function (d) {

					if (chart.options.linkTooltip.show) {

						var tooltipWidth = 0,
							tooltipHeight = 0;
						var tooltip = $('body').find('.tooltip.linkTooltip.top.in');
						//if condition to avoid width being undefined, when movement is rapid that it goes over the tooltip
						if ($(tooltip).length > 0) {
							tooltipWidth = $(tooltip)[0].offsetWidth;
							tooltipHeight = $(tooltip)[0].offsetHeight;
						}
						var mousePos = {
							x: -1,
							y: -1
						};

						$(document).mousemove(function (event) {
							mousePos.x = event.pageX;
							mousePos.y = event.pageY;
							if ($(tooltip).length > 0) {
								$(tooltip)[0].style.top = mousePos.y - tooltipHeight + "px";
								$(tooltip)[0].style.left = mousePos.x - (tooltipWidth / 2) + "px";
							}
						});
					}
					chart.hoverId = setTimeout(function () {
						chart._hoverLink(d, true);
						chart.hoverId = null;
					}, hover_hl_delay);
				})
				.on("mouseout", function () {

					if (chart.options.linkTooltip.show) {
						//Stop tracking mousemove (which was enabled for link tooltips)
						$(document).off("mousemove");
					}
					if (chart.hoverId) {
						clearTimeout(chart.hoverId);
						chart.hoverId = null;
					} else {
						chart._clearHover();
					}
				});
		}

		return chart;
	};

	Sankey.prototype._drawOverflows = function (svg) {
		var chart = this;

		svg.append("g").selectAll(".overflow")
			.data(chart.overflows)
			.enter().append("path")
			.attr("class", "overflow")
			.style("stroke-width", 0)
			.attr("d", function (d) {
				return d.path;
			})
			.attr("tooltip", function (d) {
				return d.tooltip || "";
			})
			.style("fill", "url(#overflowGradient)");

		return chart;
	};


	Sankey.prototype._hoverBlock = function (block, classed) {
		var chart = this;
		chart._clearHover();

		d3.select(block.element).classed("hover", classed).classed("target-node", classed);

		block.enter.concat(block.exit).forEach(function (link) {
			if (link.targetData) {
				var node = d3.select(link.targetData.element).classed("hover", classed);
				if (link.targetData !== block) {
					node.classed("link-node", classed);
				}
			}
			if (link.sourceData) {
				var linkNode = d3.select(link.sourceData.element).classed("hover", classed);
				if (link.sourceData !== block) {
					linkNode.classed("link-node", classed);
				}
			}
			d3.select(link.element).classed("hover", classed);
		});

		//chart.colPrefix
		var hoverCol = $("." + chart.colPrefix + block.type);
		var colClass = hoverCol.attr("class");
		hoverCol.attr("class", colClass + " hover");

		return chart;

	};

	Sankey.prototype._hoverLink = function (link, classed) {
		var chart = this;
		chart._clearHover();

		d3.select(link.element).classed("hover", classed);
		if (link.targetData) {
			d3.select(link.targetData.element).classed("hover", classed).classed("link-node", classed);
		}
		if (link.sourceData) {
			d3.select(link.sourceData.element).classed("hover", classed).classed("link-node", classed);
		}

		return chart;
	};

	Sankey.prototype._clearHover = function () {
		var chart = this;
		d3.selectAll("g.node").classed("hover", false).classed("target-node", false).classed("link-node", false);
		d3.selectAll("path.link").classed("hover", false);
		d3.selectAll("g.column").classed("hover", false);


		return chart;
	};

})();;
(function () {  
  angular.module("hpe.elements.scrollTop", []);
})();
;
(function () {

    angular.module("hpe.elements.scrollTop").directive("scrollTop", scrollTop);

    function scrollTop() {
        return {
            restrict: "E",
            templateUrl: "scrollTop/template/scrollTop.html",
            scope: {
                direction: '@?',
                distance: '@?'
            },
            link: function (scope, element) {

                var scrollButton = element[0].getElementsByClassName('scroll-top')[0];

                //if we are already scrolling dont do it again
                var isScrolling = false;
                var pageOffset = window.pageYOffset;

                //if a distance was set then take that into account
                if (scope.distance) {
                    scrollButton.style.bottom = scope.distance + 'px';
                }

                var onScroll = function () {

                    //if button should only appear when scrolling up
                    if (scope.direction && scope.direction === 'up') {
                        var newOffset = window.pageYOffset;

                        //on scroll up
                        if (newOffset < pageOffset && newOffset > 50) {
                            showButton();
                        } else {
                            hideButton();
                        }

                        //store new page position
                        pageOffset = newOffset;

                    } else {
                        //if button should appear when any scrolling takes place
                        pageOffset = window.pageYOffset;

                        if (pageOffset > 50) showButton();
                        else hideButton();
                    }

                };

                function scrollToTop() {

                    //if we are currently scrolling then dont do it again
                    if (isScrolling) return;

                    //set the fact we are currently scrolling
                    isScrolling = true;

                    //stop scrolling if user takes over
                    $("html, body").bind("scroll mousedown DOMMouseScroll mousewheel keyup", function (evt) {

                        //if triggered by a jscrollpane then ignore it
                        if (angular.element(evt.target).hasClass('jspScrollable')) return;

                        //stop automatic scrolling
                        $("html, body").stop();
                        isScrolling = false;
                    });

                    //perform scrolling
                    $("html,body").animate({
                            scrollTop: 0
                        }, 1000, "easeInOutQuart",
                        function () {
                            //unbind
                            $("html, body").unbind("scroll mousedown DOMMouseScroll mousewheel keyup");

                            //hide our scroll button now we are at the top
                            hideButton();

                            //allow button to be clicked again
                            isScrolling = false;
                        });

                }

                function showButton() {
                    scrollButton.style.right = '0px';
                }

                function hideButton() {
                    scrollButton.style.right = -scrollButton.offsetWidth + 'px';
                }

                //need to unbind on destroy
                element[0].addEventListener("click", scrollToTop);
                window.addEventListener("scroll", onScroll);
            }
        };
    }
})();;
(function() {  
  angular.module('hpe.elements.searchBuilder', []);
})();
;
(function () {

    angular.module('hpe.elements.searchBuilder').controller('SearchBuilderCtrl', SearchBuilderCtrl);

    SearchBuilderCtrl.$inject = ['$scope'];

    function SearchBuilderCtrl($scope) {
        var vm = this;

        //ensure the search query object is not null
        if ($scope.searchQuery === null || $scope.searchQuery === undefined) $scope.searchQuery = {};

        //allow search groups to get a components
        vm.components = $scope.components;

        //enable getting of group data
        vm.getGroupValue = function (groupName) {
            return $scope.searchQuery[groupName];
        };

        //enable setting of group data
        vm.setGroupValue = function (groupName, value) {
            $scope.searchQuery[groupName] = value;
        };
    }
})();;
(function () {

    angular.module('hpe.elements.searchBuilder').directive('searchBuilder', searchBuilder);

    function searchBuilder() {
        return {
            restrict: 'E',
            controller: 'SearchBuilderCtrl',
            controllerAs: 'sb',
            scope: {
                searchQuery: '=',
                components: '=',
                valid: '='
            }
        };
    }
})();;
(function() {

    angular.module('hpe.elements.searchBuilder').controller('SearchComponentCtrl', SearchComponentCtrl);

    SearchComponentCtrl.$inject = ['$scope'];

    function SearchComponentCtrl($scope) {
        var vm = this;

        //ensure a model object exists
        $scope.model = null;

        $scope.$watch('model', function(nv) {
            //we need to update the value at the group level
            $scope.searchGroup.updateComponentValue($scope.componentId, nv);
        });

        vm.removeComponent = function() {
            $scope.searchGroup.removeComponent($scope.componentId);
        };

    }
})();
;
(function () {

    angular.module('hpe.elements.searchBuilder').directive('searchComponent', searchComponent);

    searchComponent.$inject = ['$animate'];

    function searchComponent($animate) {
        return {
            restrict: 'E',
            controller: 'SearchComponentCtrl',
            controllerAs: 'sc',
            templateUrl: 'searchBuilder/templates/searchComponent.html',
            replace: true,
            transclude: true,
            require: ['^searchGroup'],
            link: function (scope, element, attrs, ctrl, transclude) {

                //prevent any animation on the element - reduce any lag
                $animate.enabled(false);

                //store the component id
                scope.componentId = element.parents('.field').first().attr('component-id');

                //make search group controller available to the search component controller
                scope.searchGroup = ctrl[0];

                //check if the component should have an initial value
                scope.model = scope.searchGroup.getComponentValue(scope.componentId);

                //perform manualy transclusion to provide correct scope to controller
                transclude(scope, function (clone) {
                    element.find('.component-container').append(clone);
                });

            }
        };
    }
})();;
(function () {

    angular.module('hpe.elements.searchBuilder').controller('SearchGroupCtrl', SearchGroupCtrl);

    SearchGroupCtrl.$inject = ['$scope'];

    function SearchGroupCtrl($scope) {
        var vm = this;

        vm.data = {};
        vm.components = [];
        vm.showPlaceholder = false;
        vm.maxFields = $scope.maxFields ? parseInt($scope.maxFields) : null;

        vm.addNewField = function () {

            //call the user function specified to add a field
            if (!$scope.addField) throw 'Search Builder - Add Field function required.';

            //check to ensure we have not reached the maximum number of fields
            if (vm.maxFields && vm.components.length >= vm.maxFields) return;

            var newField = $scope.addField();

            //if it returns a promise then dont do anything until resolved
            if (newField.then) {

                //show placeholder until promise has been resolved
                vm.showPlaceholder = true;

                //when field type is known
                newField.then(function (field) {

                    //create new component
                    var component = vm.findComponentByName(field.component);
                    vm.createComponent(field.id, component);

                    //hide placeholder now that promise has been resolved
                    vm.showPlaceholder = false;
                });

                //if the promise is rejected then hide the placeholder
                newField.catch(function () {
                    vm.showPlaceholder = false;
                });
            } else {

                //create new component
                var component = vm.findComponentByName(newField.component);
                vm.createComponent(newField.id, component);
            }
        };

        vm.createComponent = function (componentId, component, value) {
            vm.data[componentId] = {
                component: component.name,
                value: value ? value : null
            };

            vm.components.push({
                componentId: componentId,
                templateUrl: component.templateUrl
            });

            //keep everything up to date
            $scope.searchBuilder.setGroupValue($scope.groupId, vm.data);
        };

        vm.findComponentByName = function (componentName) {

            for (var i = 0; i < $scope.searchBuilder.components.length; i++) {
                if ($scope.searchBuilder.components[i].name === componentName) return $scope.searchBuilder.components[i];
            }

            return null;
        };


        vm.removeComponent = function (componentId) {

            // if there is an remove-field function specified then call it
            if ($scope.removeField) {

                // call the function passing in the componentId
                var shouldRemove = $scope.removeField(componentId);

                // the result might be a promise
                if (shouldRemove && shouldRemove.then) {

                    // wait for promise to be resolved
                    shouldRemove.then(function (result) {

                        if (result === true) {
                            performRemoval();
                        }
                    });

                } else {
                    if (shouldRemove === undefined || shouldRemove === true) {
                        performRemoval();
                    }
                }

            } else {
                performRemoval();
            }

            function performRemoval() {

                //remove any traces of data from this component
                delete vm.data[componentId];

                for (var i = 0; i < vm.components.length; i++) {
                    if (vm.components[i].componentId === componentId) {
                        vm.components.splice(i, 1);
                        return;
                    }
                }

                //keep everything up to date
                $scope.searchBuilder.setGroupValue($scope.groupId, vm.data);
            }

        };

        vm.setInitialData = function (data) {
            //store this new data
            vm.data = data;

            //iterate each item and create appropriate control
            for (var componentId in data) {
                //get field properties
                var props = data[componentId];
                var componentName = props.component;
                var initialValue = props.value;

                //create field using the component name
                var component = vm.findComponentByName(componentName);
                vm.createComponent(componentId, component, initialValue);
            }
        };

        vm.getComponentValue = function (componentId) {
            return vm.data[componentId].value;
        };

        vm.updateComponentValue = function (componentId, value) {
            vm.data[componentId].value = value;

            //keep everything up to date
            $scope.searchBuilder.setGroupValue($scope.groupId, vm.data);
        };
    }
})();;
(function () {

    angular.module('hpe.elements.searchBuilder').directive('searchGroup', searchGroup);

    function searchGroup() {
        return {
            restrict: 'E',
            controller: 'SearchGroupCtrl',
            controllerAs: 'sg',
            templateUrl: 'searchBuilder/templates/searchGroup.html',
            replace: true,
            require: ['^searchBuilder'],
            transclude: true,
            scope: {
                groupId: '=',
                groupTitle: '=',
                operator: '=',
                buttonText: '=',
                maxFields: '=?',
                addField: '=',
                removeField: '=?'
            },
            link: function (scope, element, attr, controllers) {

                //provide access to parent controller
                scope.searchBuilder = controllers[0];

                //get any initial data if there is any
                var initialData = scope.searchBuilder.getGroupValue(scope.groupId);

                if (initialData) {
                    scope.sg.setInitialData(initialData);
                }

            }
        };
    }
})();;
(function () {
  angular.module("hpe.elements.searchToolbar", []);
})();;
(function () {

  angular.module('hpe.elements.searchToolbar').controller("searchToolbarCtrl", searchToolbarCtrl);
  searchToolbarCtrl.$inject = ["$scope"];

  function searchToolbarCtrl($scope) {
    var vm = this;

    vm.inputValue = "";
    vm.currentSearch = null;

    vm.selectTypeaheadValue = function ($item, $model, $label) {
      vm.inputValue = $label;
      vm.search();
    };

    vm.search = function () {
      if (vm.currentSearch === vm.inputValue) return;

      $scope.onSearch(vm.inputValue);
      $scope.cancelSearch();

      //store the current search
      vm.currentSearch = vm.inputValue;
    };
  }


})();;
(function () {

  angular.module("hpe.elements.searchToolbar").directive("searchToolbar", ['safeTimeout', searchToolbar]);

  function searchToolbar(safeTimeout) {
    return {
      restrict: "E",
      templateUrl: "searchToolbar/template/searchToolbar.html",
      controller: "searchToolbarCtrl as st",
      scope: {
        searchTypeahead: '=',
        placeHolder: '@',
        closeSearch: '@',
        onSearch: "=",
        onFocus: "=?"
      },

      link: function (scope, element) {
        var controller = scope.st;
        var searchIcon = element.find('.search-toolbar-icon');
        var searchContainer = element.find('.search-container');
        var input = element.find('input');
        var cancelButton = element.find('.cancel-search');
        var clearButton = element.find('.expand-input-clear');
        var onFocus = scope.onFocus || false;
        var clearIcon = element.find('.hpe-close');

        var safeTimeoutInstance = safeTimeout.create(scope);

        //expose cancel search to controller
        scope.cancelSearch = cancelSearch;

        //initially hide the search container - only show icon
        searchContainer.hide();

        //initially hide the clear icon
        clearIcon.hide();

        //when the icon is clicked show the search container and hide the icon
        searchIcon.click(showSearch);

        //when the cancel button is clicked close the search bar
        cancelButton.click(cancelSearch);

        //when the input changes update the clear button visibility
        input.on('input', function () {
          showClear();
        });


        //when the clear button is clicked clear the text
        clearButton.bind('mousedown', function (e) {
          e.preventDefault();
          input.val('');
          scope.st.inputValue = '';
          showClear();
        });

        input.blur(function () {
          safeTimeoutInstance.timeout(function () {
            cancelSearch();
          }, 100);
        });


        input.focus(function () {
          if (onFocus)
            onFocus();
        });

        input.keydown(function (event) {
          //if escape is pressed cancel search
          if (event.keyCode === 27) cancelSearch();
          //if return key is pressed perform search
          else if (event.keyCode === 13) {
            controller.search();
          }
        });

        function showSearch() {
          searchContainer.show();
          searchIcon.hide();
          input.focus();
        }

        function cancelSearch() {
          searchContainer.hide();
          searchIcon.show();
        }

        function showClear() {
          if (input.val() !== "") {
            clearIcon.show();
          } else
            clearIcon.hide();
        }
      }
    };
  }
})();;
(function () {  
  angular.module("hpe.elements.selectTable", ["hpe.elements.templates"]);
})();
;
(function () {

  angular.module("hpe.elements.selectTable").controller("selectTableCtrl", selectTableCtrl);
  selectTableCtrl.$inject = ["$timeout", "$scope", "$filter"];

  function selectTableCtrl($timeout, $scope, $filter) {
    var vm = this;

    vm.tableHeight = vm.tableHeight || "300px";
    vm.displayVals = vm.values;

    if (vm.multipleSelect) {
      vm.selected = vm.selected || [];
    }

    vm.reselectFilteredItems = vm.selectHiddenItems === "reselect";
    vm.selectFilteredItems = !(vm.selectHiddenItems === "clear" || vm.selectHiddenItems === "reselect");

    vm.previouslySelected = null;

    vm.isArrayOfObjects = angular.isDefined(vm.selectKey);

    vm.displayFn = function (value) {
      return vm.isArrayOfObjects ? value[vm.selectKey] : value;
    };

    vm.isselected = function (item) {
      var select_val = vm.selected;

      // if the selected value is a string
      if (!vm.multipleSelect) {
        return item === select_val;
      } else {
        var found = false;

        for (var i = 0; i < select_val.length; i++) {

          if (angular.equals(select_val[i], item)) {
            found = true;
            break;
          }
        }
        return found;
      }
    };

    $scope.$watch('vm.values', updateValues, true);
    $scope.$watch('vm.searchText', updateValues);

    function updateScrollbar() {

      // ensure scrollpane has been initialised
      if ($scope.pane === undefined) {
        return;
      }

      // update the scrollpane on next digest
      $timeout($scope.pane.reinitialise);
    }

    function updateValues() {

      var matchValue = {};
      matchValue[vm.selectKey] = vm.searchText;
      var hasObjectProperties = vm.values[0] !== null && typeof vm.values[0] === 'object';

      if (hasObjectProperties) {
        //it is an array of objects
        vm.displayVals = $filter('filter')(vm.values, matchValue);
      } else {
        //it is an array of strings
        vm.displayVals = $filter('filter')(vm.values, vm.searchText);
      }

      if (!vm.multipleSelect) {
        //When this flag is passed as false, we need to check if
        //the selected item is still visible, and deselect it if not.
        if (!vm.selectFilteredItems) {
          if (vm.selected && !vm.isValueVisible(hasObjectProperties, vm.selected)) {
            //record the selected value for reselection
            if (vm.reselectFilteredItems) {
              vm.previouslySelected = vm.selected;
            }
            //deselect
            vm.select(vm.selected);
          } else if (vm.reselectFilteredItems && vm.previouslySelected && !vm.selected) {
            if (vm.isValueVisible(hasObjectProperties, vm.previouslySelected)) {
              vm.select(vm.previouslySelected);
            }
          }
        }
      }

      updateScrollbar();
    }

    vm.isValueVisible = function (hasObjectProperties, value) {

      //only need to act when an item is selected
      if (value) {
        //Case where the values are an object array
        if (hasObjectProperties) {
          return vm.displayVals.some(function (element) {
            return element === value;
          });
        } else {
          //Case where the values are an array of strings
          return !!~vm.displayVals.indexOf(value);
        }
      }

    };

    vm.select = function (value, $event) {
      var mouseEvent = false;
      if ($event) {
        mouseEvent = $event.screenX || $event.screenY;
        mouseEvent = !!mouseEvent;
      }
      // if we are using multiple select, add selected value to vm.selected array. If not, just set vm.selected to be the value.
      if (!vm.multipleSelect) {
        //This is deselecting of already selected option
        if (value === vm.selected) {
          //clear selected value and index
          vm.selected = "";
          if (mouseEvent) {
            $event.currentTarget.blur();
          }
        } else {
          //This is selecting an item
          vm.selected = value;
        }
      } else {
        var notFound = true;

        for (var i = 0; i < vm.selected.length; i++) {
          if (angular.equals(vm.selected[i], value)) {
            vm.selected.splice(i, 1);
            notFound = false;
            if (mouseEvent) {
              $event.currentTarget.blur();
            }
            break;
          }
        }

        if (notFound) {
          vm.selected.push(value);
        }
      }

    };

    vm.keydown = function (e) {
      //Enter or space, trigger a click
      if (e.which === 13 || e.which === 32) {
        $timeout(function () {
          e.target.click();
        });
        e.stopPropagation();
        e.preventDefault();
      }
    };
  }
})();;
(function () {

    angular.module('hpe.elements.selectTable').directive("selectTable", selectTable);

    function selectTable() {
        return {
            restrict: 'E',
            scope: {
                values: "=",
                selected: "=",
                id: "=?",
                tableHeight: "=?",
                searchText: "=?",
                selectKey: "=?",
                multipleSelect: "=?",
                selectHiddenItems: "=?"
            },
            controller: "selectTableCtrl as vm",
            bindToController: true,
            templateUrl: "selectTable/template/selectTable.html"
        };
    }
})();;
(function () {  
  angular.module("hpe.elements.sideInset", []);
})();
;
(function () {

  angular.module("hpe.elements.sideInset").controller("SideInsetCtrl", SideInsetCtrl);

  function SideInsetCtrl() {

  }

  SideInsetCtrl.prototype.setInitialWidth = function () {
    var si = this;

    si.mainContentWidth = 100 - si.sideInsetWidth;

    si.mainElement.style.width = '100%';
    si.sidePanel.style.width = '0%';

    if (si.position.right) {
      delete si.toggleButton.style.left;
      si.toggleButton.style.right = 0;
    } else if (si.position.left) {
      delete si.toggleButton.style.right;
      si.toggleButton.style.left = 0;
    }


    si.icon = si.position.right ? 'hpe-previous' : 'hpe-next';
    si.panelOpen = false;
  };

  SideInsetCtrl.prototype.setExpandedWidth = function () {
    var si = this;
    si.mainElement.style.width = si.mainContentWidth + '%';
    var sidePanelWidth = 100 - si.mainContentWidth;
    si.sidePanel.style.width = (sidePanelWidth) + '%';

    si.icon = si.position.right ? 'hpe-next' : 'hpe-previous';
    si.panelOpen = true;
  };

  SideInsetCtrl.prototype.togglePanel = function () {
    var si = this;
    if (si.panelOpen) {
      si.setInitialWidth();
    } else {
      si.setExpandedWidth();
    }
  };

})();;
(function () {

  angular.module("hpe.elements.sideInset").directive("sideInset", sideInset);

  sideInset.$inject = ["$compile"];

  function sideInset($compile) {
    return {
      restrict: "A",
      scope: {
        sideInsetWidth: "@?",
        sideInsetButtonTop: "@?"
      },
      link: function (scope, element) {

        scope.si.position = {};
        var positionClass = "";

        var childElements = element.children();

        //The side panel will appear on the left if it comes before the main content in the HTML, or on the right if it comes after.
        if (childElements.length) {
          if (!!~childElements[0].className.indexOf("side-inset")) {
            positionClass = "left";
          } else if (childElements.length > 1 && !!~childElements[1].className.indexOf("side-inset")) {
            positionClass = "right";
          } else {
            console.error("Required side-inset div was not found in sideInset directive.");
          }
        }
        scope.si.position[positionClass] = true;

        //The toggle button's vertical position is configurable since it is relative to the main content's height.
        var toggleButtonTop = '0px';
        if (scope.sideInsetButtonTop) {
          toggleButtonTop = scope.sideInsetButtonTop || toggleButtonTop;
        }

        //The width that the side panel will take is configurable.
        scope.si.sideInsetWidth = scope.sideInsetWidth || 20;

        if (scope.si.sideInsetWidth < 0 || scope.si.sideInsetWidth > 100) {
          console.error("SideInsetWidth must be between 0 and 100");
          return;
        }

        element.addClass("wrapper-side-inset");

        //Add the toggle button
        var template = "<div class='side-inset-toggle " + positionClass + "' ng-click='si.togglePanel()'>";
        template += "<a class='hpe-icon {{si.icon}}'></a>";
        template += "</div>";
        var toggleButton = angular.element(template);
        $compile(toggleButton)(scope);

        var mainContent = element.find('.main-content');
        var sideInset = element.find('.side-inset');

        mainContent.prepend(toggleButton);

        var styles = {
          transition: 'width 0.4s cubic-bezier(0.4, 0, 0.2, 1)',
          float: 'left',
          margin: 0
        };
        var mainContentSpecificStyles = {
          position: 'relative'
        };
        var sideSpecificStyles = {
          overflow: 'hidden'
        };
        var toggleButtonSpecificStyles = {
          position: 'absolute',
          transition: 'right 0.4s cubic-bezier(0.4, 0, 0.2, 1)',
          top: toggleButtonTop,
          zIndex: 1
        };

        angular.extend(mainContent[0].style, styles, mainContentSpecificStyles);
        angular.extend(sideInset[0].style, styles, sideSpecificStyles);
        angular.extend(toggleButton[0].style, toggleButtonSpecificStyles);

        //Save the elements on the controller
        scope.si.mainElement = mainContent[0];
        scope.si.sidePanel = sideInset[0];
        scope.si.toggleButton = toggleButton[0];

        scope.si.setInitialWidth();
      },
      controller: "SideInsetCtrl as si"
    };
  }
})();;
(function () {
  angular.module("hpe.elements.sideModal", ["hpe.elements.templates"]);
})();;
(function () {

  angular.module('hpe.elements.sideModal').directive('sideModalDialog', sideModalDialog);
  sideModalDialog.$inject = ["sideModalFactory", "$modal"];

  function sideModalDialog(sideModalFactory) {
    return {
      restrict: 'A',
      templateUrl: "sideModal/sideModalDialog/template/sideModalDialog.html",
      replace: 'true',
      link: function (scope) {
        scope.modalOpt = sideModalFactory.getOptions();
        scope.closeModal = function () {
          sideModalFactory.close();
        };
        scope.dismissModal = function () {
          sideModalFactory.dismiss();
        };
      }
    };
  }
})();;
(function () {

  angular.module('hpe.elements.sideModal').factory('sideModalFactory', sideModalFactory);
  sideModalFactory.$inject = ["$modal"];

  function sideModalFactory($modal) {
    var modalFactory = {};
    var modalOptions, modalInstance;

    modalFactory.open = function (options) {
      modalOptions = options;
      modalInstance = $modal.open({
        template: "<div></div>",
        animation: false,
        keyboard: 'true',
        windowTemplateUrl: "sideModal/sideModalWindow/template/sideWindowDialog.html"
      });
    };

    modalFactory.getOptions = function () {
      return modalOptions;
    };

    modalFactory.close = function () {
      modalInstance.close('true');
    };

    modalFactory.dismiss = function () {
      modalInstance.dismiss('cancel');
    };

    return modalFactory;
  }
})();;
(function () {

  angular.module('hpe.elements.sideModal').directive('sideModalWindow', sideModalWindow);
  sideModalWindow.$inject = ["sideModalFactory"];

  function sideModalWindow(sideModalFactory) {
    return {
      restrict: 'A',
      scope: {
        sideModalWindow: "="
      },
      link: function (scope, element) {
        element.on('click', function () {
          sideModalFactory.open(scope.sideModalWindow);
        });
      }
    };
  }
})();;
(function () {

  angular.module('hpe.elements.sideNavigation', []).directive("sideNavigation", sideNavigation);

  /**
   * sideNavigation - Directive to run metsiMenu on sidebar navigation
   */
  function sideNavigation() {
    return {
      restrict: 'A',
      scope: {
        loaded: '@sideNavigation',
        autoCollapse: '@?autoCollapse'
      },
      link: function (scope, element, attributes) {

        if (typeof scope.loaded === "undefined") {
          element.metisMenu();
        } else {
          scope.$watch("loaded", function (newValue) {
            if (newValue) {
              element.metisMenu();
            }
          });
        }

        //support automatic hiding of the navigation bar on state change
        if (typeof attributes.autoCollapse !== "undefined") {
          angular.element('body').addClass('auto-collapse');
          scope.$root.$on('$stateChangeSuccess', function () {
            angular.element('body').addClass('hide-navbar');
            angular.element('body').removeClass('condensed-panel');
          });
        }
      }
    };
  }
})();;
(function () {
    angular.module('hpe.elements.slider', []);
})();;
(function () {

    angular.module("hpe.elements.slider").controller("SliderCtrl", SliderCtrl);

    SliderCtrl.$inject = ['$scope', '$timeout'];

    function SliderCtrl($scope, $timeout) {
        var vm = this;

        // store the values of the two thumbs
        vm.thumbLowerValue = null;
        vm.thumbUpperValue = null;

        // store tooltip visibility
        vm.tooltipLowerVisible = false;
        vm.tooltipUpperVisible = false;

        // store thumb event information
        vm.lowerThumbState = {
            hover: false,
            drag: false
        };

        vm.upperThumbState = {
            hover: false,
            drag: false
        };

        // store all the track colors
        vm.trackColors = {
            lower: '#f2f2f2',
            range: '#889baa',
            higher: '#f2f2f2'
        };

        // store thumb positions
        vm.thumbPositions = {
            lower: 0,
            upper: 0
        };

        vm.trackSizes = {
            lower: 0,
            range: 0,
            higher: 0
        };

        // store the order we want to display the thumbs
        vm.thumbOrder = {
            lower: 100,
            upper: 101
        };

        // store all the ticks to display
        vm.ticks = [];

        var defaultOptions = {
            type: 'value',
            handles: {
                style: 'button',
                callout: {
                    trigger: 'none',
                    background: '#464646',
                    color: '#fff',
                    formatter: function (value) {
                        return value;
                    }
                }
            },
            track: {
                height: 'wide',
                min: 0,
                max: 100,
                ticks: {
                    snap: 'none',
                    major: {
                        show: true,
                        steps: 10,
                        labels: true,
                        formatter: function (value) {
                            return value;
                        }
                    },
                    minor: {
                        show: true,
                        steps: 5,
                        labels: false,
                        formatter: function (value) {
                            return value;
                        }
                    }
                },
                colors: {
                    lower: '#f2f2f2',
                    range: 'rgba(96,121,141, 0.75)',
                    higher: '#f2f2f2'
                }
            }
        };


        // process the slider options
        processOptions();

        // watch for any changes to options
        $scope.$watch('vm.options', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                processOptions();
            }
        }, true);

        // watch for changes to the values
        $scope.$watch('vm.thumbLowerValue', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                updateViewValues();
            }
        });

        $scope.$watch('vm.thumbUpperValue', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                updateViewValues();
            }
        });

        // watch for any changes to state
        $scope.$watch('vm.lowerThumbState', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                updateTooltipVisibility();
            }
        }, true);

        $scope.$watch('vm.upperThumbState', function (newValue, oldValue) {
            if (newValue !== oldValue) {
                updateTooltipVisibility();
            }
        }, true);

        // watch for any external model changes
        $scope.$watch('vm.ngModel', function (newValue, oldValue) {
            if (newValue === oldValue) return;

            // ensure everything is up to date and in sync
            updateFromModel();
        }, true);

        // set initial values
        updateFromModel();

        // initially update tooltips
        updateTooltipVisibility();


        vm.bringToFront = function (upperThumb) {

            // determine which thumb to update
            vm.thumbOrder.lower = upperThumb ? 100 : 101;
            vm.thumbOrder.upper = upperThumb ? 101 : 100;
        };

        // Private Functions

        function updateTooltipVisibility() {

            // update visiblility based on configuration and state
            switch (vm.options.handles.callout.trigger) {

                case 'none':
                    vm.tooltipLowerVisible = false;
                    vm.tooltipUpperVisible = false;
                    break;

                case 'persistent':
                    vm.tooltipLowerVisible = true;
                    vm.tooltipUpperVisible = true;
                    break;

                case 'hover':
                    vm.tooltipLowerVisible = vm.lowerThumbState.hover || vm.lowerThumbState.drag;
                    vm.tooltipUpperVisible = vm.upperThumbState.hover || vm.upperThumbState.drag;
                    break;

                case 'drag':
                    vm.tooltipLowerVisible = vm.lowerThumbState.drag;
                    vm.tooltipUpperVisible = vm.upperThumbState.drag;
                    break;

            }
        }

        function processOptions() {

            // override any default options with specified options
            vm.options = $.extend(true, defaultOptions, vm.options);

            // update ticks
            updateTicks();

            // update track colors
            updateTrackColors();
        }

        function updateViewValues() {

            var lowerPercentage = (((vm.thumbLowerValue - vm.options.track.min) / (vm.options.track.max - vm.options.track.min)) * 100);
            var upperPercentage = (((vm.thumbUpperValue - vm.options.track.min) / (vm.options.track.max - vm.options.track.min)) * 100);

            // update thumb positions
            vm.thumbPositions = {
                lower: lowerPercentage + '%',
                upper: upperPercentage + '%'
            };

            vm.trackSizes = {
                lower: lowerPercentage,
                range: upperPercentage - lowerPercentage,
                higher: vm.options.type === 'value' ? 100 - lowerPercentage : 100 - upperPercentage
            };

            // update the model - use timeout to apply on next digest cycle
            $timeout(function () {
                vm.ngModel = vm.options.type === 'value' ? vm.thumbLowerValue : {
                    low: vm.thumbLowerValue,
                    high: vm.thumbUpperValue
                };
            });
        }

        function updateFromModel() {

            if (vm.options.type === 'value') {

                // get the current value from the model
                vm.thumbLowerValue = parseFloat(vm.ngModel);

                // ensure is a valid number
                if (isNaN(vm.thumbLowerValue)) {
                    vm.thumbLowerValue = vm.options.track.min;
                }

                // ensure it is within the range
                if (vm.thumbLowerValue > vm.options.track.max) {
                    vm.thumbLowerValue = vm.options.track.max;
                }

                if (vm.thumbLowerValue < vm.options.track.min) {
                    vm.thumbLowerValue = vm.options.track.min;
                }

            } else {

                // ensure we have low and high properties
                if (vm.ngModel.low === undefined || vm.ngModel.high === undefined) {
                    throw 'Slider - For range input model must have low and high properties';
                }

                // store the previous values
                var lowerPrevious = vm.thumbLowerValue;
                var upperPrevious = vm.thumbUpperValue;

                // get the current value from the model
                vm.thumbLowerValue = parseFloat(vm.ngModel.low);
                vm.thumbUpperValue = parseFloat(vm.ngModel.high);

                // determine if the position has changed
                var lowerChanged = vm.thumbLowerValue !== lowerPrevious;
                var upperChanged = vm.thumbUpperValue !== upperPrevious;

                // if either is not an number then set the range min/max
                if (isNaN(vm.thumbLowerValue)) {
                    vm.thumbLowerValue = vm.options.track.min;
                }

                if (isNaN(vm.thumbUpperValue)) {
                    vm.thumbUpperValue = vm.options.track.max;
                }

                // ensure lower thumb it is within the range
                if (vm.thumbLowerValue > vm.options.track.max) {
                    vm.thumbLowerValue = vm.options.track.max;
                }

                if (vm.thumbLowerValue < vm.options.track.min) {
                    vm.thumbLowerValue = vm.options.track.min;
                }

                // ensure upper thumb it is within the range
                if (vm.thumbUpperValue > vm.options.track.max) {
                    vm.thumbUpperValue = vm.options.track.max;
                }

                if (vm.thumbUpperValue < vm.options.track.min) {
                    vm.thumbUpperValue = vm.options.track.min;
                }


                // ensure lower thumb is not higher than upper or vice versa
                if (lowerChanged && vm.thumbLowerValue > vm.thumbUpperValue) {
                    vm.thumbLowerValue = vm.thumbUpperValue;
                }

                if (upperChanged && vm.thumbUpperValue < vm.thumbLowerValue) {
                    vm.thumbUpperValue = vm.thumbLowerValue;
                }

                // update the z-indexes
                if (upperChanged && lowerChanged) {

                    // if lower thumb is at the max range then bring it to front
                    if (vm.thumbLowerValue === vm.options.track.max) {
                        vm.bringToFront(false);
                    }

                    // if the upper thumb is at the lowest range then bring it to front
                    if (vm.upperThumbValue === vm.options.track.min) {
                        vm.bringToFront(true);
                    }
                } else if (upperChanged) {
                    vm.bringToFront(true);
                } else if (lowerChanged) {
                    vm.bringToFront(false);
                }

            }

            // after validation ensure model is up to date
            updateViewValues();
        }

        function updateTrackColors() {

            // get colors for each part of the track
            var lower = vm.options.track.colors.lower;
            var range = vm.options.track.colors.range;
            var higher = vm.options.track.colors.higher;

            // update the controller value
            vm.trackColors.lower = typeof lower === 'string' ? lower : 'linear-gradient(to right, ' + lower.join(', ') + ')';
            vm.trackColors.range = typeof range === 'string' ? range : 'linear-gradient(to right, ' + range.join(', ') + ')';
            vm.trackColors.higher = typeof higher === 'string' ? higher : 'linear-gradient(to right, ' + higher.join(', ') + ')';
        }

        function updateTicks() {

            // get major tick options
            var majorOptions = vm.options.track.ticks.major;

            // get major tick options
            var minorOptions = vm.options.track.ticks.minor;

            // check if we should show major ticks
            if (majorOptions.show === false && minorOptions.show === false) {
                vm.ticks = [];
            }

            // create ticks
            var majorTicks = createScaleTicks(majorOptions, 'major');

            var minorTicks = createScaleTicks(minorOptions, 'minor');

            // remove any minor ticks that are on a major interval
            vm.ticks = unionTicks(majorTicks, minorTicks);
        }

        function createScaleTicks(options, type) {

            // store the ticks
            var ticks = [];

            // get tick steps
            var steps = options.steps;

            if (angular.isArray(steps)) {

                // iterate each step
                for (var idx in steps) {

                    // get step value
                    var step = steps[idx];

                    // calculate tick position - then convert to percentage
                    var tickPosition = ((step - vm.options.track.min) / (vm.options.track.max - vm.options.track.min)) * 100;

                    // if the tick is out ouf bounds then skip
                    if (tickPosition < 0 || tickPosition > 100) {
                        continue;
                    }

                    // add tick to array
                    ticks.push({
                        showTicks: options.show,
                        showLabels: options.labels,
                        type: type,
                        position: tickPosition,
                        value: step,
                        label: options.formatter(step)
                    });
                }

            } else {

                // iterate each tick
                for (var tidx = vm.options.track.min; tidx <= vm.options.track.max; tidx += options.steps) {

                    // calculate tick position - then convert to percentage
                    var tickLocation = ((tidx - vm.options.track.min) / (vm.options.track.max - vm.options.track.min)) * 100;

                    // if the tick is out ouf bounds then skip
                    if (tickLocation < 0 || tickLocation > 100) {
                        continue;
                    }

                    // add tick to array
                    ticks.push({
                        showTicks: options.show,
                        showLabels: options.labels,
                        type: type,
                        position: tickLocation,
                        value: tidx,
                        label: options.formatter(tidx)
                    });
                }
            }


            return ticks;
        }

        function unionTicks(majorTicks, minorTicks) {

            // start of with all the major ticks as they take precendence
            var ticks = majorTicks.slice(0);

            // iterate each minor tick
            for (var idx = 0; idx < minorTicks.length; idx++) {

                // get current minor tick
                var minorTick = minorTicks[idx];

                // check if there is a major tick with the same value
                var match = false;

                for (var maj = 0; maj < majorTicks.length; maj++) {
                    if (majorTicks[maj].position === minorTick.position) {
                        match = true;
                        break;
                    }
                }

                // if there are no matches then add the tick to the output array
                if (match === false) {
                    ticks.push(minorTick);
                }
            }

            return ticks.sort(function (tickOne, tickTwo) {
                if (tickOne.value < tickTwo.value) {
                    return -1;
                }
                if (tickOne.value > tickTwo.value) {
                    return 1;
                }
                return 0;
            });
        }

    }

})();;
(function () {

    angular.module('hpe.elements.slider').directive('slider', slider);

    slider.$inject = ['$timeout'];

    function slider($timeout) {
        return {
            restrict: 'E',
            templateUrl: 'slider/slider.html',
            scope: {
                options: '=',
                ngModel: '='
            },
            require: 'ngModel',
            controller: 'SliderCtrl as vm',
            bindToController: true,
            link: function (scope, element) {

                // store reference to controller
                var vm = scope.vm;

                // store reference to elements
                var nativeElement = element.get(0);

                var track = nativeElement.querySelector('.track');

                var thumbLower = nativeElement.querySelector('.thumb.lower');
                var thumbUpper = nativeElement.querySelector('.thumb.upper');

                var lowerTooltip = nativeElement.querySelector('.tooltip-lower');
                var upperTooltip = nativeElement.querySelector('.tooltip-upper');

                // store the currently dragged state
                var activeThumb = null;

                // bind event handlers
                bindHandlers();

                // create tooltips after initial digest
                $timeout(createTooltips);

                // unbind event handlers
                scope.$on('$destroy', unbindHandlers);

                function bindHandlers() {

                    // add mouse down events to thumbs
                    thumbLower.addEventListener('mousedown', thumbDragStart);
                    thumbUpper.addEventListener('mousedown', thumbDragStart);

                    // add some events to the document
                    document.addEventListener('mousemove', thumbDragMove);
                    document.addEventListener('mouseup', thumbDragEnd);

                    // support touch events
                    thumbLower.addEventListener('touchstart', thumbDragStart);
                    thumbUpper.addEventListener('touchstart', thumbDragStart);
                    document.addEventListener('touchmove', thumbDragMove);
                    document.addEventListener('touchend', thumbDragEnd);
                }

                function unbindHandlers() {
                    document.removeEventListener('mousemove', thumbDragMove);
                    document.removeEventListener('mouseup', thumbDragEnd);

                    document.removeEventListener('touchmove', thumbDragMove);
                    document.removeEventListener('touchend', thumbDragEnd);
                }

                function thumbDragStart(event) {

                    // ensure we are not performing events on tooltip
                    if (hasClassOrAncestor(event.target, 'tooltip')) {
                        return;
                    }

                    // if right or middle click do nothing
                    if (event.button && event.button !== 0) {
                        return;
                    }

                    // store the element to use later
                    activeThumb = event.target;

                    // get thumb state
                    var thumbState = resolveThumbState(activeThumb);

                    // update thumb state
                    thumbState.drag = true;

                    // remove bring to front class from both thumbs
                    vm.bringToFront(activeThumb.classList.contains('upper'));

                    // stop any highlighting occuring when dragging
                    event.preventDefault();

                    return false;
                }

                function thumbDragMove(event) {

                    // if we arent dragging then stop
                    if (activeThumb === null) {
                        return;
                    }

                    // get the thumb being dragged
                    var thumb = activeThumb;

                    // check for any page scrolling
                    var value = mousePositionToValue(event);

                    // snap to ticks
                    value = snapToTick(value);

                    // get the current value for the thumb
                    setValueForThumb(thumb, value);
                }

                function thumbDragEnd() {

                    // if we arent dragging then stop
                    if (activeThumb === null) {
                        return;
                    }

                    // get thumb state
                    var thumbState = resolveThumbState(activeThumb);

                    // update thumb state
                    thumbState.drag = false;

                    // remove any reference to thumb object being dragged
                    activeThumb = null;

                    // perform a digest here if required
                    if (!scope.$$phase) {
                        scope.$digest();
                    }
                }

                function clamp(value, min, max) {
                    return Math.min(Math.max(value, min), max);
                }

                function mousePositionToValue(event) {

                    // get event position - eithe rmouse or touch
                    var eventPosition = event.clientX !== undefined ? event.clientX : event.touches && event.touches.length > 0 ? event.touches[0].clientX : null;

                    // if event position is null do nothing
                    if (eventPosition === null) {
                        return;
                    }

                    // get mouse position
                    var mouseX = window.pageXOffset + eventPosition;

                    // get track size and position
                    var trackBounds = track.getBoundingClientRect();

                    // restrict the value within the range size
                    var position = clamp(mouseX - trackBounds.left, 0, trackBounds.width);

                    // get fraction representation of location within the track
                    var fraction = (position / trackBounds.width);

                    // convert to value within the range
                    var value = ((vm.options.track.max - vm.options.track.min) * fraction) + vm.options.track.min;

                    // ensure value is valid
                    value = validatePosition(value);

                    // convert position to point within range
                    return value;
                }

                function validatePosition(value) {

                    // if slider is not a range value is always valid
                    if (vm.options.type === 'value') {
                        return value;
                    }

                    // otherwise we need to check to make sure lower thumb cannot go above higher and vice versa
                    if (activeThumb === thumbLower) {
                        return value <= vm.thumbUpperValue ? value : vm.thumbUpperValue;
                    }

                    if (activeThumb === thumbUpper) {
                        return value >= vm.thumbLowerValue ? value : vm.thumbLowerValue;
                    }
                }

                function setValueForThumb(thumb, value) {

                    // set the appropriate values
                    if (thumb === thumbLower) {
                        vm.thumbLowerValue = value;
                    } else {
                        vm.thumbUpperValue = value;
                    }

                    // run digest if required
                    if (!scope.$$phase) {
                        scope.$digest();
                    }
                }

                function createTooltips() {

                    // initially update tooltips
                    updateTooltip(lowerTooltip, vm.tooltipLowerVisible);
                    updateTooltip(upperTooltip, vm.tooltipUpperVisible);

                    // watch values of lower thumb
                    scope.$watch('vm.thumbLowerValue', function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            $timeout(function () {
                                updateTooltip(lowerTooltip, vm.tooltipLowerVisible);
                            });
                        }
                    });

                    // watch values of upper thumb
                    scope.$watch('vm.thumbUpperValue', function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            $timeout(function () {
                                updateTooltip(upperTooltip, vm.tooltipUpperVisible);
                            });
                        }
                    });

                    // watch for changes in tooltip visibility
                    scope.$watch('vm.tooltipLowerVisible', function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            updateTooltip(lowerTooltip, vm.tooltipLowerVisible);
                        }
                    });

                    scope.$watch('vm.tooltipUpperVisible', function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            updateTooltip(upperTooltip, vm.tooltipUpperVisible);
                        }
                    });

                    // watch callout options to and update if required
                    scope.$watch('vm.options.handles.callout', function (newValue, oldValue) {
                        if (newValue !== oldValue) {
                            // update both tooltips
                            $timeout(function () {
                                updateTooltip(lowerTooltip, vm.tooltipLowerVisible);
                                updateTooltip(upperTooltip, vm.tooltipUpperVisible);
                            });
                        }
                    });
                }

                function updateTooltip(tooltip, visible) {

                    // if tooltip is not visible then stop here
                    if (visible === false) {
                        return;
                    }

                    // get the parent thumb element
                    var thumb = tooltip.parentElement;

                    // get the thumb width
                    var thumbWidth = thumb.offsetWidth;

                    // get the tooltips width
                    var tooltipWidth = tooltip.offsetWidth;

                    // calculat the tooltips new position
                    var tooltipPosition = Math.ceil((tooltipWidth - thumbWidth) / 2);

                    // update tooltip position
                    tooltip.style.left = -tooltipPosition + 'px';

                }

                function snapToTick(value) {

                    // get the snap target
                    var snapTarget = vm.options.track.ticks.snap;

                    // if snap target is none then return original value
                    if (!snapTarget || snapTarget === 'none') {
                        return value;
                    }

                    // get filtered ticks
                    var ticks;

                    switch (snapTarget) {
                        case 'minor':
                            ticks = vm.ticks.filter(function (tick) {
                                return tick.type === 'minor';
                            });
                            break;

                        case 'major':
                            ticks = vm.ticks.filter(function (tick) {
                                return tick.type === 'major';
                            });
                            break;

                        case 'all':
                            ticks = vm.ticks.slice(0);
                            break;
                    }

                    var lowerLimit = vm.options.track.min;
                    var upperLimit = vm.options.track.max;

                    // if range then update the limits
                    if (vm.options.type === 'range') {

                        // determine which thumb we are dragging
                        if (activeThumb.classList.contains('lower')) {
                            upperLimit = vm.thumbUpperValue;
                        } else {
                            lowerLimit = vm.thumbLowerValue;
                        }
                    }

                    // filter ticks within the allowed range
                    ticks = ticks.filter(function (tick) {
                        return tick.value >= lowerLimit && tick.value <= upperLimit;
                    });

                    // find the closest tick
                    var snapValue = 0,
                        distance = null;

                    // iterate each tick to find the closest
                    for (var idx = 0; idx < ticks.length; idx++) {

                        // get tick value
                        var tickValue = ticks[idx];

                        // calculate the distance between this ticks value and our target
                        var tickDistance = Math.max(tickValue.value, value) - Math.min(tickValue.value, value);

                        // if this tick is closer than the previous closest then store this new tick
                        if (distance === null || tickDistance < distance) {

                            distance = tickDistance;
                            snapValue = tickValue.value;
                        }
                    }

                    return snapValue;
                }

                /*
                    Utility Functions
                */
                function resolveThumbState(element) {
                    // return the reference to the corresponding state element
                    return element.classList.contains('lower') ? vm.lowerThumbState : vm.upperThumbState;
                }

                function hasClassOrAncestor(element, className) {

                    // check if the current element has the class
                    if (element.classList.contains(className)) {
                        return true;
                    }

                    // iterate each parent element
                    while (element.parentElement) {

                        // check if parent element has class
                        if (element.classList.contains(className)) {
                            return true;
                        }

                        // set element to the parent element
                        element = element.parentElement;
                    }

                    // if we reach this point then return false
                    return false;
                }
            }
        };
    }

})();;
(function () {  
  angular.module("hpe.elements.socialChart",  ["hpe.elements.templates"]);
})();;
(function () {

  angular.module("hpe.elements.socialChart").controller("SocialChartCtrl", SocialChartCtrl);
  SocialChartCtrl.$inject = ["$scope", "sigma", "$timeout", "d3", "safeTimeout"];

  function SocialChartCtrl($scope, sigma, $timeout, d3, safeTimeout) {
    var sc = this;
    sc._$scope = $scope;
    sc.d3 = d3;

    $scope.options = $scope.options || {};

    //the data to be displayed in the chart
    sc.data = $scope.data;

    //show the chart title
    sc.chartTitle = $scope.chartTitle;
    sc.showTitle = true;
    if (sc.chartTitle !== undefined)
      sc.socialChartTitle = sc.chartTitle.title;
    else
      sc.showTitle = false;
    sc.updateTitle = true;
    //timeout for title
    sc.safeTimeoutInstance = safeTimeout.create($scope);
    sc.setTitleTimer();

    //the styles to be applied to the container
    sc.style = {
      'display': 'inline-block',
      'background-color': '#2A2A2A'
    };

    sc.style.width = $scope.width;
    sc.style.height = $scope.height;

    //the styles to be added to panel inlays - notably background color
    sc.detailInlayStyle = {
      'background-color': '#333'
    };

    var defaultNodeDetailStyle = {
      'width': '235px',
      'height': '99%'
    };

    var defaultEdgeDetailStyle = {
      'width': '40vw',
      'height': '20%',
      'max-height': '176px'
    };

    //Styles on detail panels
    sc.nodeDetailStyle = $scope.detailStyle ? ($scope.detailStyle.node || defaultNodeDetailStyle) : defaultNodeDetailStyle;
    sc.edgeDetailStyle = $scope.detailStyle ? ($scope.detailStyle.edge || defaultEdgeDetailStyle) : defaultEdgeDetailStyle;

    //The styles for the popover panels
    var defaultNodePopoverStyle = {
      'height': '185px'
    };
    var defaultEdgePopoverStyle = {
      'min-width': '550px',
      'height': '175px'
    };
    sc.nodePopoverStyle = $scope.popoverStyle ? ($scope.popoverStyle.node || defaultNodePopoverStyle) : defaultNodePopoverStyle;
    sc.edgePopoverStyle = $scope.popoverStyle ? ($scope.popoverStyle.edge || defaultEdgePopoverStyle) : defaultEdgePopoverStyle;

    //Detail templates
    sc.nodeDetail = $scope.nodeDetail || null;
    sc.edgeDetail = $scope.edgeDetail || null;
    //Optional close button
    sc.showDetailCloseButton = ($scope.options.showDetailCloseButton !== undefined) ? !!$scope.options.showDetailCloseButton : true;

    //Popover templates
    sc.nodePopover = $scope.nodePopover || null;
    sc.edgePopover = $scope.edgePopover || null;

    sc.hoverEnabled = sc.nodePopover || sc.edgePopover;

    //Time to run the ForceAtlas2 algorithm
    if ($scope.forceAtlasDuration === 0) {
      sc.layoutRenderTimeout = 0;
    } else {
      sc.layoutRenderTimeout = $scope.forceAtlasDuration || 1800;
    }

    //check if the edge weight should have influence on the layout
    sc.edgeWeightInfluence = $scope.edgeWeightInfluence === true;

    //minimum number of nodes to display
    sc.minLabels = $scope.minLabels;

    //When present, property to use for interpolation of node sizes
    sc.nodeSizeAttribute = $scope.nodeSizeAttribute || null;

    //Selected items and linking these back to the external scope
    sc.selectedNode = null;
    sc.selectedEdge = null;

    $scope.$watch('sc.selectedNode.id', function () {
      $scope.api.selectedNode = sc.selectedNode;
    });
    $scope.$watch('sc.selectedEdge.id', function () {
      $scope.api.selectedEdge = sc.selectedEdge;
    });

    //Other API functions
    sc.api = sc.api || {};
    $scope.api = $scope.api || {};
    sc.api.onNodeClick = $scope.api.onNodeClick || null;
    sc.api.onEdgeClick = $scope.api.onEdgeClick || null;
    sc.api.onStageClick = $scope.api.onStageClick || null;
    sc.api.onNodeHover = $scope.api.onNodeHover || null;
    sc.api.onEdgeHover = $scope.api.onEdgeHover || null;
    sc.api.onToggleFullscreen = $scope.api.onToggleFullscreen || null;
    sc.api.onLoadComplete = $scope.api.onLoadComplete || null;

    //Optional rendering options
    sc.communities = $scope.communities;

    //Hover settings
    sc.hoverDelay = 850; //ms
    sc.hoveredItem = null;

    //Full-screen settings
    sc.startMaximised = ($scope.startMaximized || $scope.startMaximised) || false;
    sc.showMaximiseControl = ($scope.showMaximizeControl || $scope.showMaximiseControl) || false;
    sc.fullScreenContainer = angular.element('.' + $scope.socialChartContainer)[0] || null;
    $scope.fullscreenButtonPosition = $scope.fullscreenButtonPosition || {};
    sc.maximiseControlStyle = ($scope.fullscreenButtonPosition.maximize || $scope.fullscreenButtonPosition.maximise) || {
      'top': '-20px',
      'right': '-20px'
    };
    sc.minimiseControlStyle = ($scope.fullscreenButtonPosition.minimize || $scope.fullscreenButtonPosition.minimize) || {
      'top': '102px',
      'right': '25px'
    };

    //localStrings
    sc.localStrings = $scope.localStrings || {};
    sc.localStrings.title = sc.localStrings.title || "Entire Network";
    sc.localStrings.reset = sc.localStrings.reset || "Reset";
    sc.localStrings.zoomIn = sc.localStrings.zoomIn || "Zoom In";
    sc.localStrings.zoomOut = sc.localStrings.zoomOut || "Zoom Out";
    sc.tooltipResetHtml = sc.localStrings.reset + "&nbsp;<span class='text-muted'>(" + sc.localStrings.title + ")</span>";

    //Node movement timing
    //With a much lower value for IE
    sc.nodeMovementTime = document.documentMode ? 0 : 1000;

    //Timers
    //Particularly for delayed renders, we should cancel any timeouts set when the scope is destroyed
    sc.timers = {};
    sc.$timeout = $timeout;

    //Instantiated in directive link function
    //(Controller functions run first)
    sc.sigmaInstance = null;

    $scope.api.setSelectedNodeById = sc.setSelectedNodeById();
    $scope.api.setSelectedEdgeById = sc.setSelectedEdgeById();

  }

  SocialChartCtrl.prototype.setSelectedNodeById = function () {
    var sc = this;

    function setSelectedNodeById(nodeId) {
      var node = sc.sigmaInstance.graph.nodes(nodeId);
      if (node) {
        var container = angular.element('#sigma-container');
        var containerDimensions = {
          'width': container.width(),
          'height': container.height()
        };
        sc.clickNode(node, containerDimensions);
      } else {
        sc.clickStage();
      }
    }

    return setSelectedNodeById;
  };

  SocialChartCtrl.prototype.setSelectedEdgeById = function () {
    var sc = this;

    function setSelectedEdgeById(edgeId) {
      var edge = sc.sigmaInstance.graph.edges(edgeId);
      if (edge) {

        var container = angular.element('#sigma-container');
        var containerDimensions = {
          'width': container.width(),
          'height': container.height()
        };

        sc.clickEdge(edge, true, containerDimensions);
      } else {
        sc.clickStage();
      }
    }

    return setSelectedEdgeById;
  };

  SocialChartCtrl.prototype.initialise = function (sigmaInstance) {
    var sc = this;
    sc.sigmaInstance = sigmaInstance;
    sc.loadData();
    sc.setClickEvent();
    sc.setHoverEvent();
    sc.setCameraEvent();
  };

  SocialChartCtrl.prototype.makeFullscreen = function () {

    var sc = this;

    var container = sc.getContainer()[0]; //sigma-container
    var wrapper = container.getElementsByClassName("sigma-wrapper")[0]; //sigma-wrapper

    //Save the existing values
    if (!sc.toggleFullscreenStyles) {

      var originalWrapperStyle = {
        'top': wrapper.style.top,
        'left': wrapper.style.left,
        'overflow': wrapper.style.overflow,
        'width': wrapper.style.width
      };

      var originalSCStyle = {
        'height': sc.style.height,
        'width': sc.style.width,
        'boxShadow': sc.style.boxShadow || 'none'
      };

      var originalFullscreenContainerStyle = {
        'overflow': sc.fullScreenContainer.style.overflow,
        'maxWidth': sc.fullScreenContainer.style.maxWidth
      };

      sc.toggleFullscreenStyles = {
        'originalWrapperStyle': originalWrapperStyle,
        'originalSCStyle': originalSCStyle,
        'originalFullscreenContainerStyle': originalFullscreenContainerStyle
      };
    }

    sc.hideCanvas();

    //The chart wrapper needs to move to the position of the page container
    wrapper.style.top = ((wrapper.offsetTop - sc.fullScreenContainer.offsetTop) * -1) + "px";
    wrapper.style.left = ((wrapper.offsetLeft - sc.fullScreenContainer.offsetLeft) * -1) + "px";
    wrapper.style.width = '100vw';

    //the chart needs to take up the full space
    sc.style.height = sc.getChartHeight();
    sc.style.width = "100%";

    //stop the container from showing little scrollbars
    sc.fullScreenContainer.style.overflow = "hidden";
    sc.fullScreenContainer.style.maxWidth = "none";

    sc.isFullscreen = true;

    sc.safeTimeout(function () {
      sc.sigmaInstance.refresh();
      sc.showCanvas();
    });
  };

  SocialChartCtrl.prototype.updateChartHeight = function () {
    var sc = this;
    var chartHeight = sc.getChartHeight();
    if (sc.isFullscreen && sc.style.height !== chartHeight) {
      sc.style.height = chartHeight;
      sc.sigmaInstance.refresh();
    }
  };

  SocialChartCtrl.prototype.getChartHeight = function () {
    var sc = this;
    var targetHeight = window.innerHeight;
    if (sc.fullScreenContainer) targetHeight -= (sc.fullScreenContainer.offsetTop);
    return targetHeight + "px";
  };

  SocialChartCtrl.prototype.revertFullScreen = function () {

    var sc = this;

    if (!sc.toggleFullscreenStyles) {
      return;
    }

    var container = sc.getContainer()[0]; //sigma-container
    var wrapper = container.getElementsByClassName("sigma-wrapper")[0]; //sigma-wrapper

    sc.hideCanvas();

    for (var i in sc.toggleFullscreenStyles.originalWrapperStyle) {
      wrapper.style[i] = sc.toggleFullscreenStyles.originalWrapperStyle[i];
    }

    for (var j in sc.toggleFullscreenStyles.originalSCStyle) {
      sc.style[j] = sc.toggleFullscreenStyles.originalSCStyle[j];
    }

    for (var k in sc.toggleFullscreenStyles.originalFullscreenContainerStyle) {
      sc.fullScreenContainer.style[k] = sc.toggleFullscreenStyles.originalFullscreenContainerStyle[k];
    }

    sc.isFullscreen = false;

    sc.safeTimeout(function () {
      sc.sigmaInstance.refresh();
      sc.showCanvas();
    });

  };

  SocialChartCtrl.prototype.toggleFullscreen = function () {
    var sc = this;
    //Callback, if present
    if (sc.api.onToggleFullscreen) {
      if (!sc.api.onToggleFullscreen()) {
        //If the callback returns false, then do not perform the standard transition
        return;
      }
    }
    if (sc.isFullscreen) {
      sc.revertFullScreen();
    } else {
      sc.makeFullscreen();
    }
  };

  SocialChartCtrl.prototype.loadData = function () {
    var sc = this;

    sc.neighborViewOnSelect = true;
    if (typeof sc.sigmaInstance.settings("neighborViewOnSelect") !== 'undefined') {
      sc.neighborViewOnSelect = !!sc.sigmaInstance.settings("neighborViewOnSelect");
    }

    var getSize = function (nodeID, edges) {
      var count = 1;
      for (var i = 0; i < edges.length; i++) {
        if (edges[i].source === nodeID) {
          count++;
        }
      }
      return count;
    };

    //Define the nodes
    sc.totalNodeCount = sc.data.nodes.length;
    for (var i = 0; i < sc.totalNodeCount; i++) {
      sc.sigmaInstance.graph.addNode({
        id: '' + sc.data.nodes[i].id,
        label: sc.data.nodes[i].label,
        x: Math.random(),
        y: Math.random(),
        additional: sc.data.nodes[i].additional || {},
        size: sc.nodeSizeAttribute ?
          sc.data.nodes[i].additional[sc.nodeSizeAttribute] || 1 : sc.data.nodes[i].size || getSize(sc.data.nodes[i].id, sc.data.edges),
        color: (sc.data.nodes[i].community) ?
          sc.communities[sc.data.nodes[i].community].color : null,
        style: (sc.data.nodes[i].community) ?
          sc.communities[sc.data.nodes[i].community].style : 'fill',
        getNeighbors: getNeighbors(sc.data.nodes[i].id)
      });
    }

    //Define the edges
    for (var j = 0; j < sc.data.edges.length; j++) {
      sc.sigmaInstance.graph.addEdge({
        id: 'e' + j,
        source: '' + sc.data.edges[j].source,
        target: '' + sc.data.edges[j].target,
        value: sc.data.edges[j].value,
        type: 'curve',
        size: sc.data.edges[j].size || null,
        weight: sc.data.edges[j].weight || 0,
        additional: sc.data.edges[j].additional || {},
        getSourceNode: getSourceNode(sc.data.edges[j].source).bind(sc),
        getTargetNode: getTargetNode(sc.data.edges[j].target).bind(sc)
      });
    }

    //Render

    //If starting full screen
    if (sc.startMaximised && sc.fullScreenContainer) {

      sc.makeFullscreen();

    }

    //Check whether to adjust the node positions to acommodate the side panel
    sc.adjustNodeCentres = sc.sigmaInstance.settings("adjustCameraCenter") || false;

    if (sc.layoutRenderTimeout > 0) {

      sc.disableDraw();

      //if we should be taking edge weight into account then
      if (sc.edgeWeightInfluence === true) {
        sc.sigmaInstance.configForceAtlas2({
          edgeWeightInfluence: 1
        });
      }

      sc.sigmaInstance.startForceAtlas2();
    }

    sc.safeTimeout(function () {
      sc.sigmaInstance.stopForceAtlas2();
      sc.enableDraw();

      //show initial minimum number of labels
      sc.showMinimumLabels();

      sc.sigmaInstance.refresh();
      if (sc.api.onLoadComplete) {
        sc.api.onLoadComplete();
      }
    }, sc.layoutRenderTimeout);

    function getSourceNode(sId) {
      function getSourceNode() {
        return sc.sigmaInstance.graph.nodes(sId);
      }
      return getSourceNode;
    }

    function getTargetNode(tId) {
      function getTargetNode() {
        return sc.sigmaInstance.graph.nodes(tId);
      }
      return getTargetNode;
    }

    function getNeighbors(nodeId) {
      function getNeighbors() {
        return {
          'nodes': sc.sigmaInstance.graph.neighbors(nodeId),
          'edges': sc.sigmaInstance.graph.nodeEdges(nodeId),
        };
      }
      return getNeighbors;
    }
  };


  SocialChartCtrl.prototype.disableDraw = function () {
    var sc = this;
    sc.sigmaInstance.settings("hideEdgesOnMove", true);
    //sc.sigmaInstance.settings("drawNodes", false);
    sc.sigmaInstance.settings("drawEdges", false);
    sc.sigmaInstance.settings("drawLabels", false);
  };

  SocialChartCtrl.prototype.enableDraw = function () {
    var sc = this;
    //sc.sigmaInstance.settings("hideEdgesOnMove",false);
    sc.sigmaInstance.settings("drawNodes", true);
    sc.sigmaInstance.settings("drawEdges", true);
    sc.sigmaInstance.settings("drawLabels", true);
  };

  SocialChartCtrl.prototype.selectNode = function (node) {
    var sc = this;
    sc.selectedNode = node;
    sc.selectedEdge = null;
  };

  SocialChartCtrl.prototype.selectEdge = function (edge, applyInProgress) {
    var sc = this;
    sc.selectedEdge = edge;
    sc.selectedNode = null;
    if (!applyInProgress) {
      sc._$scope.$digest();
    }
  };

  SocialChartCtrl.prototype.clearSelected = function (applyInProgress) {
    var sc = this;
    sc.hoveredItem = null;
    sc.enableHover();
    sc.selectNode(null);
    sc.selectEdge(null, applyInProgress);
  };

  SocialChartCtrl.prototype.setTitleTimer = function () {
    var sc = this;
    //cancel previous timerTitle
    if (sc.timerTitle !== undefined) sc.safeTimeoutInstance.cancel(sc.timerTitle);

    //timer for title
    if (sc.chartTitle !== undefined && sc.chartTitle.timeout !== undefined) {
      sc.timerTitle = sc.safeTimeoutInstance.timeout(function () {
        sc.updateTitle = false;
      }, sc.chartTitle.timeout);
    }
    return;
  };

  SocialChartCtrl.prototype.clickNode = function (node, containerDimensions) {
    var sc = this;

    sc.mouseLeaveUIElement();

    //setting title
    if (sc.socialChartTitle !== undefined && sc.chartTitle.nodeSelectedTitle !== undefined) {
      sc.socialChartTitle = sc.chartTitle.nodeSelectedTitle.replace("{{node}}", node.label);
      sc.updateTitle = true;
      sc.setTitleTimer();
    }

    //get the id of the clicked node
    var nodeId = node.id;
    //get the 1st degree neighbours
    var toKeep = sc.sigmaInstance.graph.neighbors(nodeId);
    //update the reference
    toKeep[nodeId] = node;
    //update watchers
    sc.selectNode(node);
    sc.selectedNode.neighbours = toKeep;

    sc.sigmaInstance.graph.nodes().forEach(function (n) {

      //Remember if this was the last selected node
      n.wasSelected = n.selected;
      //reset all display properties
      n.selected = false;
      n.rendered = false;
      n.showLabel = false;
      if (n.originalX && !n.wasSelected && n.id !== nodeId) {
        n.x = n.originalX;
        n.y = n.originalY;
        n.originalX = null;
        n.originalY = null;
      }

      //keep selected and neighbours highlighted, else dim the other nodes
      if (toKeep[n.id]) {
        n.color = n.originalColour;
        n.bringToFront = true;
      } else {
        n.color = sc.sigmaInstance.settings("hiddenNodeColor") || '#315351';
        n.bringToFront = false;
      }
    });

    sc.sigmaInstance.graph.edges().forEach(function (e) {
      //Does this edge go between two nodes that are both highlighted?
      //If so, it stays highlighted too
      if ((toKeep[e.source] && toKeep[e.source].id === nodeId) || (toKeep[e.target] && toKeep[e.target].id === nodeId)) {
        e.color = e.originalColour;
        e.hover_color = sc.sigmaInstance.settings("defaultEdgeHoverColor") || '#2AD2C9';
      } else {
        e.color = sc.sigmaInstance.settings("hiddenEdgeColor") || '#324342';
        e.hover_color = sc.sigmaInstance.settings("hiddenEdgeColor") || '#324342';
      }
      //since a node was clicked, there's no way for an edge to be selected here
      e.selected = false;
      e.bringToFront = false;
    });

    sc.sigmaInstance.refresh();

    if (sc.api.onNodeClick) {
      sc.api.onNodeClick(node);
    }

    //no need to hover anything now
    sc.hoveredItem = null;

    //Fixed ratio for forced layout, dynamic ratio for optimal node vision when not rearranging
    //For very small graphs we need to use dynamic camera regardless
    var smallGraph = (sc.totalNodeCount < 20);
    var useDynamicZoomRatio = (smallGraph || !sc.neighborViewOnSelect);
    var zoomRatio = (useDynamicZoomRatio) ? sc.getZoomRatio(node, toKeep, containerDimensions) : 0.3;

    //For small graphs, rescale the dynamic camera
    if (smallGraph) {
      zoomRatio = (zoomRatio > 2) ? zoomRatio - 1 : zoomRatio;
    }

    /*
    Passed to the camera move function to allow the camera to be moved twice if the co-ords change
    */
    var updateCameraPosition = function (origX, origY) {

      function afterZoomCallback() {

        //Validate selected node still exists
        if (sc.selectedNode) {
          //If the camera position does not match the intended target camera position
          //e.g. due to the graph boundaries being recalculated
          //Then perform the move again
          if ((sc.selectedNode['read_cam0:x'] !== origX) || (sc.selectedNode['read_cam0:y'] !== origY)) {

            sc.safeTimeout(function () {

              sc.zoomTo(
                sc.getX(node['read_cam0:x'],
                  sc.nodeDetail,
                  sc.isFullscreen,
                  sc.menuVisible,
                  zoomRatio,
                  sc.sigmaInstance.settings("cameraCenterOffset"),
                  sc.adjustNodeCentres
                ),
                sc.getY(
                  node['read_cam0:y'],
                  sc.isFullscreen,
                  sc.adjustNodeCentres
                ),
                zoomRatio
              );
            }, 100);
          }
          //

        }
        return null;
      }
      return afterZoomCallback;
    };

    //Force the ellipsoid selected node pattern
    if (sc.neighborViewOnSelect) {
      sc.forceNodeLayout(node, containerDimensions, toKeep);
    }


    sc.safeTimeout(function () {
      if (sc.selectedNode) {
        sc.selectedNode.selected = true;
        sc.sigmaInstance.refresh();
      }
    }, sc.nodeMovementTime);

    //Move the camera to centre on the selected node
    sc.zoomTo(
      sc.getX(
        node['read_cam0:x'],
        sc.nodeDetail,
        sc.isFullscreen,
        sc.menuVisible,
        zoomRatio,
        sc.sigmaInstance.settings("cameraCenterOffset"),
        sc.adjustNodeCentres
      ),
      sc.getY(
        node['read_cam0:y'],
        sc.isFullscreen,
        sc.adjustNodeCentres
      ),
      zoomRatio,
      updateCameraPosition(node['read_cam0:x'], node['read_cam0:y'])
    );
  };

  SocialChartCtrl.prototype.getX = function (nodeX, detailPanelToShow, isFullscreen, menuVisible, zoomRatio, offset, adjustNodeCentres) {

    if (!adjustNodeCentres) {
      return nodeX;
    }

    if (!detailPanelToShow) {
      return nodeX;
    } else {
      var fullscreen = isFullscreen ? offset / 30 : 0;
      var menu = (isFullscreen && menuVisible) ? offset / 5 : 0;
      return nodeX + (offset * zoomRatio) + fullscreen + menu;
    }
  };

  SocialChartCtrl.prototype.getY = function (nodeY, isFullscreen, adjustNodeCentres) {
    if (!adjustNodeCentres) {
      return nodeY;
    }

    if (isFullscreen) {
      return nodeY + 30;
    } else {
      return nodeY;
    }
  };

  SocialChartCtrl.prototype.forceNodeLayout = function (node, containerDimensions, toKeep) {
    var sc = this;

    //Centre of the circle
    var centre = {
      x: node.x,
      y: node.y
    };
    var nodeId = node.id;

    //Arrange the 1st degree neighbours around the centre position
    //The number of points to position
    var toKeepIds = Object.keys(toKeep);
    var points = toKeepIds.length;
    var r = Math.pow(containerDimensions.width, (sc.isFullscreen ? 0.35 : 0.45)) / 2;
    var count = 1;

    //Magic numbers for constants
    var a = Math.ceil(points / 10);
    var b = Math.floor(points / 10);

    var xAspect, yAspect;
    //225: side panel
    if (containerDimensions.width - 225 > containerDimensions.height) {
      xAspect = 1.6;
      yAspect = 1;
    } else if (containerDimensions.width - 225 < containerDimensions.height) {
      xAspect = 1;
      yAspect = 1.6;
    } else {
      xAspect = 1;
      yAspect = 1;
    }
    var toMove = [];
    var previousNode = null;
    for (var i in toKeep) {
      //Don't move the centre node
      if (i !== nodeId && !toKeep[i].wasSelected) {
        count++;

        //Record IDs of moved nodes
        toMove.push(i);

        //Retain previous values
        toKeep[i].originalX = toKeep[i].x;
        toKeep[i].originalY = toKeep[i].y;

        //Prevent the circle being perfect
        var radius = r + ((count % a) * b);

        //Ellipse layout for 1st degree neighbours
        toKeep[i].to_x = centre.x + radius * xAspect * Math.cos(2 * Math.PI * count / points);
        toKeep[i].to_y = centre.y + radius * yAspect * Math.sin(2 * Math.PI * count / points);


      } else {
        //Remember this node was selected for transitions, unless this node was
        //clicked twice
        if (toKeep[i].wasSelected && toKeep[i].id !== nodeId) {
          previousNode = toKeep[i];
        }
      }
    }

    //May have to adjust position of something if we came with a fixed position node
    var displaceOffset = 1;
    //Limit the attempts to reposition
    var maxTries = 3;
    //If there is a fixed node which is ignoring the new layout
    if (previousNode) {
      //check if it collides with any node we just moved
      for (var j in toKeep) {

        if (j !== nodeId && j !== previousNode.id) {

          var attempts = 0;
          while (sc.detectCollision(previousNode, "", toKeep[j], "to_") && attempts < maxTries) {
            var newPosition = sc.displaceNode(toKeep[j], centre, displaceOffset, "to_");
            toKeep[j].to_x = newPosition.x;
            toKeep[j].to_y = newPosition.y;
            displaceOffset += 0.5;
            attempts++;
          }
        }
      }
    }

    //Displace the nodes that are visible but not selected

    //Get the list of visible nodes
    //Initially a very large set but less problematic as you go
    var nodesOnScreen = sc.sigmaInstance.renderers[0].nodesOnScreen;
    var unselectedNodes = [];

    for (var k in nodesOnScreen) {

      //If we don't want to keep this node and it's too close
      if ((!~toKeepIds.indexOf(nodesOnScreen[k].id)) &&
        (sc.getDistance(centre, nodesOnScreen[k], "") < r * 2)) {

        //Retain the old position
        nodesOnScreen[k].originalX = nodesOnScreen[k].x;
        nodesOnScreen[k].originalY = nodesOnScreen[k].y;

        var newNodePosition = sc.displaceNode(nodesOnScreen[k], centre, r);

        //Translate
        nodesOnScreen[k].to_x = newNodePosition.x;
        nodesOnScreen[k].to_y = newNodePosition.y;

        //Passed to animator
        unselectedNodes.push(nodesOnScreen[k].id);
      }
    }

    //Animate the transition
    sigma.plugins.animate(
      sc.sigmaInstance, {
        x: 'to_x',
        y: 'to_y'
      }, {
        duration: sc.nodeMovementTime,
        easing: 'cubicInOut',
        nodes: toMove.concat(unselectedNodes)
      }
    );

  };

  SocialChartCtrl.prototype.displaceNode = function (nodeToMove, centre, radius, prefix) {
    var sc = this;

    if (!prefix) {
      prefix = "";
    }
    //Get the translation
    var nX = (nodeToMove[prefix + 'x'] || nodeToMove.x);
    var nY = (nodeToMove[prefix + 'y'] || nodeToMove.y);
    var cX = (centre[prefix + 'x'] || centre.x);
    var cY = (centre[prefix + 'y'] || centre.y);
    //Min. to 1 in case the points are on top of each other
    var displaceToX = Math.max(Math.abs(nX - cX), 1);
    var displaceToY = Math.max(Math.abs(nY - cY), 1);

    //Closer nodes should be moved further away
    var distance = sc.getDistance(nodeToMove, centre, prefix);
    radius = Math.max(((distance * distance * -1) + radius * 3), 1);

    //Get the direction of the translation
    if (nX > cX) {
      displaceToX *= radius;
    } else if (nX < cX) {
      displaceToX *= -radius;
    }

    if (nY > cY) {
      displaceToY *= radius;
    } else if (nY < cY) {
      displaceToY *= -radius;
    }

    return {
      'x': nX + displaceToX,
      'y': nY + displaceToY
    };
  };

  SocialChartCtrl.prototype.detectCollision = function (nodeA, prefixA, nodeB, prefixB) {

    prefixA = prefixA || "";
    prefixB = prefixB || "";

    var p1 = {
      x: nodeA[prefixA + 'x'] || nodeA.x,
      y: nodeA[prefixA + 'y'] || nodeA.y
    };
    var p2 = {
      x: nodeB[prefixB + 'x'] || nodeB.x,
      y: nodeB[prefixB + 'y'] || nodeB.y
    };

    var d = Math.sqrt(Math.pow(Math.abs(p1.x - p1.x), 2) + Math.pow(Math.abs(p1.y - p2.y), 2));

    if (isNaN(d)) {
      return false;
    }
    return d < 1;

  };

  SocialChartCtrl.prototype.clickEdge = function (edge, applyInProgress, containerDimensions) {
    var sc = this;

    //setting title
    if (sc.socialChartTitle !== undefined && sc.chartTitle.edgeSelectedTitle !== undefined) {
      var source = edge.getSourceNode();
      var target = edge.getTargetNode();
      sc.socialChartTitle = sc.chartTitle.edgeSelectedTitle.replace("{{source}}", source.label)
        .replace("{{target}}", target.label);
      sc.updateTitle = true;
      sc.setTitleTimer();
    }

    sc.mouseLeaveUIElement();

    sc.selectEdge(edge, applyInProgress);
    //dim all the nodes except source and target
    sc.sigmaInstance.graph.nodes().forEach(function (n) {
      n.selected = false;
      n.rendered = false;
      n.bringToFront = false;
      if (n.id !== edge.source && n.id !== edge.target) {
        n.color = sc.sigmaInstance.settings("hiddenNodeColor") || '#315351';
        n.showLabel = false;
      } else {
        n.color = n.originalColour;
        n.showLabel = true;
        n.bringToFront = true;
      }
    });
    //dim all the other edges
    sc.sigmaInstance.graph.edges().forEach(function (e) {
      e.selected = false;
      e.bringToFront = false;
      e.color = sc.sigmaInstance.settings("hiddenEdgeColor") || '#324342';
      e.hover_color = sc.sigmaInstance.settings("hiddenEdgeColor") || '#324342';
    });
    //highlight this edge
    edge.bringToFront = true;
    edge.selected = true;
    edge.color = sc.sigmaInstance.settings("defaultEdgeHoverColor") || '#2AD2C9';
    edge.hover_color = sc.sigmaInstance.settings("defaultEdgeHoverColor") || '#2AD2C9';

    //no need to hover anything now
    sc.hoveredItem = null;

    if (sc.api.onEdgeClick) {
      sc.api.onEdgeClick(edge);
    }

    /*
    Get camera position
    */
    //1. Get the two nodes
    var sourceNode = edge.getSourceNode();
    var targetNode = edge.getTargetNode();
    if (sourceNode && targetNode) {
      //2. Determine the centre position between the two
      var edgeX = (sourceNode['read_cam0:x'] + targetNode['read_cam0:x']) / 2;
      var edgeY = (sourceNode['read_cam0:y'] + targetNode['read_cam0:y']) / 2;

      //3.Calculate the zoom level to show both nodes, based on their distance
      var zoomToLevel = sc.getZoomRatio(sourceNode, [targetNode], containerDimensions);

      //4. Move the camera
      sc.zoomTo(edgeX, edgeY, zoomToLevel);

    }

    sc.sigmaInstance.refresh();
  };

  SocialChartCtrl.prototype.clickStage = function (e) {
    var sc = this;
    //setting title
    if (sc.socialChartTitle !== undefined && sc.chartTitle.stageSelectedTitle !== undefined) {
      sc.socialChartTitle = sc.chartTitle.stageSelectedTitle;
      sc.updateTitle = true;
      sc.setTitleTimer();
    }

    sc.mouseLeaveUIElement();

    if (sc.selectedNode) {
      sc.selectedNode.rendered = false;
      sc.selectedNode.selected = false;
    }

    sc.clearSelected(!e); //if Event is defined, this call originated internally so a digest is not in progress

    //reset all the nodes and edges
    sc.sigmaInstance.graph.nodes().forEach(function (n) {
      n.color = n.originalColour;
      n.selected = false;
      n.showLabel = false;
      n.bringToFront = false;
      if (n.originalX) {
        n.x = n.originalX;
        n.y = n.originalY;
        n.originalX = null;
        n.originalY = null;
      }
    });

    sc.sigmaInstance.graph.edges().forEach(function (e) {
      e.color = e.originalColour;
      e.hover_color = null;
      e.selected = false;
      e.bringToFront = false;
    });

    if (sc.api.onStageClick) {
      sc.api.onStageClick();
    }

    sc.sigmaInstance.refresh();


    sc.zoomTo(0, 0, 1);

  };

  SocialChartCtrl.prototype.setClickEvent = function () {
    var sc = this;

    //Store label thresholds to vary them as the camera zooms
    sc.originalLabelTheshold = sc.sigmaInstance.settings("labelTheshold") || 7;
    sc.zoomedLabelTheshold = Math.floor(sc.originalLabelTheshold / 2);

    var resetLabelThreshold = function () {
      sc.sigmaInstance.settings("labelTheshold", sc.originalLabelTheshold);
    };

    var setZoomedThreshold = function () {
      sc.sigmaInstance.settings("labelTheshold", sc.zoomedLabelTheshold);
    };

    //initialise by storing the original node and edge colours
    sc.sigmaInstance.graph.nodes().forEach(function (n) {
      n.originalColour = n.color;
      n.selected = false;
    });
    sc.sigmaInstance.graph.edges().forEach(function (e) {
      e.originalColour = e.color;
    });

    //bind the click event
    sc.sigmaInstance.bind("clickNode", function (e) {
      var containerDimensions = {
        'width': e.data.renderer.width,
        'height': e.data.renderer.height
      };
      setZoomedThreshold();
      sc.clickNode(e.data.node, containerDimensions);

    });

    sc.sigmaInstance.bind("clickStage", function (e) {

      if (e.data.captor.isDragging) {
        return;
      }
      resetLabelThreshold();
      sc.clickStage(e);

    });

    sc.sigmaInstance.bind("clickEdge", function (e) {
      var containerDimensions = {
        'width': e.data.renderer.width,
        'height': e.data.renderer.height
      };

      resetLabelThreshold();
      sc.clickEdge(e.data.edge, false, containerDimensions);

    });
  };

  SocialChartCtrl.prototype.setHoverEvent = function () {
    var sc = this;

    sc.sigmaInstance.bind("outEdge", function () {
      sc.fixEdgeHover();
    });

  };

  SocialChartCtrl.prototype.fixEdgeHover = function () {
    var sc = this;

    if (sc.edgeHoverTimer) {
      sc.$timeout.cancel(sc.edgeHoverTimer);
    }

    sc.edgeHoverTimer = sc.safeTimeout(function () {
      sigma.misc.drawHovers.clearHover();
      sc.sigmaInstance.refresh();
    }, sc.nodeMovementTime);
  };

  SocialChartCtrl.prototype.cancelPopover = function () {
    var sc = this;
    sc.hoveredItem = null;

    if (sc.hoverTimerReplacement) {
      sc.$timeout.cancel(sc.hoverTimerReplacement);
    }

    if (sc.hoverTimer) {
      sc.$timeout.cancel(sc.hoverTimer);
    }

    if (sc.edgeHoverTimer) {
      sc.$timeout.cancel(sc.edgeHoverTimer);
    }

    sigma.misc.drawHovers.clearHover();
  };

  SocialChartCtrl.prototype.getHoveredNodes = function (coordinates) {

    if (coordinates && coordinates.stageX) {
      var point = {
        data: {
          'x': coordinates.stageX,
          'y': coordinates.stageY
        }
      };

      var nodes = sigma.misc.bindEvents.getNodes(point);

      return nodes;

    }
    return [];
  };

  SocialChartCtrl.prototype.getHoveredEdges = function (coordinates) {

    if (coordinates && coordinates.stageX) {
      var point = {
        data: {
          'x': coordinates.stageX,
          'y': coordinates.stageY
        }
      };

      var edges = sigma.misc.bindEvents.getEdges(point);

      return edges;

    }
    return [];
  };

  SocialChartCtrl.prototype.startHoverTimeout = function (initialPosition) {
    var sc = this;

    //If there is a tooltip already, check if we need to change or remove it
    if (sc.hoveredItem) {
      //Check if the mouse is close enough to still show the tooltip
      if (sc.outOfTooltipBounds(initialPosition, sc.hoveredItem.initialPosition)) {
        sigma.misc.drawHovers.clearHover();
        sc.hoveredItem = null;
        sc.enableHover();
        sc.sigmaInstance.refresh();
      } else {
        if (sc.hoverTimerReplacement) {
          sc.$timeout.cancel(sc.hoverTimerReplacement);
          sc.hoverTimerReplacement = null;

          if (sc.hoverTimer) {
            sc.$timeout.cancel(sc.hoverTimer);
          }

          sc.hoverTimer = null;
        }
        //within tooltip bounds, but check for another node being hovered
        //NB: not edge
        var hoverReplacement = sc.getHoveredNodes(sc.mousePosition);
        //if the cursor is over another node
        if (hoverReplacement.length) {
          sc.hoverTimerReplacement = sc.safeTimeout(function () {
            //Update if there is no hoveredItem, or if there is but the candidate is different
            if (((sc.hoveredItem) && (hoverReplacement[0].id !== sc.hoveredItem.id)) ||
              (!sc.hoveredItem)) {
              sc.updateHoveredItem(hoverReplacement[0], "node", initialPosition);
            }
          }, sc.hoverDelay);
        }
      }
      return;
    }

    //Cancel existing promises - we only ever have one candidate item to hover
    if (sc.hoverTimer && (initialPosition.movementX > 1 || initialPosition.movementY > 1)) {
      sc.$timeout.cancel(sc.hoverTimer);
      sc.hoverTimer = null;

      if (sc.hoverTimerReplacement) {
        sc.$timeout.cancel(sc.hoverTimerReplacement);
      }

      sc.hoverTimerReplacement = null;
    }

    //Start a countdown to show a tooltip for this item
    sc.hoverTimer = sc.safeTimeout(function () {

      //NB: Sqrt this value for actual distance
      var mouseMovementSq = Math.pow(Math.abs(initialPosition.clientX - sc.mousePosition.clientX), 2) + Math.pow(Math.abs(initialPosition.clientY - sc.mousePosition.clientY), 2);

      if ((mouseMovementSq < 50) && (!sc.mouseOverUI)) {
        var nodes = sc.getHoveredNodes(sc.mousePosition);
        if (nodes.length) {
          sc.updateHoveredItem(nodes[0], "node", initialPosition);
        } else {
          var edges = sc.getHoveredEdges(sc.mousePosition);
          if (edges.length) {
            sc.updateHoveredItem(edges[0], "edge", initialPosition);
          }
        }

      }

    }, sc.hoverDelay);
  };

  SocialChartCtrl.prototype.outOfTooltipBounds = function (mousePosition, hoverItemPosition) {
    var sc = this;
    sc.hoveredItem.popoverWidth = sc.hoveredItem.popoverWidth || angular.element(".sigma-chart-popover").width();
    sc.hoveredItem.popoverHeight = sc.hoveredItem.popoverHeight || angular.element(".sigma-chart-popover").height();

    switch (sc.popoverPosition) {
      case "bottom":
        return sc.outOfTooltipBoundsBottom(mousePosition, hoverItemPosition);

      case "top":
        return sc.outOfTooltipBoundsTop(mousePosition, hoverItemPosition);

      case "right":
        return sc.outOfTooltipBoundsRight(mousePosition, hoverItemPosition);

      case "left":
        return sc.outOfTooltipBoundsLeft(mousePosition, hoverItemPosition);

      case "default":
        return true;

    }
  };

  SocialChartCtrl.prototype.outOfTooltipBoundsBottom = function (mousePosition, hoverItemPosition) {
    var sc = this;
    //left
    if (mousePosition.clientX < hoverItemPosition.clientX - (sc.hoveredItem.popoverWidth / 2)) return true;
    //bottom boundary
    if (mousePosition.clientY > (hoverItemPosition.clientY + sc.hoveredItem.popoverHeight + 10)) return true;
    //right boundary
    if (mousePosition.clientX > hoverItemPosition.clientX + (sc.hoveredItem.popoverWidth / 2)) return true;
    //top boundary
    if (mousePosition.clientY < hoverItemPosition.clientY - 5) return true;
    return false;
  };

  SocialChartCtrl.prototype.outOfTooltipBoundsTop = function (mousePosition, hoverItemPosition) {
    var sc = this;
    //left
    if (mousePosition.clientX < hoverItemPosition.clientX - (sc.hoveredItem.popoverWidth)) return true;
    //bottom boundary
    if (mousePosition.clientY > (hoverItemPosition.clientY + 10)) return true;
    //right boundary
    if (mousePosition.clientX > hoverItemPosition.clientX + (sc.hoveredItem.popoverWidth)) return true;
    //top boundary
    if (mousePosition.clientY < hoverItemPosition.clientY - sc.hoveredItem.popoverHeight - 15) return true;
    return false;
  };

  SocialChartCtrl.prototype.outOfTooltipBoundsLeft = function (mousePosition, hoverItemPosition) {
    var sc = this;
    //left
    if (mousePosition.clientX < hoverItemPosition.clientX - sc.hoveredItem.popoverWidth) return true;
    //bottom boundary
    if (mousePosition.clientY > (hoverItemPosition.clientY + (sc.hoveredItem.popoverHeight / 2) + 10)) return true;
    //right boundary
    if (mousePosition.clientX > hoverItemPosition.clientX + 10) return true;
    //top boundary
    if (mousePosition.clientY < hoverItemPosition.clientY - (sc.hoveredItem.popoverHeight / 2) + 10) return true;
    return false;
  };

  SocialChartCtrl.prototype.outOfTooltipBoundsRight = function (mousePosition, hoverItemPosition) {
    var sc = this;
    //left
    if (mousePosition.clientX < hoverItemPosition.clientX - 5) return true;
    //bottom boundary
    if (mousePosition.clientY > (hoverItemPosition.clientY + (sc.hoveredItem.popoverHeight / 2) + 10)) return true;
    //right boundary
    if (mousePosition.clientX > hoverItemPosition.clientX + (sc.hoveredItem.popoverWidth) + 10) return true;
    //top boundary
    if (mousePosition.clientY < hoverItemPosition.clientY - (sc.hoveredItem.popoverHeight / 2) + 10) return true;
    return false;
  };

  SocialChartCtrl.prototype.updateHoveredItem = function (hoverCandidate, itemType, initialPosition) {
    var sc = this;

    if (sc.hoveredItem === hoverCandidate) return;

    sc.hoveredItem = hoverCandidate;
    sc.hoveredItem.initialPosition = initialPosition;
    sc.hoveredItem.node = false;
    sc.hoveredItem.edge = false;

    sc.hoveredItem.popoverDirection = sc.popoverDirectionFromElement(initialPosition);

    if (itemType === "node") {
      var screenRelativeNodePosition = sc.getNodePosition(hoverCandidate);

      if (sc.api.onNodeHover) {
        sc.api.onNodeHover(sc.hoveredItem);
      }

      sc.updateNodePopoverPosition(screenRelativeNodePosition.x, screenRelativeNodePosition.y, screenRelativeNodePosition.size, sc.hoveredItem.popoverDirection);
      sc.hoveredItem.node = true;
    } else if (itemType === "edge") {
      var edgeCaptorPosition = sc.getClientPosition(sc.mousePosition);

      if (sc.api.onEdgeHover) {
        sc.api.onEdgeHover(sc.hoveredItem);
      }

      sc.updateEdgePopoverPosition(edgeCaptorPosition.x, edgeCaptorPosition.y, sc.hoveredItem.popoverDirection);
      sc.hoveredItem.edge = true;
    }

    sc.delayPopoverUntilRender();
  };

  SocialChartCtrl.prototype.delayPopoverUntilRender = function () {
    var sc = this;

    if (!sc.popoverDelayTimer) {

      sc.nodePopoverStyle.visibility = 'hidden';
      sc.edgePopoverStyle.visibility = 'hidden';

      //this is required to let scrollbar render without any flickering
      sc.popoverDelayTimer = sc.safeTimeout(function () {
        sc.nodePopoverStyle.visibility = '';
        sc.edgePopoverStyle.visibility = '';
        sc.$timeout.cancel(sc.popoverDelayTimer);
        sc.popoverDelayTimer = null;
      }, 5);
    }
  };

  SocialChartCtrl.prototype.getClientPosition = function (event) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  };

  SocialChartCtrl.prototype.getNodePosition = function (node) {
    var sc = this;
    var prefix = sc.getPrefix("renderer")();
    return {
      x: node[prefix + "x"] + (sc.chartPosition ? sc.chartPosition.offsetLeft : 0),
      y: node[prefix + "y"] + (sc.chartPosition ? sc.chartPosition.offsetTop : 0),
      size: node[prefix + "size"]
    };
  };

  /*
  This function calculates the position for the popover, based on which side of the element it needs to be appear on.
  The horizontal positions (centre, left, right) can be paired with any vertical position (centre, top, bottom)
  */
  SocialChartCtrl.prototype.setPopoverOffsets = function (position, clientRect, x, y, size, popoverWidth, popoverHeight) {

    var offset = {
      left: 0,
      top: 0
    };

    var padding = 20;
    var verticalCentrePadding = 18;
    var leftAdjust = 9;
    var rightAdjust = 6;

    if (position.centreH) {
      offset.left = parseInt(x) - clientRect.left - (popoverWidth / 2);
    } else if (position.left) {
      offset.left = position.centreV ?
        parseInt(x) - clientRect.left - (popoverWidth) - padding - leftAdjust :
        parseInt(x) - clientRect.left - (popoverWidth / 2) - padding - Math.max(((popoverWidth / 2) - position.left), 0);
    } else if (position.right) {
      offset.left = position.centreV ?
        parseInt(x) - clientRect.left + padding + rightAdjust :
        parseInt(x) - clientRect.left - (popoverWidth / 2) + padding + Math.max(((popoverWidth / 2) - position.right), 0);
    }

    if (position.centreV) {
      offset.top = parseInt(y) - clientRect.top - window.pageYOffset - (popoverHeight / 2) - size + verticalCentrePadding;
    } else if (position.bottom) {
      offset.top = parseInt(y) - clientRect.top - window.pageYOffset + size + padding;
    } else if (position.top) {
      offset.top = parseInt(y) - clientRect.top - window.pageYOffset - popoverHeight - size;
    }

    return offset;
  };

  SocialChartCtrl.prototype.setPopoverCallout = function (position, offset, x, y, popoverWidth) {
    var sc = this;

    //Pick a style (moves the callout arrow)
    sc.popoverPosition = "";

    if (position.centreV) {
      if (position.left) {
        sc.popoverPosition = "left";
      }
      if (position.right) {
        sc.popoverPosition = "right";
      }
    } else {
      if (position.top) {
        sc.popoverPosition = "top";
      }
      if (position.bottom) {
        sc.popoverPosition = "bottom";
      }
    }

    //If contained within a modal, don't adjust popover
    if ($('.modal').length > 0) return;

    //Determine if the callout needs to be moved
    sc.popoverArrowStyle = {};
    if (position.top) {
      if (position.left) {
        sc.popoverArrowStyle = {
          position: 'relative',
          top: '100%',
          width: 0,
          left: popoverWidth - position.left
        };
      } else if (position.right) {
        var menuAdjust = sc.menuVisible ? 220 : 0;
        sc.popoverArrowStyle = {
          position: 'relative',
          right: Math.max((popoverWidth / 2) - x - offset.left - menuAdjust, 0),
          top: '100%'
        };
      }
    }

  };

  SocialChartCtrl.prototype.updateNodePopoverPosition = function (x, y, size, position) {
    var sc = this;
    var clientRect = sc.getContainer()[0].getElementsByClassName("sigma-wrapper")[0].getBoundingClientRect();
    var popoverWidth = 378;
    var popoverHeight = 200;

    //Set the positions
    var offset = sc.setPopoverOffsets(position, clientRect, x, y, size, popoverWidth, popoverHeight);

    //Determine which style is needed for the callout
    sc.setPopoverCallout(position, offset, x + window.pageXOffset, y + window.pageYOffset, popoverWidth, popoverHeight);

    //reset set the popover accordingly if the chart is contained within a modal, otherwise the popover doesn't take the modal positioning into account
    var modalOffset;
    var topOffset = 0,
      leftOffset = 0;

    //if we have a modal, then get the offset of the sigma container of the chart within that modal
    if ($('.modal').length > 0)
      modalOffset = $('#sigma-container').offset();

    if (modalOffset !== undefined) {
      topOffset = modalOffset.top;
      leftOffset = modalOffset.left;
    }

    if (isNaN(offset.left) === false) {
      sc.nodePopoverStyle.left = offset.left + leftOffset + "px";
    }

    if (isNaN(offset.top) === false) {
      sc.nodePopoverStyle.top = offset.top + topOffset + "px";
    }

  };

  SocialChartCtrl.prototype.updateEdgePopoverPosition = function (x, y, position) {
    var sc = this;
    var clientRect = sc.getContainer()[0].getElementsByClassName("sigma-wrapper")[0].getBoundingClientRect();
    var popoverWidth = 526;
    var popoverHeight = 200;

    //Set the positions
    var offset = sc.setPopoverOffsets(position, clientRect, x + window.pageXOffset, y + window.pageYOffset, 0, popoverWidth, popoverHeight);

    //Determine which style is needed for the callout
    sc.setPopoverCallout(position, offset, x, y, popoverWidth, popoverHeight);

    if (isNaN(offset.left) === false) {
      sc.edgePopoverStyle.left = offset.left + "px";
    }

    if (isNaN(offset.top) === false) {
      sc.edgePopoverStyle.top = offset.top + "px";
    }

  };

  SocialChartCtrl.prototype.popoverDirectionFromElement = function (mousePosition) {
    var clientW = (document.documentElement.clientWidth || document.body.clientWidth);
    var clientH = (document.documentElement.clientHeight || document.body.clientHeight);
    var mX = mousePosition.clientX;
    var mY = mousePosition.clientY;

    var marginX = clientW / 4;
    var marginY = clientH / 4;
    var leftBound = marginX;
    var rightBound = clientW - marginX;
    var bottomBound = clientH - marginY;

    var position = {};

    if (mX <= leftBound) {
      position.right = mX;
    } else if (mX >= rightBound) {
      position.left = clientW - mX;
    } else {
      position.centreH = true;
    }
    if (mY > bottomBound) {
      position.top = true;
    } else {
      if (position.right || position.left) {
        position.centreV = true;
      } else {
        position.bottom = true;
      }
    }
    return position;
  };

  SocialChartCtrl.prototype.leavePopover = function () {
    sigma.misc.drawHovers.clearHover();
  };

  SocialChartCtrl.prototype.disableHover = function () {
    var sc = this;
    sc.sigmaInstance.settings("disableHover", true);
  };

  SocialChartCtrl.prototype.enableHover = function () {
    var sc = this;
    sc.sigmaInstance.settings("disableHover", false);
  };

  SocialChartCtrl.prototype.mouseLeaveUIElement = function () {
    var sc = this;
    sc.mouseOverUI = false;
    sc.enableHover();
  };

  SocialChartCtrl.prototype.mouseEnterUIElement = function () {
    var sc = this;
    sc.cancelPopover();
    sc.mouseOverUI = true;
    sc.disableHover();
    sc.sigmaInstance.refresh();
  };

  SocialChartCtrl.prototype.setMenuDisplacement = function (wrapperOffset) {
    var sc = this;
    sc.chartPosition = wrapperOffset;
    sc.menuVisible = !!wrapperOffset.offsetLeft;
    sc.nodeDetailStyle.right = (sc.isFullscreen) ? wrapperOffset.offsetLeft + "px" : 0;
    sc.edgeDetailStyle.right = (sc.isFullscreen) ? wrapperOffset.offsetLeft + "px" : 0;
  };

  SocialChartCtrl.prototype.setCameraEvent = function () {
    var sc = this;
    //Default zoom level
    sc.sigmaInstance.settings('zoomLevel', 1);

    //Used to return the camera to a position where the graph is acceptably visible
    sc.lastPosition = [0, 0, 1];

    //Once we override the camera position, this flag stops us overriding it again until it has finished moving
    sc.lastPosition.skipZoom = false;

    sc.sigmaInstance.camera.bind("coordinatesUpdated", function (e) {

      //Save the current zoom level for the renderers which require it
      sc.sigmaInstance.settings('zoomLevel', e.target.ratio);

      //Remove the hover popover
      sc.cancelPopover();

      var dimensions = {
        'width': e.target.quadtree._tree.bounds.width,
        'height': e.target.quadtree._tree.bounds.height
      };

      //ensure the minimum number of node labels are added
      sc.showMinimumLabels();

      if (!inBounds(e.target.x, e.target.y, e.target.ratio, dimensions)) {

        if (!sc.lastPosition.skipZoom) {

          //Return the camera to the last acceptable position
          sc.lastPosition.skipZoom = true;
          sc.zoomTo(sc.lastPosition[0], sc.lastPosition[1], sc.lastPosition[2]);

          sc.safeTimeout(function () {
            //After the transition has finished, resume checking for 'out of bounds' positions
            sc.lastPosition.skipZoom = false;
          }, (sc.sigmaInstance.settings('animationsTime') || 300) + 100);
        }

      } else {
        //The camera position was in bounds; so save this as the last known acceptable position
        sc.lastPosition = [e.target.x, e.target.y, e.target.ratio];
      }
    });

    //calculates if the camera position is within a certain margin of the viewport at a given zoom level
    var inBounds = function (x, y, r, dimensions) {
      var containerWidth = dimensions.width * 0.6;
      var containerHeight = dimensions.height * 0.75;
      x = Math.abs(x);
      y = Math.abs(y);
      return (x < containerWidth && y < containerHeight);
    };
  };

  /*
    Always show a certain number of labels on screen
  */
  SocialChartCtrl.prototype.showMinimumLabels = function () {
    var sc = this;

    var camera = sc.sigmaInstance.camera;

    //ensure we actually want to show a certain number of labels and dimensions are available
    if (sc.minLabels === null || sc.minLabels === undefined || !angular.isNumber(sc.minLabels) || camera.quadtree._tree === null) return;

    //Get the width and height of the container
    var dimensions = {
      'width': camera.quadtree._tree.bounds.width,
      'height': camera.quadtree._tree.bounds.height
    };

    sc.sigmaInstance.graph.nodes().forEach(function (n) {
      n.showLabel = false;
    });

    //get all visible nodes in screen
    var nodesOnScreen = camera.quadtree.area(camera.getRectangle(dimensions.width * camera.ratio, dimensions.height * camera.ratio));

    //find nodes with focus if there are any - dont consider just the ones on screen
    var bringToFront = sc.sigmaInstance.graph.nodes().filter(function (node) {
      return node.bringToFront;
    });

    //if any nodes are selected then we only want to label them - otherwise it should be based on size
    var targetNodes = bringToFront.length === 0 ? nodesOnScreen : bringToFront;

    //sort by size - largest first
    var ordered = targetNodes.sort(function (a, b) {
      if (a.size > b.size) return -1;
      if (a.size < b.size) return 1;
      return 0;
    });

    //show all labels
    var labelCount = Math.min(ordered.length, sc.minLabels);

    for (var i = 0; i < labelCount; i++) {
      ordered[i].showLabel = true;
    }

  };

  /*
  This function determines a zoom ratio that will attempt to make
  all 1st degree neighbours of the selected node visible
  */
  SocialChartCtrl.prototype.getZoomRatio = function (centreNode, neighbours, dimensions) {
    var sc = this;
    var maxDistance = 0;
    var furthestNode = centreNode;

    //Identify the node furthest from the selected
    Object.keys(neighbours).forEach(function (el) {
      el = neighbours[el];
      var distance = sc.getDistance(centreNode, el);

      if (distance > maxDistance) {
        maxDistance = distance;
        furthestNode = el;
      }
    });

    var ratio = maxDistance * 2 / Math.min(dimensions.height, dimensions.width);

    return (ratio < sc.sigmaInstance.settings('zoomMin')) ? sc.sigmaInstance.settings('zoomMin') : ratio;
  };

  //calculates the distance between two nodes
  SocialChartCtrl.prototype.getDistance = function (a, b, propertyPrefix) {
    var sc = this;

    if (!propertyPrefix) {
      if (propertyPrefix !== "") {
        propertyPrefix = sc.getPrefix("camera")();
      }
    }
    var nodeA = {
      x: a[propertyPrefix + 'x'] || a.x,
      y: a[propertyPrefix + 'y'] || a.y
    };
    var nodeB = {
      x: b[propertyPrefix + 'x'] || b.x,
      y: b[propertyPrefix + 'y'] || b.x
    };
    return Math.sqrt(Math.pow(Math.abs(nodeA.x - nodeB.x), 2) + Math.pow(Math.abs(nodeA.y - nodeB.y), 2));
  };

  SocialChartCtrl.prototype.zoomTo = function (x, y, r, zoomCallback) {
    var sc = this;

    if (sc.selectedNode) {
      sc.selectedNode.rendered = false;
    }

    sc.safeTimeout(function () {
      sigma.misc.animation.camera(
        sc.sigmaInstance.cameras[0], {
          'x': x,
          'y': y,
          ratio: r
        }, {
          duration: sc.sigmaInstance.settings('animationsTime') || 300
        }
      );
      sc.safeTimeout(function () {
          sc.sigmaInstance.refresh();

          if (sc.selectedNode) {
            sc.selectedNode.rendered = true;
          }

          if (zoomCallback) {
            zoomCallback();
          }
          sc.deselectText();
        },
        (sc.sigmaInstance.settings('animationsTime') || 300) + 100
      );
    }, 100);

  };

  SocialChartCtrl.prototype.top = function () {
    var sc = this;
    sc.cancelPopover();
    sc.clickStage();
  };

  SocialChartCtrl.prototype.zoomIn = function () {
    var sc = this;
    sc.cancelPopover();
    var zoomDelay = sc.sigmaInstance.settings('zoomingRatio') || 1.7;
    var ratio = sc.sigmaInstance.camera.ratio / zoomDelay;
    sc.zoomTo(sc.sigmaInstance.camera.x,
      sc.sigmaInstance.camera.y,
      (ratio > sc.sigmaInstance.settings('zoomMin')) ? ratio : sc.sigmaInstance.settings('zoomMin')
    );
  };

  SocialChartCtrl.prototype.zoomOut = function () {
    var sc = this;
    sc.cancelPopover();
    if (sc.sigmaInstance.settings('zoomMax') - sc.sigmaInstance.camera.ratio <= 0.01) return;
    var zoomDelay = sc.sigmaInstance.settings('zoomingRatio') || 1.7;
    var ratio = sc.sigmaInstance.camera.ratio * zoomDelay;
    sc.zoomTo(sc.sigmaInstance.camera.x,
      sc.sigmaInstance.camera.y,
      (ratio < sc.sigmaInstance.settings('zoomMax')) ? ratio : sc.sigmaInstance.settings('zoomMax')
    );
  };

  SocialChartCtrl.prototype.safeTimeout = function (func, delay) {
    var sc = this;
    //Set a timer
    var timeout = sc.$timeout(decoratedFunc, delay);

    //Record the timer
    sc.timers[timeout.$$timeoutId] = timeout;

    //Return the passthrough result from the timer call
    return timeout;

    //Set timer with wrapper that records when the timeout has executed
    function decoratedFunc() {
      try {
        delete sc.timers[timeout.$$timeoutId];
        return func();
      } catch (e) {
        console.info(e);
      }
    }

  };

  SocialChartCtrl.prototype.popoverClick = function () {
    var sc = this;

    if (sc.hoveredItem) {

      var id = sc.hoveredItem.id;

      var hoveredPosition = {
        x: sc.hoveredItem.initialPosition.clientX,
        y: sc.hoveredItem.initialPosition.clientY
      };
      var mousePosition = {
        x: sc.mousePosition.clientX,
        y: sc.mousePosition.clientY
      };

      //allow clickthough to the selected item
      //if the popover click occurred on the item itself
      if (id[0] === 'e') {
        var edges = sc.getHoveredEdges(sc.mousePosition);
        if ((edges.length && edges[0].id === id) || (sc.getDistance(mousePosition, hoveredPosition, "") < 13)) {
          (sc.setSelectedEdgeById())(id);
        }
      } else {
        var nodes = sc.getHoveredNodes(sc.mousePosition);
        if ((nodes.length && nodes[0].id === id) || (sc.getDistance(mousePosition, hoveredPosition, "") < 13)) {
          sc.hoveredItem = null;
          (sc.setSelectedNodeById())(id);
        }
      }
    }
  };

  SocialChartCtrl.prototype.getPrefix = function (prefixStr) {
    var sc = this;
    var renderId = sc.sigmaInstance.renderers[0].conradId;
    var cameraPrefix = sc.sigmaInstance.camera.readPrefix;

    function getRenderPrefix() {
      return prefixStr + renderId + ":";
    }

    function getCameraPrefix() {
      return cameraPrefix;
    }

    return prefixStr === "camera" ? getCameraPrefix : getRenderPrefix;
  };

  SocialChartCtrl.prototype.closeDetail = function () {
    var sc = this;
    sc.top();
    sc.mouseLeaveUIElement();
  };

  SocialChartCtrl.prototype.hideCanvas = function () {
    var sc = this;
    sc.getContainer().find("canvas.sigma-edges").hide();
    sc.getContainer().find("canvas.sigma-scene").hide();
    sc.getContainer().find("canvas.sigma-mouse").hide();
  };

  SocialChartCtrl.prototype.showCanvas = function () {
    var sc = this;
    sc.getContainer().find("canvas.sigma-edges").show();
    sc.getContainer().find("canvas.sigma-scene").show();
    sc.getContainer().find("canvas.sigma-mouse").show();
  };

  SocialChartCtrl.prototype.deselectText = function () {
    if (window.getSelection) {
      if (window.getSelection().empty) { // Chrome
        window.getSelection().empty();
      } else if (window.getSelection().removeAllRanges) { // Firefox
        window.getSelection().removeAllRanges();
      }
    } else if (document.selection) { // IE?
      document.selection.empty();
    }
  };

})();;
(function () {

  angular.module("hpe.elements.socialChart").directive("socialChart", socialChart);

  socialChart.$inject = ["$timeout", "$interval"];

  function socialChart($timeout, $interval) {
    return {
      restrict: "E",
      scope: {
        data: "=",
        options: "=?",
        width: "@",
        height: "@",
        api: "=",
        communities: "=?",
        detailStyle: "=?",
        popoverStyle: "=?",
        nodeDetail: "@?",
        edgeDetail: "@?",
        nodePopover: "@?",
        edgePopover: "@?",
        forceAtlasDuration: "=?",
        nodeSizeAttribute: "=?",
        startMaximized: "=?",
        startMaximised: "=?",
        showMaximizeControl: "=?",
        showMaximiseControl: "=?",
        socialChartContainer: "@?",
        fullscreenButtonPosition: "=?",
        localStrings: "=?",
        chartTitle: "=?",
        titleDisplayTime: "=?",
        edgeWeightInfluence: "=?",
        minLabels: "=?"
      },
      controller: "SocialChartCtrl as sc",
      templateUrl: "socialChart/template/socialChart.html",
      link: function (scope, element) {

        var config = {
          'defaultNodeColor': '#2AD2C9',
          'defaultEdgeColor': '#1a8882',
          'defaultLabelColor': 'rgba(255,255,255,0.6)',
          'labelSizeRatio': 2,
          'enableEdgeHovering': true,
          'nodesPowRatio': 0.75,
          'edgesPowRatio': 0,
          'minEdgeSize': 0.5,
          'selectedShadowColorTransparent': 'rgba(69, 148, 219, 0)',
          'selectedEdgeShadowColor': 'rgba(60,148,191,0.1)',
          'selectedShadowColor': '#4594db',
          'edgeHoverColor': 'default',
          'defaultEdgeHoverColor': '#2AD2C9',
          'hoverShadowColor': '#bbb',
          'edgeHoverShadowColor': 'rgba(153,153,153,0.1)',
          'edgeColor': 'default',
          'stageColor': '#2A2A2A',
          'hiddenNodeColor': '#324342',
          'hiddenEdgeColor': '#324342',
          'zoomMax': '1',
          'zoomDelay': 1.7,
          'batchEdgesDrawing': true,
          'hideEdgesOnMove': true,
          'minNodeSize': 2,
          'maxNodeSize': 9,
          'labelThreshold': 7,
          'adjustCameraCenter': true,
          'cameraCenterOffset': 80,
          'skipErrors': true,
          'edgeHoverPrecision': 2,
          'neighborViewOnSelect': true
        };

        scope.sc.id = scope.id;
        scope.sc.getContainer = function () {
          return element;
        };

        //Record the mouse position over the chart for events that require real co-ordinates
        element[0].addEventListener("mousemove", function (event) {
            scope.sc.mousePosition = {
              'clientX': event.clientX,
              'clientY': event.clientY,
              'movementX': event.movementX,
              'movementY': event.movementY,
              'stageX': sigma.utils.getX(event) - sigma.utils.getWidth(event) / 2,
              'stageY': sigma.utils.getY(event) - sigma.utils.getHeight(event) / 2
            };
            scope.sc.startHoverTimeout(scope.sc.mousePosition);

          }.bind(scope.sc),
          false,
          false);

        //Record the mouse leaving
        element[0].addEventListener("mouseleave", function (event) {
            //Kill any events and hover items
            if (!event.toElement || !~event.toElement.className.indexOf("tooltip")) {
              scope.sc.cancelPopover();
              scope.sc.sigmaInstance.refresh();
            }
          }.bind(scope.sc),
          false,
          false);

        var settings = {
          font: 'Metric',
          singleHover: true
        };

        angular.extend(settings, config, (function () {
          return scope.options || {};
        })());

        $timeout(function () {
          var s = new sigma({
            renderer: {
              container: element.find(".sigma-wrapper #sigma-container")[0],
              type: 'canvas'
            },
            settings: settings
          });

          scope.sc.initialise(s);

          var wrapper = angular.element(".sigma-wrapper")[0];
          var positionWatch;
          if (!positionWatch) {
            //There are relatively positioned elements which should be updated when the container moves
            //A $watch is not sufficient here as a $digest is not triggered by non-angular DOM manipulation.
            var top = 0;
            var left = 0;

            positionWatch = $interval(function () {
              var wrapperRect = wrapper.getBoundingClientRect();
              top = wrapperRect.top + angular.element(window).scrollTop();
              left = wrapperRect.left + angular.element(window).scrollLeft();
              scope.sc.setMenuDisplacement({
                'offsetTop': top,
                'offsetLeft': left
              });
              scope.sc.updateChartHeight();
            }, 500);
          }

          scope.$on('$destroy', function () {
            //Cancel the displacement watch
            $interval.cancel(positionWatch);
            positionWatch = undefined;

            //Stop the layout algorithm
            s.stopForceAtlas2();

            //Teardown the chart
            s.kill();

            //Cancel any remaining promises
            for (var timer in scope.sc.timers) {
              $timeout.cancel(scope.sc.timers[timer]);
            }
          });

        });
      }
    };
  }
})();;
(function () {
  angular.module("hpe.elements.sorters", []);
})();;
(function () {
    
  angular.module("hpe.elements.sorters").directive("detailRowHeader", detailRowHeader);

  function detailRowHeader() {
    return {
      restrict: "A",
      controller: "DetailRowHeaderCtrl as vm",
      templateUrl: "sorters/detailRowHeader/template/detailRowHeader.html",
      scope: {
        headers: '='
      },
      bindToController: true
  };
 }
})();;
(function () {

	angular.module('hpe.elements.sorters').controller("DetailRowHeaderCtrl", DetailRowHeaderCtrl);

	function DetailRowHeaderCtrl() {
		var vm = this;

		var sortOrder = [];

		vm.sort = function (header) {

			// if we do not have a sort property then return
			if (!header.sort) {
				return;
			}

			// check if currently sorting
			if (vm.sortingActive(header.sort)) {

				// get the sorter object
				var sorter = getActiveSorter(header.sort);

				// if ascending is false then remove the sorter
				if (sorter.ascending === false) {
					removeSorter(sorter);
				} else {

					// otherwise we want to invert the direction
					sorter.ascending = false;

					// then move to the bottom of the stack
					moveToTail(sorter);
				}


			} else {
				// add sorter to array
				sortOrder.push({
					name: header.sort,
					ascending: true
				});
			}

			// call the select function if there is one
			if (header.select) {

				// get the sorter data in the expected format
				var sorterData = getSorterData();

				// call function with data
				header.select.call(this, sorterData.sorters, sorterData.ascending);
			}
		};

		vm.getSortIcon = function (header) {

			// if not active return null
			if (vm.sortingActive(header.sort) === false) {
				return null;
			}

			// get active sorter object
			var sorter = getActiveSorter(header.sort);

			// return icon based on direction
			return sorter.ascending ? 'hpe-ascend' : 'hpe-descend';
		};

		vm.getSortOrder = function (header) {

			// if only one item is selected then return empty string
			if (sortOrder.length < 2) {
				return '';
			}

			// if the item is not active then also return an empty string
			if (vm.sortingActive(header.sort) === false) {
				return '';
			}

			// otherwise get the sorter object
			var sorter = getActiveSorter(header.sort);

			// find position in array
			var index = sortOrder.indexOf(sorter);

			// return number (incremented by 1 for user friendliness)
			return index + 1;
		};

		vm.sortingActive = function (sorter) {

			// if sorter is not defined return false
			if (!sorter) {
				return false;
			}

			// find any sorters with the same name
			var matchingSorters = sortOrder.filter(function (activeSorter) {
				return activeSorter.name === sorter;
			});

			// return whether any were found
			return matchingSorters.length !== 0;
		};

		// Private Functions
		function getActiveSorter(sorter) {
			// find any sorters with the same name
			var matchingSorters = sortOrder.filter(function (activeSorter) {
				return activeSorter.name === sorter;
			});

			// return whether any were found
			return matchingSorters[0];
		}

		function removeSorter(sorter) {

			// find sorter index
			var index = sortOrder.indexOf(sorter);

			// remove from array
			sortOrder.splice(index, 1);
		}

		function moveToTail(sorter) {

			// remove from the array
			removeSorter(sorter);

			// add to the end of array
			sortOrder.push(sorter);
		}

		function getSorterData() {
			return {
				sorters: sortOrder.map(function (sorter) {
					return sorter.name;
				}),
				ascending: sortOrder.map(function (sorter) {
					return sorter.ascending;
				})
			};
		}

	}

})();;
(function () {

  angular.module("hpe.elements.sorters").directive("detailRowHeaderPopover", detailRowHeaderPopover);

  detailRowHeaderPopover.$inject = ['$templateRequest', '$compile', '$rootScope'];

  function detailRowHeaderPopover($templateRequest, $compile, $rootScope) {
    return {
      restrict: "A",
      scope: {
        detailRowHeaderPopover: '='
      },
      link: function (scope, element) {

        var templateUrl = scope.detailRowHeaderPopover;

        // load template
        var promise = $templateRequest(templateUrl);

        // wait until promise is resolved
        promise.then(function (html) {

          // create scope with function to close popover
          var popoverScope = $rootScope.$new(true);

          // add function to close popover to scope
          popoverScope.closePopover = closePopover;

          // add function to toggle filter icon to scope
          popoverScope.setFilterActive = setFilterActive;

          // compile template
          var template = $compile(html)(popoverScope);

          element.popover({
            html: true,
            template: '<div class="popover detail-row-header-popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>',
            content: template,
            placement: 'bottom',
            animation: false
          });

        });

        // watch for window resize events - we should dismiss to avoid popover misplacement
        window.addEventListener('resize', closePopover.bind(this));

        function closePopover() {
          element.popover('hide');
        }

        function setFilterActive(active) {
          var nativeElement = element[0];
          if (active) {
            nativeElement.classList.remove("hpe-caret-down");
            nativeElement.classList.add("hpe-caret-down-filled");
          } else {
            nativeElement.classList.add("hpe-caret-down");
            nativeElement.classList.remove("hpe-caret-down-filled");
          }
        }
      }
    };
  }
})();;
(function () {

  angular.module('hpe.elements.sorters').controller("MultiSortableHeaderCtrl", MultiSortableHeaderCtrl);

  function MultiSortableHeaderCtrl() {
    var vm = this;

    vm.activeHeaders = [];

    vm.columnData = {};

    // iterate each sorter and generate array for us to work with
    for (var idx = 0; idx < vm.activeSorters.length; idx++) {

      // get the current sorter
      var sorter = vm.activeSorters[idx];

      // if we have a none column then break out of the loop
      if (sorter === null || sorter === undefined || sorter.toLowerCase() === 'none') {
        break;
      }

      // find a matching direction
      var descending = vm.activeOrders[idx];

      // only store the header in the activeHeaders array if a direction was specified
      if (descending === true || descending === false) {

        // store the info in the activeHeaders array
        vm.activeHeaders.push({
          sort: sorter,
          descending: descending
        });
      }
    }

    // update data initially
    updateData();

    vm.select = function (header) {

      // ensure row can be sorted
      if (header.sortable === false) {
        return;
      }

      var existingHeader;

      // check if we are currently sorting by this column
      for (var idx = 0; idx < vm.activeHeaders.length; idx++) {

        // get the current active header
        var activeHeader = vm.activeHeaders[idx];

        // if the selected header is active
        if (activeHeader.sort === header.sort) {

          // store the existing header information
          existingHeader = activeHeader;

          // remove this array item
          vm.activeHeaders.splice(idx, 1);

          // then break out of the loop
          break;
        }
      }

      if (existingHeader) {

        // if previously ascending then change to descending and push to end of queue - otherwise keep deselected
        if (existingHeader.descending === false) {

          // invert sort direction
          existingHeader.descending = true;

          // push on to queue
          vm.activeHeaders.push(existingHeader);
        }

      } else {

        // if not previously existing then add it with default ascending
        vm.activeHeaders.push({
          sort: header.sort,
          descending: false
        });

      }

      // update array bindings
      updateData();

      // call sorting function
      header.select(vm.activeSorters, vm.activeOrders);

    };

    function updateData() {

      // update activeSorters
      vm.activeSorters = vm.activeHeaders.map(function (header) {
        return header.sort;
      });

      vm.activeOrders = vm.activeHeaders.map(function (header) {
        return header.descending;
      });

      // reset column data
      vm.columnData = {};

      // iterate each active header and update data in object so view doesnt call functions on each digest
      vm.activeHeaders.forEach(function (header, index) {

        // store icon and order data
        vm.columnData[header.sort] = {
          icon: header.descending ? 'hpe-descend' : 'hpe-ascend',
          order: index + 1
        };

      });

    }
  }

})();;
(function () {

    angular.module('hpe.elements.sorters').directive('multiSortableHeader', multiSortableHeader);

    multiSortableHeader.$inject = ['$resize', '$timeout'];

    function multiSortableHeader($resize, $timeout) {
        return {
            restrict: "A",
            scope: {
                headers: '=',
                activeSorters: '=defaultSorter',
                activeOrders: '=defaultOrder'
            },
            templateUrl: "sorters/multiSortableHeader/template/multiSortableHeader.html",
            controller: "MultiSortableHeaderCtrl as vm",
            bindToController: true,
            link: function (scope, element) {

                // store reference to native element
                var nativeElement = element.get(0);

                // watch for any changes to children
                var observer = new MutationObserver(initialiseTooltips);

                // wait for initial digest
                $timeout(function () {

                    // begin watching for dom changes
                    observer.observe(nativeElement, {
                        childList: true,
                        subtree: true,
                        characterData: true
                    });

                    // initialise tooltips
                    initialiseTooltips();
                });

                function initialiseTooltips() {

                    // find all column elements
                    var columns = nativeElement.getElementsByTagName('th');

                    // iterate each column
                    for (var idx = 0; idx < columns.length; idx++) {

                        // get current column
                        var column = columns.item(idx);

                        // bind to current function
                        $resize.bind(column, updateTooltip);
                    }

                    // initially update tooltips
                    updateAllTooltips(columns);
                }

                function updateAllTooltips(columns) {

                    // iterate each column and update tooltip
                    for (var idx = 0; idx < columns.length; idx++) {

                        // update column tooltip
                        updateTooltip(columns.item(idx));
                    }
                }

                function updateTooltip(column) {

                    // get label element
                    var label = column.querySelector('.multiSortTitle');

                    // check if requires tooltip
                    var showTooltip = label.offsetWidth < label.scrollWidth;

                    // wrap element
                    var labelElement = angular.element(label);

                    // if doesnt have a tooltip but needs one then add one
                    if (showTooltip === true) {

                        // apply tooltip
                        labelElement.tooltip({
                            title: labelElement.text(),
                            container: 'body'
                        });
                    } else {
                        labelElement.tooltip('destroy');
                    }

                }
            }
        };
    }

})();;
(function () {
  
  angular.module("hpe.elements.sorters").directive("sortDirectionToggle", sortDirectionToggle);

  function sortDirectionToggle() {
    return {
      restrict: "E",
      controller: "SortDirectionToggleCtrl as sdt",
      templateUrl: "sorters/sortDirectionToggle/template/sortDirectionToggle.html",
      scope: {
        label: '=',
        sorters: '=',
        descend: '='
      },
      replace: true
  };
 }
})();;
(function () {
  
  angular.module('hpe.elements.sorters').controller("SortDirectionToggleCtrl", ["$scope", "$element", SortDirectionToggleCtrl]);

  function SortDirectionToggleCtrl($scope, $element) {
    var sdt = this;
    sdt.sorters = $scope.sorters;
    sdt.descend = $scope.descend || false;
    sdt.icon = $element.find('.sort-icon')[0];

    sdt.activeSorter = null;

    //set the default sort details
    for(var i = 0; i<sdt.sorters.length; i++){
      if(sdt.sorters[i].defaultSorter){
        sdt.name = sdt.sorters[i].name;
        sdt.sort = sdt.sorters[i].sort;
        sdt.activeSorter = sdt.sorters[i];
        break;
      }
    }

    // if no sorter has been selected by default select the first sorter
    if(sdt.activeSorter === null){
      sdt.name = sdt.sorters[0].name;
      sdt.sort = sdt.sorters[0].sort;
      sdt.activeSorter = sdt.sorters[0];
    }

    //call the function which sorts the table
    sdt.activeSorter.select(sdt.sort, sdt.descend);


    //called when an item is selected from the dropdown
    sdt.select = function(sorter) {
      //get the index
      sdt.activeSorter = sorter;
      sdt.sort = sorter.sort;
      sdt.name = sorter.name;
      //sort table
      sorter.select(sdt.sort, sdt.descend);
    };

    //called when the ascending/descending icon is clicked
    sdt.toggle = function(){
      //remove focus on click
      sdt.icon.blur();

      if(sdt.descend)
        sdt.descend = false;
      else
        sdt.descend = true;
      
      //sort table
      sdt.activeSorter.select(sdt.sort, sdt.descend);
    };


    //called when the ascending/descending icon is clicked
    sdt.toggleKeypress = function($event){
      if($event.keyCode === 13){

        //remove focus on click
         sdt.icon.blur();
        
        if(sdt.descend)
          sdt.descend = false;
        else
          sdt.descend = true;
        
        //sort table
        sdt.activeSorter.select(sdt.sort, sdt.descend);
      }
    };

  }

})();;
(function () {
  
  angular.module("hpe.elements.sorters").directive("sorter", sorter);

  function sorter() {
    return {
      restrict: "E",
      controller: "SorterCtrl as sc",
      templateUrl: "sorters/sorter/template/sorter.html",
      scope: {
        sorterTitle: "="
      },
     transclude: true,
     replace: true
  };
 }
})();;
(function () {
  
  angular.module('hpe.elements.sorters').controller("SorterCtrl", ["$scope", SorterCtrl]);

  function SorterCtrl($scope) {
    var vm = this;
    vm.sorteroption = $scope;
    vm.default = $scope.title;
    vm.sorteroptions = $scope.sorteroptions = [];
    vm.previousSorter = null;
  }

  SorterCtrl.prototype.setTitle = function (title, defaultval) {
    
    var sorterAlreadySelected = null;
    this.sorteroption.name = title;
    this.sorteroption.class = (!defaultval) ? 'sorter-selected' : '';

    if (this.previousSorter === this) {

      if (defaultval) {
        sorterAlreadySelected = true;
        this.previousSorter = null;
      } else {
        sorterAlreadySelected = false;
        this.previousSorter = this;
      }
    }
  };

  SorterCtrl.prototype.addSorterOptions = function (val) {
    this.sorteroptions.push(val);
  };

})();;
(function () {

  angular.module('hpe.elements.sorters').controller("SorterHeaderCtrl", SorterHeaderCtrl);

  function SorterHeaderCtrl() {
    var vm = this;

    var selectedColumn = {
      header: findHeader(vm.defaultSorter),
      descending: vm.defaultOrder
    };

    vm.select = function (header) {

      // if not a sortable row stop here
      if (!header.sortable) {
        return;
      }

      // if same header then toggle
      if (selectedColumn.header === header) {
        selectedColumn.descending = !selectedColumn.descending;
      } else {
        selectedColumn.header = header;
        selectedColumn.descending = false;
      }

      // call select function if present
      if (header.select) {
        header.select.call(header, selectedColumn.header.sort, selectedColumn.descending);
      }

    };

    vm.getIcon = function (header) {

      if (selectedColumn && selectedColumn.header === header) {
        return selectedColumn.descending ? 'hpe-descend' : 'hpe-ascend';
      }

      return '';
    };

    function findHeader(sort) {

      if (!vm.headers) {
        return null;
      }

      var matches = vm.headers.filter(function (header) {
        return header.sort === sort;
      });

      return matches[0];
    }
  }

})();;
(function () {

    angular.module('hpe.elements.sorters').directive('sortableHeader', sortableHeader);

    sortableHeader.$inject = ['$resize', '$timeout'];

    function sortableHeader($resize, $timeout) {
        return {
            restrict: "A",
            scope: {
                headers: '=',
                defaultSorter: '=',
                defaultOrder: '=',
                fontSize: '=?'
            },
            templateUrl: "sorters/sorterHeader/template/sortableHeader.html",
            controller: "SorterHeaderCtrl as vm",
            bindToController: true,
            link: function (scope, element) {

                // store reference to native element
                var nativeElement = element.get(0);

                // watch for any changes to children
                var observer = new MutationObserver(initialiseTooltips);

                // wait for initial digest
                $timeout(function () {

                    // begin watching for dom changes
                    observer.observe(nativeElement, {
                        childList: true,
                        subtree: true,
                        characterData: true
                    });

                    // initialise tooltips
                    initialiseTooltips();
                });

                function initialiseTooltips() {

                    // find all column elements
                    var columns = nativeElement.getElementsByTagName('th');

                    // iterate each column
                    for (var idx = 0; idx < columns.length; idx++) {

                        // get current column
                        var column = columns.item(idx);

                        // bind to current function
                        $resize.bind(column, updateTooltip);
                    }

                    // initially update tooltips
                    updateAllTooltips(columns);
                }

                function updateAllTooltips(columns) {

                    // iterate each column and update tooltip
                    for (var idx = 0; idx < columns.length; idx++) {

                        // update column tooltip
                        updateTooltip(columns.item(idx));
                    }
                }

                function updateTooltip(column) {

                    // get label element
                    var label = column.querySelector('.sortableHeader');

                    // check if requires tooltip
                    var showTooltip = label.offsetWidth < label.scrollWidth;

                    // wrap element
                    var labelElement = angular.element(label);

                    // if doesnt have a tooltip but needs one then add one
                    if (showTooltip === true) {

                        // apply tooltip
                        labelElement.tooltip({
                            title: labelElement.text(),
                            container: 'body'
                        });
                    } else {
                        labelElement.tooltip('destroy');
                    }

                }

                function destroyTooltips() {

                    // find all column elements
                    var columns = nativeElement.getElementsByTagName('th');

                    // iterate each column
                    for (var idx = 0; idx < columns.length; idx++) {

                        // get current column
                        var column = columns.item(idx);

                        // get label element
                        var label = column.querySelector('.sortableHeader');

                        // wrap element
                        var labelElement = angular.element(label);

                        // destroy tooltip
                        labelElement.tooltip('destroy');

                        // bind to current function
                        $resize.unbind(column, updateTooltip);
                    }
                }

                // ensure we tidy up after
                scope.$on('$destroy', function () {
                    destroyTooltips();
                });
            }
        };
    }
})();;
(function () {

  angular.module('hpe.elements.sorters').controller("SorterOptionCtrl", SorterOptionCtrl);

  SorterOptionCtrl.$inject = ["$scope", "previewPaneProvider"];

  function SorterOptionCtrl($scope, previewPaneProvider) {
    var vm = this;
    vm.selectCallback = $scope.select;
    vm.name = $scope.name;
    vm.default = $scope.default;
    vm.sorterOption = $scope;

    if (vm.default) {
      vm.sorterOption.selectedClass = true;

    }
    vm.sorterOption.provider = previewPaneProvider;
  }

  SorterOptionCtrl.prototype.select = function () {

    this.sorter.setTitle(this.name, this.default);
    for (var i = this.sorter.sorteroptions.length - 1; i >= 0; i--) {
      this.sorter.sorteroptions[i].deselect();
    }
    this.sorterOption.selectedClass = true;
    this.selectCallback();
    this.sorterOption.provider.preview.previewFile = "";
  };

  SorterOptionCtrl.prototype.deselect = function () {
    this.sorterOption.selectedClass = false;
  };

})();;
(function () {

  angular.module("hpe.elements.sorters").directive("sorterOption", sorterOption);

  function sorterOption() {
    return {
      restrict: "E",
      require: '^sorter',
      templateUrl: "sorters/sorterOption/template/sorterOption.html",
      controller: "SorterOptionCtrl as soc",
      transclude: true,
      replace: true,
      scope: {
        name: "=",
        select: "&",
        default: "=",
        iconClass: "=?"
      },
      link: function (scope, element, attrs, controller) {

        scope.soc.sorter = controller;
        scope.soc.sorter.addSorterOptions(scope.soc);

        if (scope.default) {
          controller.setTitle(scope.name, scope.default);
        }
      }
    };
  }
})();;
(function () {
  angular.module("hpe.elements.spark", []);
})();;
(function () {

  angular.module('hpe.elements.spark').controller("SparkCtrl", SparkCtrl);

  function SparkCtrl() {
    var vm = this;

    vm.inline = vm.label !== undefined;

    vm.setPosition = {
      'height': vm.fillheight + 'px',
      'margin-top': (vm.top !== undefined) ? vm.top : 0 + 'px'
    };

  }
})();;
(function () {

  angular.module("hpe.elements.spark").directive("spark", spark);

  function spark() {
    return {
      restrict: "E",
      templateUrl: "spark/template/spark.html",
      controller: "SparkCtrl as sc",
      replace: true,
      scope: {
        type: "=",
        value: "=",
        fillheight: "=",
        label: "=inlineLabel",
        top: "=",
        topLeftLabel: "=",
        topRightLabel: "=",
        bottomLeftLabel: "=",
        bottomRightLabel: "=",
        sparkTooltip: "@?"
      },
      bindToController: true
    };
  }
})();;
(function () {
  angular.module("hpe.elements.splitter", []);
})();;
(function () {

  angular.module("hpe.elements.splitter").directive("splitter", splitter);

  splitter.$inject = ["$compile", "$timeout"];

  function splitter($compile, $timeout) {
    return {
      restrict: "E",
      templateUrl: 'splitter/templates/splitter.html',
      transclude: true,
      replace: true,
      scope: {
        direction: '@',
        gutterSize: '@?',
        snapOffset: '@?',
        onDrag: '=?',
        onDragStart: '=?',
        onDragEnd: '=?',
        reinitialize: '=?'
      },
      link: function (scope, element) {

        var container, panels, horizontal, gutter, options, dragHandle;

        function init() {
          //get splitter container element
          container = element[0];

          //get splitter panels
          panels = getPanels();

          //get direction
          horizontal = scope.direction !== 'vertical';

          //set the orientation class
          element.addClass(horizontal ? 'horizontal' : 'vertical');

          Split(panels, getOptions());

          //Add a side-inset panel style toggle button
          setUpToggleButton();
        }
        scope.reinitialize = function () {
          element.children(".gutter").remove();
          init();
        };

        $timeout(init);



        /*
          Convert HTML Collection to array
        */
        function getPanels() {

          //get panels - but only immediate children!
          var children = container.children;

          var output = [];

          for (var i = 0; i < children.length; i++) {
            var child = angular.element(children[i]);

            if (child.hasClass('splitter-panel')) {
              var panel = children[i];

              //Check if the panel should be hidden
              //This attribute is also used in the plugin and panels hidden here will be exempt from width/height calculations
              if (panel.attributes.getNamedItem("splitter-panel-collapsed")) {

                //Record the 'display' value
                panel._display = panel.style.display;

                //Hide the panel
                panel.style.display = "none";
              } else if (angular.isDefined(panel._display)) {
                //Panel was previously hidden and needs to be shown

                //If the last value was the default, then revert to that default
                if (panel._display === "") {
                  panel.style.removeProperty("display");
                } else {
                  //Otherwise maybe there was a deliberate value we should respect
                  panel.style.display = panel._display;
                }
              }

              output.push(panel);
            }
          }

          return output;
        }

        /*
          Generate the options object based on specified settings
        */
        function getOptions() {
          options = {};

          //mandatory options
          options.direction = horizontal ? 'horizontal' : 'vertical';
          options.sizes = getPanelSizes();
          options.minSize = getMinimumSizes();

          //optional options
          if (scope.gutterSize) options.gutterSize = parseInt(scope.gutterSize);
          if (scope.snapOffset) options.snapOffset = parseInt(scope.snapOffset);
          if (scope.onDrag) options.onDrag = scope.onDrag;
          if (scope.onDragStart) options.onDragStart = scope.onDragStart;
          if (scope.onDragEnd) options.onDragEnd = scope.onDragEnd;

          return options;
        }

        /*
          Get all the sizes specified for each panel
        */
        function getPanelSizes() {
          var sizes = [];

          panels.forEach(function (panel) {

            //get sizes
            var size = panel.hasAttribute('size') ? parseInt(panel.getAttribute('size')) : null;

            //if size is not specified - throw an error - it is required
            if (!size) throw 'Splitter - All panels must have size specified';

            //store these values to use in options
            sizes.push(size);
          });
          return sizes;
        }

        /*
          Get all the minimum sizes for the panels
        */
        function getMinimumSizes() {
          var minSizes = [];

          panels.forEach(function (panel) {
            var minSize = panel.hasAttribute('min-size') ? parseInt(panel.getAttribute('min-size')) : 100;
            minSizes.push(minSize);
          });

          return minSizes;
        }

        /*
          Add a toggle to the mainpanel
        */
        function setUpToggleButton() {

          var mainPanel, sidePanel;

          panels.forEach(function (panel, index) {

            if (panel.hasAttribute('splitter-side')) {
              sidePanel = angular.element(panel);
              sidePanel._index = index;
              sidePanel[0].style.float = "none";
            }

            if (panel.hasAttribute('splitter-main')) {
              mainPanel = angular.element(panel);
              mainPanel._index = index;
              mainPanel[0].style.float = "none";
            }
          });

          if (mainPanel && sidePanel) {
            gutter = getGutter(mainPanel._index, sidePanel._index, panels.length);
            createToggleButton(mainPanel, sidePanel, panels.length);
          }
        }

        /*
          Create a toggle for the side panel
        */
        function createToggleButton(mainPanel, sidePanel) {

          var toggleDirection;

          options = getOptions();

          //Prevent the panel from sliding below the container
          container.style.overflow = "hidden";

          //Find out if the toggle switch should face left or right/top or bottom
          if (options.direction === "horizontal") {
            //Prevent the panel from sliding below the container
            container.style.display = "flex";
            toggleDirection = (mainPanel._index < sidePanel._index) ? "right" : "left";
          } else {
            toggleDirection = (mainPanel._index < sidePanel._index) ? "bottom" : "top";
          }

          //Set the splitter CSS
          scope.splitterPositionClass = toggleDirection;

          //Create a toggle button
          var toggle = angular.element('<div class="side-inset-splitter-toggle-container ' + scope.splitterPositionClass +'"><div class="side-inset-splitter-toggle"><a class="hpe-icon"></a></div></div>');

          //Add the toggle button to the main panel
          dragHandle = gutter[0].querySelector(".drag-handle");
          dragHandle.classList.add("hidden-drag-handle");
          if(scope.splitterPositionClass === "top" || scope.splitterPositionClass === "left")
            toggle.insertAfter(gutter);
          else
            toggle.insertBefore(gutter);

          //Get the width of the side panel
          var sidePanelWidth = parseInt(sidePanel.attr("size"));
          var sidePanelHeight = sidePanelWidth;
          //Remember the toggle state
          var toggleState = "collapsed";
          //Start with the gutter hidden
          hideGutter();
          //Set the right direction for the toggle button
          if (options.direction === "horizontal") {
            //Start with the side panel collapsed
            var gutterWidth = gutter.width();
            collapseSidePanel(mainPanel, sidePanel, gutterWidth);
            toggleButtonIcon(toggle, toggleDirection === "right" ? "hpe-previous" : "hpe-next");
          } else {
            //Start with the side panel collapsed
            var gutterHeight = gutter.height();
            collapseSidePanel(mainPanel, sidePanel, gutterHeight);
            toggleButtonIcon(toggle, toggleDirection === "bottom" ? "hpe-up" : "hpe-down");
          }

          //The transitions will only be added temporarily when the toggle is clicked
          mainPanel.on("webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend", function () {
            removeTransitionClasses(mainPanel);
          });
          sidePanel.on("webkitTransitionEnd otransitionend oTransitionEnd msTransitionEnd transitionend", function () {
            removeTransitionClasses(sidePanel);
          });

          toggle.on('mousedown', function (event) {
            event.stopPropagation();
          });

          //Bind the click logic for the toggle button
          toggle.on("click", function () {

            addTransitionClasses(mainPanel, sidePanel);

            if (toggleState === "collapsed") {
              toggleState = "expanded";
              showGutter();
              toggleButtonIcon(toggle);
              if (options.direction === "horizontal")
                expandSidePanel(mainPanel, sidePanel, sidePanelWidth);
              else
                expandSidePanel(mainPanel, sidePanel, sidePanelHeight);
              return;
            }
            if (toggleState === "expanded") {
              toggleState = "collapsed";

              //Update the new element width so the panel will re-expand to this size again
              hideGutter();
              toggleButtonIcon(toggle);
              if (options.direction === "horizontal") {
                sidePanelWidth = getSidePanelWidth(sidePanel, gutterWidth);
                collapseSidePanel(mainPanel, sidePanel, gutterWidth);
              } else {
                sidePanelHeight = getSidePanelHeight(sidePanel, gutterHeight);
                collapseSidePanel(mainPanel, sidePanel, gutterHeight);
              }
              return;
            }
          });
        }

        function getSidePanelWidth(sidePanel, gutterWidth) {
          //Container Width
          var containerWidth = sidePanel.parent().width();
          //The width of the gutter as a percentage - divided by two as each panel shares half the width in its calc sizing
          var percentageGutterWidth = (gutterWidth / 2) / containerWidth;
          //The width of the side panel as a percentage of the container
          var percentageSidePanelWidth = sidePanel.width() / containerWidth;
          //Update the variable, save as a 2 digit percentage
          return ((percentageGutterWidth) + (percentageSidePanelWidth)).toFixed(2) * 100;
        }

        function getSidePanelHeight(sidePanel, gutterHeight) {
          //Container Width
          var containerHeight = sidePanel.parent().height();
          //The width of the gutter as a percentage - divided by two as each panel shares half the width in its calc sizing
          var percentageGutterHeight = (gutterHeight / 2) / containerHeight;
          //The width of the side panel as a percentage of the container
          var percentageSidePanelHeight = sidePanel.height() / containerHeight;
          //Update the variable, save as a 2 digit percentage
          return ((percentageGutterHeight) + (percentageSidePanelHeight)).toFixed(2) * 100;
        }

        function addTransitionClasses(mainPanel, sidePanel) {
          if (options.direction === "horizontal") {
            mainPanel[0].style.transition = "width 0.4s cubic-bezier(0.4, 0, 0.2, 1)";
            sidePanel[0].style.transition = "width 0.4s cubic-bezier(0.4, 0, 0.2, 1)";
          } else {
            mainPanel[0].style.transition = "height 0.4s cubic-bezier(0.4, 0, 0.2, 1)";
            sidePanel[0].style.transition = "height 0.4s cubic-bezier(0.4, 0, 0.2, 1)";
          }
        }

        function removeTransitionClasses(elem) {
          elem[0].style.transition = "";
        }

        function toggleButtonIcon(toggle, iconClass) {
          //Find the <a> element with our icon
          var icon = toggle.find("a");

          //If this method was called with a class then use it
          if (iconClass) {
            icon.addClass(iconClass);
            return;
          }

          if (options.direction === "horizontal") {
            //Otherwise toggle 'next' to 'previous'
            if (icon.hasClass("hpe-next")) {
              icon.removeClass("hpe-next");
              icon.addClass("hpe-previous");
              return;
            }

            //Or 'previous' to 'next'
            if (icon.hasClass("hpe-previous")) {
              icon.removeClass("hpe-previous");
              icon.addClass("hpe-next");
              return;
            }
          } else {
            //Otherwise toggle 'up' to 'down'
            if (icon.hasClass("hpe-up")) {
              icon.removeClass("hpe-up");
              icon.addClass("hpe-down");
              return;
            }

            //Or 'down' to 'up'
            if (icon.hasClass("hpe-down")) {
              icon.removeClass("hpe-down");
              icon.addClass("hpe-up");
              return;
            }
          }

        }

        function hideGutter() {
          gutter.data("originalWidth", gutter.width());
          gutter.data("originalHeight", gutter.height());
          gutter.width("0");
          gutter.height("0");
        }

        function showGutter() {
          if (options.direction === "horizontal") {
            gutter.width(gutter.data("originalWidth"));
          } else {
            gutter[0].style.width= "100%";
          }
          gutter.height(gutter.data("originalHeight"));
        }

        function getGutter(mainPanelIndex, sidePanelIndex) {
          var gutterIndex = 0;
          if (sidePanelIndex > mainPanelIndex) {
            //side panel to the right of main panel
            gutterIndex = sidePanelIndex - 1;
          }
          return element.find(".gutter").eq(gutterIndex);
        }

        function collapseSidePanel(mainPanel, sidePanel) {
          if (options.direction === "horizontal") {
            sidePanel[0].style.overflowY = "hidden";
            sidePanel[0].style.width = "0";
            mainPanel[0].style.width = "100%";
          } else {
            sidePanel[0].style.overflowY = "auto";
            sidePanel[0].style.width = "100%";
            sidePanel[0].style.height = "0";
            mainPanel[0].style.height = "100%";
          }
          dragHandle.classList.add("hidden-drag-handle");
        }

        function expandSidePanel(mainPanel, sidePanel, size) {
          if (options.direction === "horizontal") {
            sidePanel[0].style.overflowY = "auto";
            sidePanel[0].style.width = size + "%";
            mainPanel[0].style.width = 100 - size + "%";
          } else {
            sidePanel[0].style.overflowY = "auto";
            sidePanel[0].style.width = "100%";
            sidePanel[0].style.height = size + "%";
            mainPanel[0].style.height = 100 - size + "%";
          }
          dragHandle.classList.remove("hidden-drag-handle");
        }
      }
    };
  }
})();;
(function () {

  angular.module("hpe.elements.splitter").directive("splitterPanel", splitterPanel);

  function splitterPanel() {
    return {
      restrict: "E",
      templateUrl: 'splitter/templates/splitterPanel.html',
      transclude: true,
      replace: true
    };
  }
})();;
(function () {
  angular.module("hpe.elements.staticTooltip", []);
})();;
(function () {

  angular.module("hpe.elements.staticTooltip").directive("staticTooltip", staticTooltip);

  staticTooltip.$inject = ['$parse'];

  function staticTooltip($parse) {
    return {
      restrict: "A",
      link: function (scope, element) {

        //create tooltip
        createTooltip();

        //watch the attribute to see if any change
        scope.$watch(function () {
          return JSON.stringify(generateOptions());
        }, function (nv, ov) {
          if (nv !== ov) createTooltip();
        });

        function generateOptions() {
          var options = {
            offset: {}
          };

          //extract options
          var content = $parse(element.attr('content'))(scope);
          var dismissText = $parse(element.attr('dismiss-text'))(scope);
          var position = $parse(element.attr('position'))(scope);
          var direction = $parse(element.attr('direction'))(scope);
          var offsetX = element.attr('offset-x') ? +$parse(element.attr('offset-x'))(scope) : null;
          var offsetY = element.attr('offset-y') ? +$parse(element.attr('offset-y'))(scope) : null;
          var zIndex = element.attr('z-index') ? +$parse(element.attr('z-index'))(scope) : null;

          //create object based on present options
          if (content) options.content = content;
          if (dismissText) options.dismissText = dismissText;
          if (position) options.position = position;
          if (direction) options.direction = direction;
          if (offsetX) options.offset.x = offsetX;
          if (offsetY) options.offset.y = offsetY;
          if (zIndex) options.zIndex = zIndex;

          return options;
        }

        function createTooltip() {
          $(element[0]).staticTooltip(generateOptions());
        }
      }
    };
  }
})();;
(function () {  
  angular.module("hpe.elements.tagInput", ['hpe.elements.templates','ngTagsInput']);
})();;
(function () {

	angular.module("hpe.elements.tagInput")
		.controller("TagInputCtrl", TagInputCtrl);

	TagInputCtrl.$inject = ["$scope", "$q"];

	function TagInputCtrl($scope, $q) {

		var ti = this;

		ti.$q = $q;

		//Tags
		ti.tags = $scope.tags || [];
		//Massage format of tags
		if (ti.tags.length) {
			if ((typeof ti.tags[0]).toLowerCase() === "string") {
				var tagCopy = [];
				for (var i in ti.tags) {
					tagCopy.push({
						text: ti.tags[i]
					});
				}
				ti.tags = tagCopy;
			}
		}

		ti.fullTagSet = $scope.fullTagSet || [];

		//Options
		$scope.options = $scope.options || {};
		ti.placeholder = $scope.options.placeholder || "";
		ti.minTagLength = $scope.options.minTagLength || 1;
		ti.maxTagLength = $scope.options.maxTagLength || Number.MAX_SAFE_INTEGER;
		ti.minNumberTags = $scope.options.minNumberTags || 0;
		ti.maxNumberTags = $scope.options.maxNumberTags || Number.MAX_SAFE_INTEGER;
		ti.addOnSpace = $scope.options.addOnSpace || false;
		ti.addOnComma = $scope.options.addOnComma || false;
		ti.addOnBlur = $scope.options.addOnBlur === false ? false : true;
		ti.addOnPaste = $scope.options.addOnPaste === false ? false : true;
		ti.pasteSplitPattern = $scope.options.pasteSplitPattern || ",";
		ti.enableEditingLastTag = $scope.options.enableEditingLastTag || false;
		ti.tabIndex = $scope.options.tabIndex || undefined;
		ti.template = $scope.options.template || undefined;
		ti.maxTagsMessage = $scope.options.maxTagsMessage || undefined;
		ti.maxTagsHidden = $scope.options.maxTagsHidden || false;

		//Options - Format
		$scope.options.format = $scope.options.format || {};
		ti.keyProperty = $scope.options.format.key || 'text';
		ti.displayProperty = $scope.options.format.display || 'text';

		//Options - Autocomplete
		ti.autocomplete = $scope.options.autocomplete || false;
		$scope.options.autocomplete = $scope.options.autocomplete || {};
		ti.addFromAutocompleteOnly = $scope.options.autocomplete.addFromAutocompleteOnly || false;
		ti.autocompleteDelay = $scope.options.autocomplete.delay || 100;
		ti.autocompleteMinLength = $scope.options.autocomplete.minLength || 3;
		ti.selectFirstMatch = ti.addFromAutocompleteOnly;
		ti.autocompleteTemplate = $scope.options.autocomplete.template || undefined;
		ti.source = $scope.options.autocomplete.source || false;

		//API
		$scope.api = $scope.api || {};
		ti.onTagAdding = $scope.api.onTagAdding || undefined;
		ti.onTagAdded = $scope.api.onTagAdded || undefined;
		ti.onInvalidTag = $scope.api.onInvalidTag || undefined;
		ti.onTagRemoving = $scope.api.onTagRemoving || undefined;
		ti.onTagRemoved = $scope.api.onTagRemoved || undefined;
		ti.onTagClicked = $scope.api.onTagClicked || undefined;

		//for setting the message
		ti.selectedInput = undefined;
		ti.showMessage = false;


		ti.updateMessage = function (text) {
			// if max tags reached and text isnt empty
			if (ti.tags.length === ti.maxNumberTags && ti.maxTagsMessage !== undefined) {
				// show the message if the text is not empty
				ti.showMessage = (text !== "");

				// update the ui
				$scope.$digest();
			}
		};

		$scope.$watch(function () {
			return ti.tags.length;
		}, function () {
			if (ti.tags.length < ti.maxNumberTags && ti.maxTagsMessage !== undefined)
				ti.showMessage = false;

			$scope.tags = ti.tags;
		});

	}

	TagInputCtrl.prototype.loadTags = function ($query) {
		var ti = this;
		ti.$query = $query || "";
		ti.$query = $query.toLowerCase();
		return ti.$q(function (resolve, reject) {
			if (ti.fullTagSet) {
				resolve(ti.fullTagSet.filter(function (element) {
					return ~element.toLowerCase().indexOf(ti.$query);
				}));
			} else {
				reject([]);
			}
		});
	};

})();;
(function () {

  angular.module("hpe.elements.tagInput").directive("tagInput", tagInput);

  tagInput.$inject = ['safeTimeout'];

  function tagInput(safeTimeout) {
    return {
      restrict: "E",
      templateUrl: "tagInput/template/tagInput.html",
      controller: "TagInputCtrl as ti",
      scope: {
        tags: "=",
        fullTagSet: "=?",
        api: "=?",
        options: "=?"
      },
      link: function (scope, element, attrs, controller) {

        var safeTimeoutInstance = safeTimeout.create(scope);

        safeTimeoutInstance.timeout(function () {
          var input = element.find('input');

          input.on('input', function () {
            controller.updateMessage(input.val());
          });
        });
      }
    };
  }
})();;
(function () {
    angular.module('hpe.elements.timeAgo', []);
})();;
(function () {

    angular.module('hpe.elements.timeAgo').directive('timeAgo', timeAgo);

    timeAgo.$inject = ['timeAgoService', '$parse', 'safeInterval'];

    function timeAgo(timeAgoService, $parse, safeInterval) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                //store the date
                var date = $parse(attrs.timeAgo)(scope);

                //store the current text - only update the dom if required
                var currentText;

                //create an instance of the safe interval service bound to the scope
                var safeIntervalInstance = safeInterval.create(scope);

                //update the time every second
                safeIntervalInstance.interval(function () {
                    //get a timestamp
                    var timeStamp = timeAgoService.timeSinceNow(date);

                    //compare it with the current text
                    if (currentText !== timeStamp) {
                        currentText = timeStamp;
                        element.text(timeStamp);
                    }

                }, 1000);
            }
        };
    }
})();;
//this file has _module name so that it is picked up first by grunt-concat,
//any further module declarations should be added here.

(function () {  
  angular.module("hpe.elements.treeview", ["hpe.elements.templates"]);
})();;
(function () {

  angular.module("hpe.elements.treeview").controller("TreeViewCtrl", TreeViewCtrl);

  TreeViewCtrl.$inject = ['$scope', '$element', '$timeout'];

  function TreeViewCtrl($scope, $element, $timeout) {
    var tv = this;
    //the scope of the parent controller
    tv.treeScope = null;

    tv.filterFunction = $scope.filterFunction || null;
    tv.selectedNode = $scope.selected;
    tv.selectedNodeScope = null;
    //reference to the node being edited
    tv.editingNode = null;
    //The developer can pass in functions for adding new items and adding new folders.
    //These will be decorated with the internal functionality, not overridden.
    //if no functions are supplied here, the tree will provide inline edit buttons
    tv.addItem = $scope.addItem || function () {
      return null;
    };

    tv.deleteFn = $scope.deleteFn || function () {
      return null;
    };

    tv.readOnly = $scope.readOnly || false;

    tv.treeOptions = $scope.treeOptions || {
      showTreeLines: true,
      openOnSelect: false
    };

    tv.inlineEdit = !!(!tv.addItem);

    tv.icons = $scope.icons || {
      folder: {
        collapsed: "hpe-folder",
        expanded: "hpe-folder-open"
      },
      item: "hpe-document",
      'default': "hpe-3d"
    };


    $scope.$watch('tv.selectedNode', function (nV) {
      if (nV !== undefined) {
        $scope.selected = nV;
      }
    }, true);

    //Initialisation
    $timeout(function () {
      tv.treeScope.collapseAll();

      $timeout(function () {
        var treeElement = $element.find('.angular-ui-tree');
        //Make tree visible after it is loaded
        treeElement.css('max-height', '');
        treeElement.css('visibility', '');

      });
    });

    tv.init = function (parentScope) {
      if (!tv.treeScope) {
        tv.treeScope = parentScope;
      }
    };

    tv.getIcon = function (type, collapsed) {
      if (tv.icons && type) {
        var icon = tv.icons[type];
        if (!icon) {
          return tv.icons["default"];
        } else if (typeof icon === 'string' || icon instanceof String) {
          return icon;
        } else if (icon.collapsed && collapsed) {
          return icon.collapsed;
        } else if (icon.expanded && !collapsed) {
          return icon.expanded;
        }
        return tv.icons["default"];
      }
    };

    tv.canAddItem = function (scope) {
      return scope.$modelValue.allowChildren && !tv.readOnly && (!tv.selectedNode.permissions || (tv.selectedNode.permissions && tv.selectedNode.permissions.add));
    };

    tv.canDeleteItem = function () {
      return !tv.readOnly && (!tv.selectedNode.permissions || (tv.selectedNode.permissions && tv.selectedNode.permissions.delete));
    };

    tv.canEditItem = function () {
      return !tv.readOnly && (!tv.selectedNode.permissions || (tv.selectedNode.permissions && tv.selectedNode.permissions.edit));
    };



    tv.newSubItem = function (scope, allowChildren, newItem) {
      if (tv.canAddItem(scope)) {
        //create the new item
        var nodeData = scope.$modelValue;

        var itemToAdd = newItem || {
          id: -1,
          allowChildren: !!allowChildren,
          title: 'New',
          nodes: []
        };

        var length = nodeData.nodes.push(itemToAdd);

        //select the new node for editing
        //defer execution until the $$hashKey is available. i.e. after the browser has rendered
        //If you want to manipulate objects before Angular manipulates the DOM you can use evalAsync - from a controller context
        //From a directive context, evalAsync runs after the DOM has been manipulated
        $timeout(function () {
          tv.selectedNodeScope.expand();

          tv.selectedNode = nodeData.nodes[length - 1];
          tv.edit({
            $modelValue: nodeData.nodes[length - 1]
          }, !!newItem);

          tv.selectedNodeScope = tv.selectedNodeScope.childNodes()[tv.selectedNodeScope.childNodesCount() - 1];
        });
      }
    };

    //ng-show="tv.filter(node)"
    //only show nodes based on their title, or according to the supplied function
    tv.filter = function (item) {
      if (tv.filterFunction) {
        return !!tv.filterFunction(item);
      }
      return !($scope.query && $scope.query.length > 0 && item.title.indexOf($scope.query) === -1);
    };

    //remove an item from the tree
    tv.remove = function (scope) {
      scope.remove();
    };

    //handle the selected item in the tree
    tv.select = function (scope) {
      //check if it's already clicked
      var firstClick = !tv.isSelected(scope);
      //update reference to the selected node
      tv.selectedNode = scope.$modelValue;
      tv.selectedNodeScope = scope;
      //change any text inputs back to spans
      tv.editingNode = null;
      if (tv.treeOptions.openOnSelect) {
        //toggle the node
        scope.select(scope);
        //force the node to be expanded if this the initial selection
        //otherwise clicking again on the selected node will toggle it as any other node
        if (firstClick) {
          scope.expand();
        }
      }
    };

    //call on a node to check if it's currently selected
    tv.isSelected = function (scope) {
      if ((tv.selectedNode === null) || (!scope.$modelValue)) {
        return false;
      }
      //we compare on the internal hashkey in case the titles or IDs aren't unique
      return (tv.selectedNode.$$hashKey === scope.$modelValue.$$hashKey);
    };

    //call on a node to check if it's currently being edited
    tv.isBeingEdited = function (scope) {
      if ((tv.editingNode === null) || (!scope.$modelValue)) {
        return false;
      }
      //we compare on the internal hashkey in case the titles or IDs aren't unique
      return (tv.editingNode.$$hashKey === scope.$modelValue.$$hashKey);
    };

    //activate inline edit of the selected node's title
    tv.edit = function (scope, itemAlreadyCreated) {
      //if an item was added via the API then it does not need edited here again
      if (itemAlreadyCreated) {
        return;
      }
      //editing is only performed on the currently selected item
      if (tv.isSelected(scope) && tv.canEditItem(scope)) {
        tv.editingNode = scope.$modelValue;
        tv.editingNode.$oV = tv.editingNode.title;
        //if possible, select all the text in the input
        if (tv.selectedNodeScope && tv.selectedNodeScope.$element) {
          $timeout(function () {
            tv.selectedNodeScope.$element.find("input.title-edit").select();
          });

        }
      } else {
        //this function is bound to the node title. If it wasn't already selected, click through to the default node action.
        tv.select(scope);
      }
    };

    //Save off changes to a node
    tv.finishEdit = function (scope, $event) {
      if (($event.which === 13) || ($event.type === "blur")) {
        //if the node is now blank, undo the change
        if (tv.editingNode && tv.editingNode.title === "") {
          tv.editingNode.title = tv.editingNode.$oV;
        }
        //exit edit mode
        tv.editingNode = null;
        if ($event.type === "keypress") {
          $timeout(function () {
            tv.selectedNodeScope.$element.find("span.title-readonly")[0].focus();
          });
        }
      }
    };

    $scope.addItem = function () {
      if (tv.selectedNode) {
        //call decoratee
        var newItem = tv.addItem() || null;
        tv.newSubItem(tv.wrapNode(tv.selectedNode), false, newItem);
      }
    };

    $scope.deleteFn = function (scope) {
      if (tv.selectedNode) {
        if (tv.canDeleteItem(scope)) {
          //call decoratee
          var response = tv.deleteFn() || null;
          if (response) {
            $timeout(function () {
              if (tv.selectedNodeScope.$parentNodeScope !== null) {
                tv.selectedNodeScope.$parentNodeScope.$element.find("span.title-readonly")[0].focus();
              }
              tv.remove(tv.selectedNodeScope);
              tv.selectedNode = null;
              tv.selectedNodeScope = null;
            });
          }
        }
      }
    };

    tv.wrapNode = function (node) {
      return {
        $modelValue: node
      };
    };

    tv.keyboardSelect = function (scope, $event) {
      if ($event.which === 13) {
        //enter
        tv.edit(scope);
      } else if ($event.which === 45) {
        //insert
        tv.select(scope);
        if ($scope.addItem) {
          $scope.addItem(scope);
        }

      } else if ($event.which === 46) {
        //delete
        tv.select(scope);
        if ($scope.deleteFn) {
          $scope.deleteFn(scope);
        }
      }
    };


  }

})();;
(function () {

  angular.module("hpe.elements.treeview").directive("treeView", treeView);

  function treeView() {
    return {
      restrict: "E",
      controller: "TreeViewCtrl as tv",
      scope: {
        data: '=',
        filterFunction: '=?filter',
        selected: '=?',
        addItem: '=?',
        icons: '=?',
        deleteFn: '=?delete',
        readOnly: '@?',
        treeOptions: '=?options'
      },
      templateUrl: "treeView/template/treeView.html",
      link: function (scope, element) {

        var treeElement = element.find('.angular-ui-tree');
        //If a height is provided to prevent initial flicker during load, set the style
        //(removed from controller after load)
        if (scope.treeOptions.loadHeight !== undefined && scope.treeOptions.loadHeight !== "") {

          var loadHeight = scope.treeOptions.loadHeight + "px";
          treeElement.css('max-height', loadHeight);
        }

        //Hide tree before loading ( made visible after load from controller)
        treeElement.css('visibility', 'hidden');

      }
    };
  }
})();;
(function () {

  angular.module("hpe.elements.wizard", ["hpe.elements.templates"])
    .controller("ElementsWizardCtrl", ["$scope", ElementsWizardCtrl])
    .directive("wizard", function () {
      return {
        restrict: "E",
        transclude: true,
        replace: true,
        scope: {
          onFinished: "&",
          onCanceled: "&",
          onChanging: "&",
          onFinishing: "&",
          isVisited: "=",
          buttonOptions: "="
        },
        controller: "ElementsWizardCtrl",
        controllerAs: "wzrd",
        templateUrl: "wizard/template/wizard.html",
        link: function (scope, element, attrs, ctrls) {
          scope.$watch('buttonOptions', function (newValue, oldValue) {
            if (newValue === oldValue) return;

            if (newValue) {
              ctrls.buttonOptions = angular.extend(ctrls.defaultOptions, newValue);
              ctrls.updateButtonTabIndexes();
            }

          }, true);

          // watch for changes on isvisited attribute
          scope.$watch('isVisited', function (newValue, oldValue) {
            if (newValue === oldValue) return;

            // only update steps if isVisited was set to true
            if (newValue) {
              ctrls.updateIsVisited();
            }
          }, true);
        }
      };
    })
    .directive('step', function () {
      return {
        restrict: 'E',
        require: "^wizard",
        transclude: true,
        replace: true,
        scope: {
          active: '=?'
        },
        templateUrl: "wizard/template/step.html",
        controller: function () {},
        compile: function (elm, attrs, transclude) {
          return function postLink(scope, elm, attrs, wizardCtrl) {
            scope.$watch('active', function (active) {
              if (active) {
                wizardCtrl.select(scope);
              }
            });


            scope.disabled = false;
            scope.done = false;

            scope.select = function () {
              wizardCtrl.select(scope);
            };


            if (scope.$parent.$index !== undefined && scope.$parent.$index !== null) {
              wizardCtrl.insertStep(scope, scope.$parent.$index);
            } else {
              wizardCtrl.addStep(scope);
            }
            scope.$on('$destroy', function () {
              wizardCtrl.removeStep(scope);
            });

            //We need to transclude later, once the content container is ready.
            //when this link happens, we're inside a step heading.
            scope.$transcludeFn = transclude;
          };
        }

      };
    })
    .directive('stepHeadingTransclude', function () {
      return {
        restrict: 'A',
        require: '^step',
        link: function (scope, elm) {
          scope.$watch('headingElement', function (heading) {
            if (heading) {
              elm.html('');
              elm.append(heading);
            }
          });
        }
      };
    })

  .directive('stepContentTransclude', function () {
    return {
      restrict: 'A',
      require: '^wizard',
      link: function (scope, elm, attrs) {
        var step = scope.$eval(attrs.stepContentTransclude);
        step.$transcludeFn(step.$parent, function (contents) {
          angular.forEach(contents, function (node) {
            if (isStepHeading(node)) {
              //Let stepHeadingTransclude know.
              step.headingElement = node;
            } else {
              elm.append(node);
            }
          });
        });
      }
    };
  });

  function isStepHeading(node) {
    return node.tagName && (
      node.hasAttribute('step-heading') ||
      node.hasAttribute('data-step-heading') ||
      node.tagName.toLowerCase() === 'step-heading' ||
      node.tagName.toLowerCase() === 'data-step-heading'
    );
  }

  function ElementsWizardCtrl($scope) {
    var vm = this;
    vm.onChanging = $scope.onChanging;
    vm.onFinishing = $scope.onFinishing;
    vm.onFinished = $scope.onFinished;
    vm.onCanceled = $scope.onCanceled;

    vm.isVisited = $scope.isVisited || false;

    // sets the steps to all be 'done' and sets the current active step correctly
    vm.updateIsVisited = function () {
      for (var i = 0; i < vm.steps.length; i++) {
        vm.steps[i].disabled = false;
        vm.steps[i].done = true;
      }
      setActive(vm.currentActiveStep);
    };

    vm.defaultOptions = {
      nextText: 'Next',
      previousText: 'Previous',
      cancelText: 'Cancel',
      finishText: 'Finish',
      showPrevious: true,
      showNext: true,
      showCancel: true,
      showFinish: true,
      nextTooltip: '',
      previousTooltip: '',
      cancelTooltip: '',
      finishTooltip: '',
      hideCancelOnFinish: true,
      previousEnabled: true,
      nextEnabled: true,
      finishEnabled: true,
      alwaysShowFinish: false
    };

    vm.buttonOptions = vm.defaultOptions;

    //set up buttons options and give default values if none are available
    if ($scope.buttonOptions) {
      vm.buttonOptions = angular.extend(vm.defaultOptions, $scope.buttonOptions);
    }

    // if buttons are disabled, set the tabindex to -1 so they are not be navigable by keyboard
    vm.updateButtonTabIndexes = function () {
      vm.buttonOptions.previousTabIndex = 0;
      if (!vm.buttonOptions.previousEnabled) {
        vm.buttonOptions.previousTabIndex = -1;
      }

      vm.buttonOptions.nextTabIndex = 0;
      if (!vm.buttonOptions.nextEnabled) {
        vm.buttonOptions.nextTabIndex = -1;
      }

      vm.buttonOptions.finishTabIndex = 0;
      if (!vm.buttonOptions.finishEnabled) {
        vm.buttonOptions.finishTabIndex = -1;
      }
    };

    vm.updateButtonTabIndexes();

    vm.previousEnabledSet = vm.buttonOptions.previousEnabled;

    //vm.previousDisabled = true;
    vm.nextShow = true;
    vm.finishShow = !vm.nextShow;
    vm.alwaysShowFinish = vm.buttonOptions.alwaysShowFinish === true ? true : false;
    vm.finish = finish;
    vm.cancel = cancel;
    vm.previous = previous;
    vm.next = next;

    vm.showingCancel = vm.buttonOptions.showCancel;

    vm.steps = [];
    vm.currentActiveStep = null;

    vm.addStep = addStep;
    vm.select = select;
    vm.removeStep = removeStep;
    vm.insertStep = insertStep;

    var activeIndex = vm.steps.indexOf(vm.currentActiveStep);
    if (activeIndex <= 0) {
      vm.buttonOptions.previousEnabled = false;

      // if on the first step, previous button is disabled and therefore not navigable by keyboard
      vm.buttonOptions.previousTabIndex = -1;
    }


    function finish() {
      if (vm.onFinishing && vm.onFinishing() === false) {
        vm.currentActiveStep.error = true;
        return;
      }

      vm.currentActiveStep.error = false;
      if (vm.onFinished) {
        vm.onFinished();
      }
    }

    function cancel() {
      if (vm.onCanceled) {
        vm.onCanceled();
      }
    }

    function previous() {
      if (!vm.buttonOptions.previousEnabled)
        return;
      var activeIndex = vm.steps.indexOf(vm.currentActiveStep);
      if (activeIndex <= 0) {
        return;
      }
      if (vm.onChanging && vm.onChanging({
          from: activeIndex,
          to: activeIndex - 1
        }) === false) {
        vm.currentActiveStep.error = true;
        return;
      }
      moveTo(vm.steps[activeIndex - 1]);

      if (vm.currentActiveStep.index !== vm.steps.length && vm.buttonOptions.showCancel) {
        vm.showingCancel = true;
      }
    }

    function next() {
      var activeIndex = vm.steps.indexOf(vm.currentActiveStep);
      if (activeIndex === vm.steps.length - 1) {
        return;
      }
      if (vm.onChanging && vm.onChanging({
          from: activeIndex,
          to: activeIndex + 1
        }) === false) {
        vm.currentActiveStep.error = true;
        return;
      }
      moveTo(vm.steps[activeIndex + 1]);

      if (vm.currentActiveStep.index === vm.steps.length && vm.buttonOptions.showCancel) {
        if (vm.buttonOptions.hideCancelOnFinish)
          vm.showingCancel = false;
        else
          vm.showingCancel = true;
      }
    }

    function moveTo(next) {


      setDone(vm.currentActiveStep);
      setActive(next);
      var activeIndex = vm.steps.indexOf(vm.currentActiveStep);

      if (vm.previousEnabledSet)
        vm.buttonOptions.previousEnabled = activeIndex !== 0;

      // if previous is enabled again, make it navigable by keyboard
      if (vm.buttonOptions.previousEnabled)
        vm.buttonOptions.previousTabIndex = 0;
      else
        vm.buttonOptions.previousTabIndex = -1;

      vm.nextShow = activeIndex !== vm.steps.length - 1;
      vm.finishShow = !vm.nextShow;
    }

    function setActive(step) {
      step.active = true;
      step.disabled = false;
      step.done = false;
      vm.currentActiveStep = step;
    }

    function setDone(step) {
      step.active = false;
      step.done = true;
      step.error = false;
    }


    function addStep(step) {
      vm.steps.push(step);

      //set id
      step.id = "wizard-step-" + vm.steps.length;
      step.index = vm.steps.length;
      if (vm.steps.length === 1) {
        step.active = true;
        vm.currentActiveStep = step;
      } else {
        step.active = false;

        if (vm.isVisited) {
          step.disabled = false;
          step.done = true;
        } else {
          step.disabled = true;
        }
      }
      vm.nextShow = vm.steps.length > 1;
      vm.finishShow = !vm.nextShow;
    }

    function insertStep(step, index) {
      //shortcut out if its really just adding one on to the end
      if (index === vm.steps.length) {
        vm.addStep(step);
        return;
      }

      //increment everythings id and index from index upwards
      for (var i = index; i < vm.steps.length; i++) {
        vm.steps[i].id = "wizard-step-" + (i + 1);
        vm.steps[i].index = i + 1;
      }

      //if index is active new index must be active
      if (vm.steps[index].active) {
        vm.steps[index].active = false;
        setActive(step);
      } else {
        step.active = false;
        if (vm.isVisited) {
          step.disabled = false;
          step.done = true;
        } else {
          step.disabled = true;
        }
      }
      //set button styling
      //always show next as if it was being appended it should be caught by shortcut at top of function
      vm.nextShow = true;
      vm.finishShow = !vm.nextShow;

      //finally insert
      vm.steps.splice(index, 0, step);

    }

    function select(step) {
      if (step.done) {
        var activeIndex = vm.steps.indexOf(vm.currentActiveStep);
        //check on changing
        if (vm.onChanging && vm.onChanging({
            from: activeIndex,
            to: vm.steps.indexOf(step)
          }) === false) {
          vm.currentActiveStep.error = true;
          return;
        }
        moveTo(step);

        if (vm.currentActiveStep.index === vm.steps.length) {
          if (vm.buttonOptions.showCancel && !vm.buttonOptions.hideCancelOnFinish)
            vm.showingCancel = true;
          else if (!vm.buttonOptions.showCancel || vm.buttonOptions.hideCancelOnFinish)
            vm.showingCancel = false;
        } else if (vm.buttonOptions.showCancel)
          vm.showingCancel = true;
      }
    }

    function removeStep(step) {
      var index = vm.steps.indexOf(step);
      if (index < 0) {
        return;
      }
      if (step.active && vm.steps.length > 1) {
        moveTo(vm.steps[index === vm.steps.length - 1 ? index - 1 : index + 1]);
      }
      vm.steps.splice(index, 1);

    }
  }
})();;
/*!
LICENSE-START
 angular-file-upload v1.1.5
 https://github.com/nervgh/angular-file-upload

 The MIT License

 Copyright (c) 2013 nerv. https://github.com/nervgh

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
LICENSE-END
*/

(function(angular, factory) {
    if (typeof define === 'function' && define.amd) {
        define('angular-file-upload', ['angular'], function(angular) {
            return factory(angular);
        });
    } else {
        return factory(angular);
    }
}(typeof angular === 'undefined' ? null : angular, function(angular) {

var module = angular.module('angularFileUpload', []);

'use strict';

/**
 * Classes
 *
 * FileUploader
 * FileUploader.FileLikeObject
 * FileUploader.FileItem
 * FileUploader.FileDirective
 * FileUploader.FileSelect
 * FileUploader.FileDrop
 * FileUploader.FileOver
 */

module


    .value('fileUploaderOptions', {
        url: '/',
        alias: 'file',
        headers: {},
        queue: [],
        progress: 0,
        autoUpload: false,
        removeAfterUpload: false,
        method: 'POST',
        filters: [],
        formData: [],
        queueLimit: Number.MAX_VALUE,
        withCredentials: false
    })


    .factory('FileUploader', ['fileUploaderOptions', '$rootScope', '$http', '$window', '$compile',
        function(fileUploaderOptions, $rootScope, $http, $window, $compile) {
            /**
             * Creates an instance of FileUploader
             * @param {Object} [options]
             * @constructor
             */
            function FileUploader(options) {
                var settings = angular.copy(fileUploaderOptions);
                angular.extend(this, settings, options, {
                    isUploading: false,
                    _nextIndex: 0,
                    _failFilterIndex: -1,
                    _directives: {select: [], drop: [], over: []}
                });

                // add default filters
                this.filters.unshift({name: 'queueLimit', fn: this._queueLimitFilter});
                this.filters.unshift({name: 'folder', fn: this._folderFilter});
            }
            /**********************
             * PUBLIC
             **********************/
            /**
             * Checks a support the html5 uploader
             * @returns {Boolean}
             * @readonly
             */
            FileUploader.prototype.isHTML5 = !!($window.File && $window.FormData);
            /**
             * Adds items to the queue
             * @param {File|HTMLInputElement|Object|FileList|Array<Object>} files
             * @param {Object} [options]
             * @param {Array<Function>|String} filters
             */
            FileUploader.prototype.addToQueue = function(files, options, filters) {
                var list = this.isArrayLikeObject(files) ? files: [files];
                var arrayOfFilters = this._getFilters(filters);
                var count = this.queue.length;
                var addedFileItems = [];

                angular.forEach(list, function(some /*{File|HTMLInputElement|Object}*/) {
                    var temp = new FileUploader.FileLikeObject(some);

                    if (this._isValidFile(temp, arrayOfFilters, options)) {
                        var fileItem = new FileUploader.FileItem(this, some, options);
                        addedFileItems.push(fileItem);
                        this.queue.push(fileItem);
                        this._onAfterAddingFile(fileItem);
                    } else {
                        var filter = this.filters[this._failFilterIndex];
                        this._onWhenAddingFileFailed(temp, filter, options);
                    }
                }, this);

                if(this.queue.length !== count) {
                    this._onAfterAddingAll(addedFileItems);
                    this.progress = this._getTotalProgress();
                }

                this._render();
                if (this.autoUpload) this.uploadAll();
            };
            /**
             * Remove items from the queue. Remove last: index = -1
             * @param {FileItem|Number} value
             */
            FileUploader.prototype.removeFromQueue = function(value) {
                var index = this.getIndexOfItem(value);
                var item = this.queue[index];
                if (item.isUploading) item.cancel();
                this.queue.splice(index, 1);
                item._destroy();
                this.progress = this._getTotalProgress();
            };
            /**
             * Clears the queue
             */
            FileUploader.prototype.clearQueue = function() {
                while(this.queue.length) {
                    this.queue[0].remove();
                }
                this.progress = 0;
            };
            /**
             * Uploads a item from the queue
             * @param {FileItem|Number} value
             */
            FileUploader.prototype.uploadItem = function(value) {
                var index = this.getIndexOfItem(value);
                var item = this.queue[index];
                var transport = this.isHTML5 ? '_xhrTransport' : '_iframeTransport';

                item._prepareToUploading();
                if(this.isUploading) return;

                this.isUploading = true;
                this[transport](item);
            };
            /**
             * Cancels uploading of item from the queue
             * @param {FileItem|Number} value
             */
            FileUploader.prototype.cancelItem = function(value) {
                var index = this.getIndexOfItem(value);
                var item = this.queue[index];
                var prop = this.isHTML5 ? '_xhr' : '_form';
                if (item && item.isUploading) item[prop].abort();
            };
            /**
             * Uploads all not uploaded items of queue
             */
            FileUploader.prototype.uploadAll = function() {
                var items = this.getNotUploadedItems().filter(function(item) {
                    return !item.isUploading;
                });
                if (!items.length) return;

                angular.forEach(items, function(item) {
                    item._prepareToUploading();
                });
                items[0].upload();
            };
            /**
             * Cancels all uploads
             */
            FileUploader.prototype.cancelAll = function() {
                var items = this.getNotUploadedItems();
                angular.forEach(items, function(item) {
                    item.cancel();
                });
            };
            /**
             * Returns "true" if value an instance of File
             * @param {*} value
             * @returns {Boolean}
             * @private
             */
            FileUploader.prototype.isFile = function(value) {
                var fn = $window.File;
                return (fn && value instanceof fn);
            };
            /**
             * Returns "true" if value an instance of FileLikeObject
             * @param {*} value
             * @returns {Boolean}
             * @private
             */
            FileUploader.prototype.isFileLikeObject = function(value) {
                return value instanceof FileUploader.FileLikeObject;
            };
            /**
             * Returns "true" if value is array like object
             * @param {*} value
             * @returns {Boolean}
             */
            FileUploader.prototype.isArrayLikeObject = function(value) {
                return (angular.isObject(value) && 'length' in value);
            };
            /**
             * Returns a index of item from the queue
             * @param {Item|Number} value
             * @returns {Number}
             */
            FileUploader.prototype.getIndexOfItem = function(value) {
                return angular.isNumber(value) ? value : this.queue.indexOf(value);
            };
            /**
             * Returns not uploaded items
             * @returns {Array}
             */
            FileUploader.prototype.getNotUploadedItems = function() {
                return this.queue.filter(function(item) {
                    return !item.isUploaded;
                });
            };
            /**
             * Returns items ready for upload
             * @returns {Array}
             */
            FileUploader.prototype.getReadyItems = function() {
                return this.queue
                    .filter(function(item) {
                        return (item.isReady && !item.isUploading);
                    })
                    .sort(function(item1, item2) {
                        return item1.index - item2.index;
                    });
            };
            /**
             * Destroys instance of FileUploader
             */
            FileUploader.prototype.destroy = function() {
                angular.forEach(this._directives, function(key) {
                    angular.forEach(this._directives[key], function(object) {
                        object.destroy();
                    }, this);
                }, this);
            };
            /**
             * Callback
             * @param {Array} fileItems
             */
            FileUploader.prototype.onAfterAddingAll = function(fileItems) {};
            /**
             * Callback
             * @param {FileItem} fileItem
             */
            FileUploader.prototype.onAfterAddingFile = function(fileItem) {};
            /**
             * Callback
             * @param {File|Object} item
             * @param {Object} filter
             * @param {Object} options
             * @private
             */
            FileUploader.prototype.onWhenAddingFileFailed = function(item, filter, options) {};
            /**
             * Callback
             * @param {FileItem} fileItem
             */
            FileUploader.prototype.onBeforeUploadItem = function(fileItem) {};
            /**
             * Callback
             * @param {FileItem} fileItem
             * @param {Number} progress
             */
            FileUploader.prototype.onProgressItem = function(fileItem, progress) {};
            /**
             * Callback
             * @param {Number} progress
             */
            FileUploader.prototype.onProgressAll = function(progress) {};
            /**
             * Callback
             * @param {FileItem} item
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             */
            FileUploader.prototype.onSuccessItem = function(item, response, status, headers) {};
            /**
             * Callback
             * @param {FileItem} item
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             */
            FileUploader.prototype.onErrorItem = function(item, response, status, headers) {};
            /**
             * Callback
             * @param {FileItem} item
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             */
            FileUploader.prototype.onCancelItem = function(item, response, status, headers) {};
            /**
             * Callback
             * @param {FileItem} item
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             */
            FileUploader.prototype.onCompleteItem = function(item, response, status, headers) {};
            /**
             * Callback
             */
            FileUploader.prototype.onCompleteAll = function() {};
            /**********************
             * PRIVATE
             **********************/
            /**
             * Returns the total progress
             * @param {Number} [value]
             * @returns {Number}
             * @private
             */
            FileUploader.prototype._getTotalProgress = function(value) {
                if(this.removeAfterUpload) return value || 0;

                var notUploaded = this.getNotUploadedItems().length;
                var uploaded = notUploaded ? this.queue.length - notUploaded : this.queue.length;
                ratio = (this.queue.length) ? 100 / this.queue.length: 0;
                var current = (value || 0) * ratio / 100;

                return Math.round(uploaded * ratio + current);
            };
            /**
             * Returns array of filters
             * @param {Array<Function>|String} filters
             * @returns {Array<Function>}
             * @private
             */
            FileUploader.prototype._getFilters = function(filters) {
                if (angular.isUndefined(filters)) return this.filters;
                if (angular.isArray(filters)) return filters;
                var names = filters.match(/[^\s,]+/g);
                return this.filters.filter(function(filter) {
                    return names.indexOf(filter.name) !== -1;
                }, this);
            };
            /**
             * Updates html
             * @private
             */
            FileUploader.prototype._render = function() {
                if (!$rootScope.$$phase) $rootScope.$apply();
            };
            /**
             * Returns "true" if item is a file (not folder)
             * @param {File|FileLikeObject} item
             * @returns {Boolean}
             * @private
             */
            FileUploader.prototype._folderFilter = function(item) {
                return !!(item.size || item.type);
            };
            /**
             * Returns "true" if the limit has not been reached
             * @returns {Boolean}
             * @private
             */
            FileUploader.prototype._queueLimitFilter = function() {
                return this.queue.length < this.queueLimit;
            };
            /**
             * Returns "true" if file pass all filters
             * @param {File|Object} file
             * @param {Array<Function>} filters
             * @param {Object} options
             * @returns {Boolean}
             * @private
             */
            FileUploader.prototype._isValidFile = function(file, filters, options) {
                this._failFilterIndex = -1;
                return !filters.length ? true : filters.every(function(filter) {
                    this._failFilterIndex++;
                    return filter.fn.call(this, file, options);
                }, this);
            };
            /**
             * Checks whether upload successful
             * @param {Number} status
             * @returns {Boolean}
             * @private
             */
            FileUploader.prototype._isSuccessCode = function(status) {
                return (status >= 200 && status < 300) || status === 304;
            };
            /**
             * Transforms the server response
             * @param {*} response
             * @param {Object} headers
             * @returns {*}
             * @private
             */
            FileUploader.prototype._transformResponse = function(response, headers) {
                var headersGetter = this._headersGetter(headers);
                angular.forEach($http.defaults.transformResponse, function(transformFn) {
                    response = transformFn(response, headersGetter);
                });
                return response;
            };
            /**
             * Parsed response headers
             * @param headers
             * @returns {Object}
             * @see https://github.com/angular/angular.js/blob/master/src/ng/http.js
             * @private
             */
            FileUploader.prototype._parseHeaders = function(headers) {
                var parsed = {}, key, val, i;

                if (!headers) return parsed;

                angular.forEach(headers.split('\n'), function(line) {
                    i = line.indexOf(':');
                    key = line.slice(0, i).trim().toLowerCase();
                    val = line.slice(i + 1).trim();

                    if (key) {
                        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
                    }
                });

                return parsed;
            };
            /**
             * Returns function that returns headers
             * @param {Object} parsedHeaders
             * @returns {Function}
             * @private
             */
            FileUploader.prototype._headersGetter = function(parsedHeaders) {
                return function(name) {
                    if (name) {
                        return parsedHeaders[name.toLowerCase()] || null;
                    }
                    return parsedHeaders;
                };
            };
            /**
             * The XMLHttpRequest transport
             * @param {FileItem} item
             * @private
             */
            FileUploader.prototype._xhrTransport = function(item) {
                var xhr = item._xhr = new XMLHttpRequest();
                var form = new FormData();
                var that = this;

                that._onBeforeUploadItem(item);

                angular.forEach(item.formData, function(obj) {
                    angular.forEach(obj, function(value, key) {
                        form.append(key, value);
                    });
                });

                form.append(item.alias, item._file, item.file.name);

                xhr.upload.onprogress = function(event) {
                    var progress = Math.round(event.lengthComputable ? event.loaded * 100 / event.total : 0);
                    that._onProgressItem(item, progress);
                };

                xhr.onload = function() {
                    var headers = that._parseHeaders(xhr.getAllResponseHeaders());
                    var response = that._transformResponse(xhr.response, headers);
                    var gist = that._isSuccessCode(xhr.status) ? 'Success' : 'Error';
                    var method = '_on' + gist + 'Item';
                    that[method](item, response, xhr.status, headers);
                    that._onCompleteItem(item, response, xhr.status, headers);
                };

                xhr.onerror = function() {
                    var headers = that._parseHeaders(xhr.getAllResponseHeaders());
                    var response = that._transformResponse(xhr.response, headers);
                    that._onErrorItem(item, response, xhr.status, headers);
                    that._onCompleteItem(item, response, xhr.status, headers);
                };

                xhr.onabort = function() {
                    var headers = that._parseHeaders(xhr.getAllResponseHeaders());
                    var response = that._transformResponse(xhr.response, headers);
                    that._onCancelItem(item, response, xhr.status, headers);
                    that._onCompleteItem(item, response, xhr.status, headers);
                };

                xhr.open(item.method, item.url, true);

                xhr.withCredentials = item.withCredentials;

                angular.forEach(item.headers, function(value, name) {
                    xhr.setRequestHeader(name, value);
                });

                xhr.send(form);
                this._render();
            };
            /**
             * The IFrame transport
             * @param {FileItem} item
             * @private
             */
            FileUploader.prototype._iframeTransport = function(item) {
                var form = angular.element('<form style="display: none;" />');
                var iframe = angular.element('<iframe name="iframeTransport' + Date.now() + '">');
                var input = item._input;
                var that = this;

                if (item._form) item._form.replaceWith(input); // remove old form
                item._form = form; // save link to new form

                that._onBeforeUploadItem(item);

                input.prop('name', item.alias);

                angular.forEach(item.formData, function(obj) {
                    angular.forEach(obj, function(value, key) {
                        var element = angular.element('<input type="hidden" name="' + key + '" />');
                        element.val(value);
                        form.append(element);
                    });
                });

                form.prop({
                    action: item.url,
                    method: 'POST',
                    target: iframe.prop('name'),
                    enctype: 'multipart/form-data',
                    encoding: 'multipart/form-data' // old IE
                });

                iframe.bind('load', function() {
                    try {
                        // Fix for legacy IE browsers that loads internal error page
                        // when failed WS response received. In consequence iframe
                        // content access denied error is thrown becouse trying to
                        // access cross domain page. When such thing occurs notifying
                        // with empty response object. See more info at:
                        // http://stackoverflow.com/questions/151362/access-is-denied-error-on-accessing-iframe-document-object
                        // Note that if non standard 4xx or 5xx error code returned
                        // from WS then response content can be accessed without error
                        // but 'XHR' status becomes 200. In order to avoid confusion
                        // returning response via same 'success' event handler.

                        // fixed angular.contents() for iframes
                        var html = iframe[0].contentDocument.body.innerHTML;
                    } catch (e) {}

                    var xhr = {response: html, status: 200, dummy: true};
                    var headers = {};
                    var response = that._transformResponse(xhr.response, headers);

                    that._onSuccessItem(item, response, xhr.status, headers);
                    that._onCompleteItem(item, response, xhr.status, headers);
                });

                form.abort = function() {
                    var xhr = {status: 0, dummy: true};
                    var headers = {};
                    var response;

                    iframe.unbind('load').prop('src', 'javascript:false;');
                    form.replaceWith(input);

                    that._onCancelItem(item, response, xhr.status, headers);
                    that._onCompleteItem(item, response, xhr.status, headers);
                };

                input.after(form);
                form.append(input).append(iframe);

                form[0].submit();
                this._render();
            };
            /**
             * Inner callback
             * @param {File|Object} item
             * @param {Object} filter
             * @param {Object} options
             * @private
             */
            FileUploader.prototype._onWhenAddingFileFailed = function(item, filter, options) {
                this.onWhenAddingFileFailed(item, filter, options);
            };
            /**
             * Inner callback
             * @param {FileItem} item
             */
            FileUploader.prototype._onAfterAddingFile = function(item) {
                this.onAfterAddingFile(item);
            };
            /**
             * Inner callback
             * @param {Array<FileItem>} items
             */
            FileUploader.prototype._onAfterAddingAll = function(items) {
                this.onAfterAddingAll(items);
            };
            /**
             *  Inner callback
             * @param {FileItem} item
             * @private
             */
            FileUploader.prototype._onBeforeUploadItem = function(item) {
                item._onBeforeUpload();
                this.onBeforeUploadItem(item);
            };
            /**
             * Inner callback
             * @param {FileItem} item
             * @param {Number} progress
             * @private
             */
            FileUploader.prototype._onProgressItem = function(item, progress) {
                var total = this._getTotalProgress(progress);
                this.progress = total;
                item._onProgress(progress);
                this.onProgressItem(item, progress);
                this.onProgressAll(total);
                this._render();
            };
            /**
             * Inner callback
             * @param {FileItem} item
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             * @private
             */
            FileUploader.prototype._onSuccessItem = function(item, response, status, headers) {
                item._onSuccess(response, status, headers);
                this.onSuccessItem(item, response, status, headers);
            };
            /**
             * Inner callback
             * @param {FileItem} item
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             * @private
             */
            FileUploader.prototype._onErrorItem = function(item, response, status, headers) {
                item._onError(response, status, headers);
                this.onErrorItem(item, response, status, headers);
            };
            /**
             * Inner callback
             * @param {FileItem} item
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             * @private
             */
            FileUploader.prototype._onCancelItem = function(item, response, status, headers) {
                item._onCancel(response, status, headers);
                this.onCancelItem(item, response, status, headers);
            };
            /**
             * Inner callback
             * @param {FileItem} item
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             * @private
             */
            FileUploader.prototype._onCompleteItem = function(item, response, status, headers) {
                item._onComplete(response, status, headers);
                this.onCompleteItem(item, response, status, headers);

                var nextItem = this.getReadyItems()[0];
                this.isUploading = false;

                if(angular.isDefined(nextItem)) {
                    nextItem.upload();
                    return;
                }

                this.onCompleteAll();
                this.progress = this._getTotalProgress();
                this._render();
            };
            /**********************
             * STATIC
             **********************/
            /**
             * @borrows FileUploader.prototype.isFile
             */
            FileUploader.isFile = FileUploader.prototype.isFile;
            /**
             * @borrows FileUploader.prototype.isFileLikeObject
             */
            FileUploader.isFileLikeObject = FileUploader.prototype.isFileLikeObject;
            /**
             * @borrows FileUploader.prototype.isArrayLikeObject
             */
            FileUploader.isArrayLikeObject = FileUploader.prototype.isArrayLikeObject;
            /**
             * @borrows FileUploader.prototype.isHTML5
             */
            FileUploader.isHTML5 = FileUploader.prototype.isHTML5;
            /**
             * Inherits a target (Class_1) by a source (Class_2)
             * @param {Function} target
             * @param {Function} source
             */
            FileUploader.inherit = function(target, source) {
                target.prototype = Object.create(source.prototype);
                target.prototype.constructor = target;
                target.super_ = source;
            };
            FileUploader.FileLikeObject = FileLikeObject;
            FileUploader.FileItem = FileItem;
            FileUploader.FileDirective = FileDirective;
            FileUploader.FileSelect = FileSelect;
            FileUploader.FileDrop = FileDrop;
            FileUploader.FileOver = FileOver;

            // ---------------------------

            /**
             * Creates an instance of FileLikeObject
             * @param {File|HTMLInputElement|Object} fileOrInput
             * @constructor
             */
            function FileLikeObject(fileOrInput) {
                var isInput = angular.isElement(fileOrInput);
                var fakePathOrObject = isInput ? fileOrInput.value : fileOrInput;
                var postfix = angular.isString(fakePathOrObject) ? 'FakePath' : 'Object';
                var method = '_createFrom' + postfix;
                this[method](fakePathOrObject);
            }

            /**
             * Creates file like object from fake path string
             * @param {String} path
             * @private
             */
            FileLikeObject.prototype._createFromFakePath = function(path) {
                this.lastModifiedDate = null;
                this.size = null;
                this.type = 'like/' + path.slice(path.lastIndexOf('.') + 1).toLowerCase();
                this.name = path.slice(path.lastIndexOf('/') + path.lastIndexOf('\\') + 2);
            };
            /**
             * Creates file like object from object
             * @param {File|FileLikeObject} object
             * @private
             */
            FileLikeObject.prototype._createFromObject = function(object) {
                this.lastModifiedDate = angular.copy(object.lastModifiedDate);
                this.size = object.size;
                this.type = object.type;
                this.name = object.name;
            };

            // ---------------------------

            /**
             * Creates an instance of FileItem
             * @param {FileUploader} uploader
             * @param {File|HTMLInputElement|Object} some
             * @param {Object} options
             * @constructor
             */
            function FileItem(uploader, some, options) {
                var isInput = angular.isElement(some);
                var input = isInput ? angular.element(some) : null;
                var file = !isInput ? some : null;

                angular.extend(this, {
                    url: uploader.url,
                    alias: uploader.alias,
                    headers: angular.copy(uploader.headers),
                    formData: angular.copy(uploader.formData),
                    removeAfterUpload: uploader.removeAfterUpload,
                    withCredentials: uploader.withCredentials,
                    method: uploader.method
                }, options, {
                    uploader: uploader,
                    file: new FileUploader.FileLikeObject(some),
                    isReady: false,
                    isUploading: false,
                    isUploaded: false,
                    isSuccess: false,
                    isCancel: false,
                    isError: false,
                    progress: 0,
                    index: null,
                    _file: file,
                    _input: input
                });

                if (input) this._replaceNode(input);
            }
            /**********************
             * PUBLIC
             **********************/
            /**
             * Uploads a FileItem
             */
            FileItem.prototype.upload = function() {
                this.uploader.uploadItem(this);
            };
            /**
             * Cancels uploading of FileItem
             */
            FileItem.prototype.cancel = function() {
                this.uploader.cancelItem(this);
            };
            /**
             * Removes a FileItem
             */
            FileItem.prototype.remove = function() {
                this.uploader.removeFromQueue(this);
            };
            /**
             * Callback
             * @private
             */
            FileItem.prototype.onBeforeUpload = function() {};
            /**
             * Callback
             * @param {Number} progress
             * @private
             */
            FileItem.prototype.onProgress = function(progress) {};
            /**
             * Callback
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             */
            FileItem.prototype.onSuccess = function(response, status, headers) {};
            /**
             * Callback
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             */
            FileItem.prototype.onError = function(response, status, headers) {};
            /**
             * Callback
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             */
            FileItem.prototype.onCancel = function(response, status, headers) {};
            /**
             * Callback
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             */
            FileItem.prototype.onComplete = function(response, status, headers) {};
            /**********************
             * PRIVATE
             **********************/
            /**
             * Inner callback
             */
            FileItem.prototype._onBeforeUpload = function() {
                this.isReady = true;
                this.isUploading = true;
                this.isUploaded = false;
                this.isSuccess = false;
                this.isCancel = false;
                this.isError = false;
                this.progress = 0;
                this.onBeforeUpload();
            };
            /**
             * Inner callback
             * @param {Number} progress
             * @private
             */
            FileItem.prototype._onProgress = function(progress) {
                this.progress = progress;
                this.onProgress(progress);
            };
            /**
             * Inner callback
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             * @private
             */
            FileItem.prototype._onSuccess = function(response, status, headers) {
                this.isReady = false;
                this.isUploading = false;
                this.isUploaded = true;
                this.isSuccess = true;
                this.isCancel = false;
                this.isError = false;
                this.progress = 100;
                this.index = null;
                this.onSuccess(response, status, headers);
            };
            /**
             * Inner callback
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             * @private
             */
            FileItem.prototype._onError = function(response, status, headers) {
                this.isReady = false;
                this.isUploading = false;
                this.isUploaded = true;
                this.isSuccess = false;
                this.isCancel = false;
                this.isError = true;
                this.progress = 0;
                this.index = null;
                this.onError(response, status, headers);
            };
            /**
             * Inner callback
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             * @private
             */
            FileItem.prototype._onCancel = function(response, status, headers) {
                this.isReady = false;
                this.isUploading = false;
                this.isUploaded = false;
                this.isSuccess = false;
                this.isCancel = true;
                this.isError = false;
                this.progress = 0;
                this.index = null;
                this.onCancel(response, status, headers);
            };
            /**
             * Inner callback
             * @param {*} response
             * @param {Number} status
             * @param {Object} headers
             * @private
             */
            FileItem.prototype._onComplete = function(response, status, headers) {
                this.onComplete(response, status, headers);
                if (this.removeAfterUpload) this.remove();
            };
            /**
             * Destroys a FileItem
             */
            FileItem.prototype._destroy = function() {
                if (this._input) this._input.remove();
                if (this._form) this._form.remove();
                delete this._form;
                delete this._input;
            };
            /**
             * Prepares to uploading
             * @private
             */
            FileItem.prototype._prepareToUploading = function() {
                this.index = this.index || ++this.uploader._nextIndex;
                this.isReady = true;
            };
            /**
             * Replaces input element on his clone
             * @param {JQLite|jQuery} input
             * @private
             */
            FileItem.prototype._replaceNode = function(input) {
                var clone = $compile(input.clone())(input.scope());
                clone.prop('value', null); // FF fix
                input.css('display', 'none');
                input.after(clone); // remove jquery dependency
            };

            // ---------------------------

            /**
             * Creates instance of {FileDirective} object
             * @param {Object} options
             * @param {Object} options.uploader
             * @param {HTMLElement} options.element
             * @param {Object} options.events
             * @param {String} options.prop
             * @constructor
             */
            function FileDirective(options) {
                angular.extend(this, options);
                this.uploader._directives[this.prop].push(this);
                this._saveLinks();
                this.bind();
            }
            /**
             * Map of events
             * @type {Object}
             */
            FileDirective.prototype.events = {};
            /**
             * Binds events handles
             */
            FileDirective.prototype.bind = function() {
                for(var key in this.events) {
                    var prop = this.events[key];
                    this.element.bind(key, this[prop]);
                }
            };
            /**
             * Unbinds events handles
             */
            FileDirective.prototype.unbind = function() {
                for(var key in this.events) {
                    this.element.unbind(key, this.events[key]);
                }
            };
            /**
             * Destroys directive
             */
            FileDirective.prototype.destroy = function() {
                var index = this.uploader._directives[this.prop].indexOf(this);
                this.uploader._directives[this.prop].splice(index, 1);
                this.unbind();
                // this.element = null;
            };
            /**
             * Saves links to functions
             * @private
             */
            FileDirective.prototype._saveLinks = function() {
                for(var key in this.events) {
                    var prop = this.events[key];
                    this[prop] = this[prop].bind(this);
                }
            };

            // ---------------------------

            FileUploader.inherit(FileSelect, FileDirective);

            /**
             * Creates instance of {FileSelect} object
             * @param {Object} options
             * @constructor
             */
            function FileSelect(options) {
                FileSelect.super_.apply(this, arguments);

                if(!this.uploader.isHTML5) {
                    this.element.removeAttr('multiple');
                }
                this.element.prop('value', null); // FF fix
            }
            /**
             * Map of events
             * @type {Object}
             */
            FileSelect.prototype.events = {
                $destroy: 'destroy',
                change: 'onChange'
            };
            /**
             * Name of property inside uploader._directive object
             * @type {String}
             */
            FileSelect.prototype.prop = 'select';
            /**
             * Returns options
             * @return {Object|undefined}
             */
            FileSelect.prototype.getOptions = function() {};
            /**
             * Returns filters
             * @return {Array<Function>|String|undefined}
             */
            FileSelect.prototype.getFilters = function() {};
            /**
             * If returns "true" then HTMLInputElement will be cleared
             * @returns {Boolean}
             */
            FileSelect.prototype.isEmptyAfterSelection = function() {
                return !!this.element.attr('multiple');
            };
            /**
             * Event handler
             */
            FileSelect.prototype.onChange = function() {
                var files = this.uploader.isHTML5 ? this.element[0].files : this.element[0];
                var options = this.getOptions();
                var filters = this.getFilters();

                if (!this.uploader.isHTML5) this.destroy();
                this.uploader.addToQueue(files, options, filters);
                if (this.isEmptyAfterSelection()) this.element.prop('value', null);
            };

            // ---------------------------

            FileUploader.inherit(FileDrop, FileDirective);

            /**
             * Creates instance of {FileDrop} object
             * @param {Object} options
             * @constructor
             */
            function FileDrop(options) {
                FileDrop.super_.apply(this, arguments);
            }
            /**
             * Map of events
             * @type {Object}
             */
            FileDrop.prototype.events = {
                $destroy: 'destroy',
                drop: 'onDrop',
                dragover: 'onDragOver',
                dragleave: 'onDragLeave'
            };
            /**
             * Name of property inside uploader._directive object
             * @type {String}
             */
            FileDrop.prototype.prop = 'drop';
            /**
             * Returns options
             * @return {Object|undefined}
             */
            FileDrop.prototype.getOptions = function() {};
            /**
             * Returns filters
             * @return {Array<Function>|String|undefined}
             */
            FileDrop.prototype.getFilters = function() {};
            /**
             * Event handler
             */
            FileDrop.prototype.onDrop = function(event) {
                var transfer = this._getTransfer(event);
                if (!transfer) return;
                var options = this.getOptions();
                var filters = this.getFilters();
                this._preventAndStop(event);
                angular.forEach(this.uploader._directives.over, this._removeOverClass, this);
                this.uploader.addToQueue(transfer.files, options, filters);
            };
            /**
             * Event handler
             */
            FileDrop.prototype.onDragOver = function(event) {
                var transfer = this._getTransfer(event);
                if(!this._haveFiles(transfer.types)) return;
                transfer.dropEffect = 'copy';
                this._preventAndStop(event);
                angular.forEach(this.uploader._directives.over, this._addOverClass, this);
            };
            /**
             * Event handler
             */
            FileDrop.prototype.onDragLeave = function(event) {
                if (event.currentTarget !== this.element[0]) return;
                this._preventAndStop(event);
                angular.forEach(this.uploader._directives.over, this._removeOverClass, this);
            };
            /**
             * Helper
             */
            FileDrop.prototype._getTransfer = function(event) {
                return event.dataTransfer ? event.dataTransfer : event.originalEvent.dataTransfer; // jQuery fix;
            };
            /**
             * Helper
             */
            FileDrop.prototype._preventAndStop = function(event) {
                event.preventDefault();
                event.stopPropagation();
            };
            /**
             * Returns "true" if types contains files
             * @param {Object} types
             */
            FileDrop.prototype._haveFiles = function(types) {
                if (!types) return false;
                if (types.indexOf) {
                    return types.indexOf('Files') !== -1;
                } else if(types.contains) {
                    return types.contains('Files');
                } else {
                    return false;
                }
            };
            /**
             * Callback
             */
            FileDrop.prototype._addOverClass = function(item) {
                item.addOverClass();
            };
            /**
             * Callback
             */
            FileDrop.prototype._removeOverClass = function(item) {
                item.removeOverClass();
            };

            // ---------------------------

            FileUploader.inherit(FileOver, FileDirective);

            /**
             * Creates instance of {FileDrop} object
             * @param {Object} options
             * @constructor
             */
            function FileOver(options) {
                FileOver.super_.apply(this, arguments);
            }
            /**
             * Map of events
             * @type {Object}
             */
            FileOver.prototype.events = {
                $destroy: 'destroy'
            };
            /**
             * Name of property inside uploader._directive object
             * @type {String}
             */
            FileOver.prototype.prop = 'over';
            /**
             * Over class
             * @type {string}
             */
            FileOver.prototype.overClass = 'nv-file-over';
            /**
             * Adds over class
             */
            FileOver.prototype.addOverClass = function() {
                this.element.addClass(this.getOverClass());
            };
            /**
             * Removes over class
             */
            FileOver.prototype.removeOverClass = function() {
                this.element.removeClass(this.getOverClass());
            };
            /**
             * Returns over class
             * @returns {String}
             */
            FileOver.prototype.getOverClass = function() {
                return this.overClass;
            };

            return FileUploader;
        }])


    .directive('nvFileSelect', ['$parse', 'FileUploader', function($parse, FileUploader) {
        return {
            link: function(scope, element, attributes) {
                var uploader = scope.$eval(attributes.uploader);

                if (!(uploader instanceof FileUploader)) {
                    throw new TypeError('"Uploader" must be an instance of FileUploader');
                }

                var object = new FileUploader.FileSelect({
                    uploader: uploader,
                    element: element
                });

                object.getOptions = $parse(attributes.options).bind(object, scope);
                object.getFilters = function() {return attributes.filters;};
            }
        };
    }])


    .directive('nvFileDrop', ['$parse', 'FileUploader', function($parse, FileUploader) {
        return {
            link: function(scope, element, attributes) {
                var uploader = scope.$eval(attributes.uploader);

                if (!(uploader instanceof FileUploader)) {
                    throw new TypeError('"Uploader" must be an instance of FileUploader');
                }

                if (!uploader.isHTML5) return;

                var object = new FileUploader.FileDrop({
                    uploader: uploader,
                    element: element
                });

                object.getOptions = $parse(attributes.options).bind(object, scope);
                object.getFilters = function() {return attributes.filters;};
            }
        };
    }])


    .directive('nvFileOver', ['FileUploader', function(FileUploader) {
        return {
            link: function(scope, element, attributes) {
                var uploader = scope.$eval(attributes.uploader);

                if (!(uploader instanceof FileUploader)) {
                    throw new TypeError('"Uploader" must be an instance of FileUploader');
                }

                var object = new FileUploader.FileOver({
                    uploader: uploader,
                    element: element
                });

                object.getOverClass = function() {
                    return attributes.overClass || this.overClass;
                };
            }
        };
    }])

    return module;
}));;
/*!
LICENSE-START
The MIT License (MIT)

Copyright (c) 2014 Develer S.r.L.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
LICENSE-END
*/

/* Added extra functionality for PieChart --- HPElements - Angular Version*/

// Generated by CoffeeScript 1.8.0
(function () {
angular.module('angular-flot', []).directive('flot', ['$window', function($window) {
  return {
    restrict: 'EA',
    template: '<div></div>',
    scope: {
      dataset: '=',
      options: '=',
      callback: '=',
      onPlotClick: '&',
      onPlotHover: '&',
      donutLabels: '=?'
    },
    link: function(scope, element, attributes) {
      var height, init, onDatasetChanged, onOptionsChanged, plot, plotArea, width, _ref, _ref1;
      plot = null;
      width = attributes.width || '100%';
      height = attributes.height || '100%';
      if (((_ref = scope.options) != null ? (_ref1 = _ref.legend) != null ? _ref1.container : void 0 : void 0) instanceof jQuery) {
        throw 'Please use a jQuery expression string with the "legend.container" option.';
      }
      if (!scope.dataset) {
        scope.dataset = [];
      }
      if (!scope.options) {
        scope.options = {
          legend: {
            show: false
          }
        };
      }
      plotArea = $(element.children()[0]);
      plotArea.css({
        width: width,
        height: height
      });
      init = function() {
        var plotObj;
        plotObj = $.plot(plotArea, scope.dataset, scope.options);
        if (scope.callback) {
          scope.callback(plotObj);
        }
        return plotObj;
      };

      //
      // Events
      //
      plotArea.on('plotclick', function onPlotClick (event, pos, item) {
        scope.$apply(function onApplyPlotClick () {
          scope.onPlotClick({
            event: event,
            pos: pos,
            item: item
          })
        })
      });

      plotArea.on('plothover', function onPlotHover (event, pos, item) {
        scope.$apply(function onApplyPlotHover () {
          scope.onPlotHover({
            event: event,
            pos: pos,
            item: item
          })
        })
      });

      element.on('$destroy', function onDestroy () {
        plotArea.off('plotclick')
        plotArea.off('plothover')
        //Added the code below for HPEElements.
        $(window).off('resize',resize);
      })

       //Added extra code for HPElements.
       var resize = function() {
         //cannot reinit here, this causes plugin data to be lost - should only redraw instead
         if (plot) {
          // Added this clause to avoid donut chart from being redrawn due to distortion.
          if(typeof(scope.options.series) != "undefined") {
            if(typeof(scope.options.series.pie) == "undefined") {
             plot.setupGrid();
             return plot.draw();
            } else {
             return plot = init();
            }
          } else {
            plot.setupGrid();
            return plot.draw();
          }
         } else {
           return plot = init();
         }
       }
       $(window).bind('resize',resize);
      //Added extra code for HPElements.

      onDatasetChanged = function(dataset) {
        if (plot) {
          plot.setData(dataset);
          plot.setupGrid();
          return plot.draw();
        } else {
          return plot = init();
        }
      };
      scope.$watch('dataset', onDatasetChanged, true);
      onOptionsChanged = function() {
        return plot = init();
      };
      scope.$watch('options', onOptionsChanged, true);

      onDonutLabelsChanged = function(labels) {
        if(labels) {
          if(labels.centerLabel) scope.options.series.pie.centerLabel.text = labels.centerLabel;
          if(labels.subLabel) scope.options.series.pie.subLabel.text = labels.subLabel;
          if(labels.donutLabel) scope.options.series.pie.donutLabel.text = labels.donutLabel;
        }
      }
      scope.$watch('donutLabels', onDonutLabelsChanged, true);

    }
  };
}]);
})();
;
/*!
LICENSE-START
 * The MIT License (MIT)
 
 * Copyright (c) 2014 Brian Hines
 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 LICENSE-END
 */
var angularPeity = angular.module( 'angular-peity', [] );


var buildChartDirective = function ( chartType ) {
	return {
		restrict: 'E',
		scope: {
			data: "=",
			options: "="
		},
		link: function ( scope, element, attrs ) {

            var options = {};
            if ( scope.options ) {
				options = scope.options;
            }

			var span = document.createElement( 'span' );
			span.textContent = scope.data.join();

            if ( !attrs.class ) {
                span.className = "";
            } else {
                span.className = attrs.class;
            }

            if (element[0].nodeType === 8) {
                element.replaceWith( span );
            } else {
                element[0].appendChild( span );
            }

            jQuery( span ).peity( chartType, options );

		}
	};
};


angularPeity.directive( 'pieChart', function () {

	return buildChartDirective( "pie" );

} );


angularPeity.directive( 'barChart', function () {

	return buildChartDirective( "bar" );

} );


angularPeity.directive( 'lineChart', function () {

	return buildChartDirective( "line" );

} );
;
/*!
 *
 * @license AngularJS v1.3.16
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {'use strict';

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *     Any commits to this file should be reviewed with security in mind.  *
 *   Changes to this file can potentially create security vulnerabilities. *
 *          An approval from 2 Core members with history of modifying      *
 *                         this file is required.                          *
 *                                                                         *
 *  Does the change somehow allow for arbitrary javascript to be executed? *
 *    Or allows for someone to change the prototype of built-in objects?   *
 *     Or gives undesired access to variables likes document or window?    *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

var $sanitizeMinErr = angular.$$minErr('$sanitize');

/**
 * @ngdoc module
 * @name ngSanitize
 * @description
 *
 * # ngSanitize
 *
 * The `ngSanitize` module provides functionality to sanitize HTML.
 *
 *
 * <div doc-module-components="ngSanitize"></div>
 *
 * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
 */

/*
 * HTML Parser By Misko Hevery (misko@hevery.com)
 * based on:  HTML Parser By John Resig (ejohn.org)
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 *
 * // Use like so:
 * htmlParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 */


/**
 * @ngdoc service
 * @name $sanitize
 * @kind function
 *
 * @description
 *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
 *   then serialized back to properly escaped html string. This means that no unsafe input can make
 *   it into the returned string, however, since our parser is more strict than a typical browser
 *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
 *   browser, won't make it through the sanitizer. The input may also contain SVG markup.
 *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and
 *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.
 *
 * @param {string} html HTML input.
 * @returns {string} Sanitized HTML.
 *
 * @example
   <example module="sanitizeExample" deps="angular-sanitize.js">
   <file name="index.html">
     <script>
         angular.module('sanitizeExample', ['ngSanitize'])
           .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
             $scope.snippet =
               '<p style="color:blue">an html\n' +
               '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
               'snippet</p>';
             $scope.deliberatelyTrustDangerousSnippet = function() {
               return $sce.trustAsHtml($scope.snippet);
             };
           }]);
     </script>
     <div ng-controller="ExampleController">
        Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Directive</td>
           <td>How</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="bind-html-with-sanitize">
           <td>ng-bind-html</td>
           <td>Automatically uses $sanitize</td>
           <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind-html="snippet"></div></td>
         </tr>
         <tr id="bind-html-with-trust">
           <td>ng-bind-html</td>
           <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
           <td>
           <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
&lt;/div&gt;</pre>
           </td>
           <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
         </tr>
         <tr id="bind-default">
           <td>ng-bind</td>
           <td>Automatically escapes</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
       </div>
   </file>
   <file name="protractor.js" type="protractor">
     it('should sanitize the html snippet by default', function() {
       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
         toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
     });

     it('should inline raw snippet if bound to a trusted value', function() {
       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
         toBe("<p style=\"color:blue\">an html\n" +
              "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
              "snippet</p>");
     });

     it('should escape snippet without any filter', function() {
       expect(element(by.css('#bind-default div')).getInnerHtml()).
         toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
              "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
              "snippet&lt;/p&gt;");
     });

     it('should update', function() {
       element(by.model('snippet')).clear();
       element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
         toBe('new <b>text</b>');
       expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
         'new <b onclick="alert(1)">text</b>');
       expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
         "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
     });
   </file>
   </example>
 */
function $SanitizeProvider() {
  this.$get = ['$$sanitizeUri', function($$sanitizeUri) {
    return function(html) {
      var buf = [];
      htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
        return !/^unsafe/.test($$sanitizeUri(uri, isImage));
      }));
      return buf.join('');
    };
  }];
}

function sanitizeText(chars) {
  var buf = [];
  var writer = htmlSanitizeWriter(buf, angular.noop);
  writer.chars(chars);
  return buf.join('');
}


// Regular Expressions for parsing tags and attributes
var START_TAG_REGEXP =
       /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
  END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
  ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
  BEGIN_TAG_REGEXP = /^</,
  BEGING_END_TAGE_REGEXP = /^<\//,
  COMMENT_REGEXP = /<!--(.*?)-->/g,
  DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
  CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
  SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
  // Match everything outside of normal chars and " (quote character)
  NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;


// Good source of info about elements and attributes
// http://dev.w3.org/html5/spec/Overview.html#semantics
// http://simon.html5.org/html-elements

// Safe Void Elements - HTML5
// http://dev.w3.org/html5/spec/Overview.html#void-elements
var voidElements = makeMap("area,br,col,hr,img,wbr");

// Elements that you can, intentionally, leave open (and which close themselves)
// http://dev.w3.org/html5/spec/Overview.html#optional-tags
var optionalEndTagBlockElements = makeMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
    optionalEndTagInlineElements = makeMap("rp,rt"),
    optionalEndTagElements = angular.extend({},
                                            optionalEndTagInlineElements,
                                            optionalEndTagBlockElements);

// Safe Block Elements - HTML5
var blockElements = angular.extend({}, optionalEndTagBlockElements, makeMap("address,article," +
        "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," +
        "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul"));

// Inline Elements - HTML5
var inlineElements = angular.extend({}, optionalEndTagInlineElements, makeMap("a,abbr,acronym,b," +
        "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," +
        "samp,small,span,strike,strong,sub,sup,time,tt,u,var"));

// SVG Elements
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
var svgElements = makeMap("animate,animateColor,animateMotion,animateTransform,circle,defs," +
        "desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient," +
        "line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set," +
        "stop,svg,switch,text,title,tspan,use");

// Special Elements (can contain anything)
var specialElements = makeMap("script,style");

var validElements = angular.extend({},
                                   voidElements,
                                   blockElements,
                                   inlineElements,
                                   optionalEndTagElements,
                                   svgElements);

//Attributes that have href and hence need to be sanitized
var uriAttrs = makeMap("background,cite,href,longdesc,src,usemap,xlink:href");

var htmlAttrs = makeMap('abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' +
    'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' +
    'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' +
    'scope,scrolling,shape,size,span,start,summary,target,title,type,' +
    'valign,value,vspace,width');

// SVG attributes (without "id" and "name" attributes)
// https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
var svgAttrs = makeMap('accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' +
    'attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,' +
    'color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,' +
    'font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,' +
    'gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,' +
    'keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,' +
    'markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,' +
    'overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,' +
    'repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,' +
    'stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,' +
    'stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,' +
    'stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,' +
    'underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,' +
    'viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,' +
    'xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,' +
    'zoomAndPan');

var validAttrs = angular.extend({},
                                uriAttrs,
                                svgAttrs,
                                htmlAttrs);

function makeMap(str) {
  var obj = {}, items = str.split(','), i;
  for (i = 0; i < items.length; i++) obj[items[i]] = true;
  return obj;
}


/**
 * @example
 * htmlParser(htmlString, {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * });
 *
 * @param {string} html string
 * @param {object} handler
 */
function htmlParser(html, handler) {
  if (typeof html !== 'string') {
    if (html === null || typeof html === 'undefined') {
      html = '';
    } else {
      html = '' + html;
    }
  }
  var index, chars, match, stack = [], last = html, text;
  stack.last = function() { return stack[stack.length - 1]; };

  while (html) {
    text = '';
    chars = true;

    // Make sure we're not in a script or style element
    if (!stack.last() || !specialElements[stack.last()]) {

      // Comment
      if (html.indexOf("<!--") === 0) {
        // comments containing -- are not allowed unless they terminate the comment
        index = html.indexOf("--", 4);

        if (index >= 0 && html.lastIndexOf("-->", index) === index) {
          if (handler.comment) handler.comment(html.substring(4, index));
          html = html.substring(index + 3);
          chars = false;
        }
      // DOCTYPE
      } else if (DOCTYPE_REGEXP.test(html)) {
        match = html.match(DOCTYPE_REGEXP);

        if (match) {
          html = html.replace(match[0], '');
          chars = false;
        }
      // end tag
      } else if (BEGING_END_TAGE_REGEXP.test(html)) {
        match = html.match(END_TAG_REGEXP);

        if (match) {
          html = html.substring(match[0].length);
          match[0].replace(END_TAG_REGEXP, parseEndTag);
          chars = false;
        }

      // start tag
      } else if (BEGIN_TAG_REGEXP.test(html)) {
        match = html.match(START_TAG_REGEXP);

        if (match) {
          // We only have a valid start-tag if there is a '>'.
          if (match[4]) {
            html = html.substring(match[0].length);
            match[0].replace(START_TAG_REGEXP, parseStartTag);
          }
          chars = false;
        } else {
          // no ending tag found --- this piece should be encoded as an entity.
          text += '<';
          html = html.substring(1);
        }
      }

      if (chars) {
        index = html.indexOf("<");

        text += index < 0 ? html : html.substring(0, index);
        html = index < 0 ? "" : html.substring(index);

        if (handler.chars) handler.chars(decodeEntities(text));
      }

    } else {
      // IE versions 9 and 10 do not understand the regex '[^]', so using a workaround with [\W\w].
      html = html.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i'),
        function(all, text) {
          text = text.replace(COMMENT_REGEXP, "$1").replace(CDATA_REGEXP, "$1");

          if (handler.chars) handler.chars(decodeEntities(text));

          return "";
      });

      parseEndTag("", stack.last());
    }

    if (html == last) {
      throw $sanitizeMinErr('badparse', "The sanitizer was unable to parse the following block " +
                                        "of html: {0}", html);
    }
    last = html;
  }

  // Clean up any remaining tags
  parseEndTag();

  function parseStartTag(tag, tagName, rest, unary) {
    tagName = angular.lowercase(tagName);
    if (blockElements[tagName]) {
      while (stack.last() && inlineElements[stack.last()]) {
        parseEndTag("", stack.last());
      }
    }

    if (optionalEndTagElements[tagName] && stack.last() == tagName) {
      parseEndTag("", tagName);
    }

    unary = voidElements[tagName] || !!unary;

    if (!unary)
      stack.push(tagName);

    var attrs = {};

    rest.replace(ATTR_REGEXP,
      function(match, name, doubleQuotedValue, singleQuotedValue, unquotedValue) {
        var value = doubleQuotedValue
          || singleQuotedValue
          || unquotedValue
          || '';

        attrs[name] = decodeEntities(value);
    });
    if (handler.start) handler.start(tagName, attrs, unary);
  }

  function parseEndTag(tag, tagName) {
    var pos = 0, i;
    tagName = angular.lowercase(tagName);
    if (tagName)
      // Find the closest opened tag of the same type
      for (pos = stack.length - 1; pos >= 0; pos--)
        if (stack[pos] == tagName)
          break;

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (i = stack.length - 1; i >= pos; i--)
        if (handler.end) handler.end(stack[i]);

      // Remove the open elements from the stack
      stack.length = pos;
    }
  }
}

var hiddenPre=document.createElement("pre");
/**
 * decodes all entities into regular string
 * @param value
 * @returns {string} A string with decoded entities.
 */
function decodeEntities(value) {
  if (!value) { return ''; }

  hiddenPre.innerHTML = value.replace(/</g,"&lt;");
  // innerText depends on styling as it doesn't display hidden elements.
  // Therefore, it's better to use textContent not to cause unnecessary reflows.
  return hiddenPre.textContent;
}

/**
 * Escapes all potentially dangerous characters, so that the
 * resulting string can be safely inserted into attribute or
 * element text.
 * @param value
 * @returns {string} escaped text
 */
function encodeEntities(value) {
  return value.
    replace(/&/g, '&amp;').
    replace(SURROGATE_PAIR_REGEXP, function(value) {
      var hi = value.charCodeAt(0);
      var low = value.charCodeAt(1);
      return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';
    }).
    replace(NON_ALPHANUMERIC_REGEXP, function(value) {
      return '&#' + value.charCodeAt(0) + ';';
    }).
    replace(/</g, '&lt;').
    replace(/>/g, '&gt;');
}

/**
 * create an HTML/XML writer which writes to buffer
 * @param {Array} buf use buf.jain('') to get out sanitized html string
 * @returns {object} in the form of {
 *     start: function(tag, attrs, unary) {},
 *     end: function(tag) {},
 *     chars: function(text) {},
 *     comment: function(text) {}
 * }
 */
function htmlSanitizeWriter(buf, uriValidator) {
  var ignore = false;
  var out = angular.bind(buf, buf.push);
  return {
    start: function(tag, attrs, unary) {
      tag = angular.lowercase(tag);
      if (!ignore && specialElements[tag]) {
        ignore = tag;
      }
      if (!ignore && validElements[tag] === true) {
        out('<');
        out(tag);
        angular.forEach(attrs, function(value, key) {
          var lkey=angular.lowercase(key);
          var isImage = (tag === 'img' && lkey === 'src') || (lkey === 'background');
          if (validAttrs[lkey] === true &&
            (uriAttrs[lkey] !== true || uriValidator(value, isImage))) {
            out(' ');
            out(key);
            out('="');
            out(encodeEntities(value));
            out('"');
          }
        });
        out(unary ? '/>' : '>');
      }
    },
    end: function(tag) {
        tag = angular.lowercase(tag);
        if (!ignore && validElements[tag] === true) {
          out('</');
          out(tag);
          out('>');
        }
        if (tag == ignore) {
          ignore = false;
        }
      },
    chars: function(chars) {
        if (!ignore) {
          out(encodeEntities(chars));
        }
      }
  };
}


// define ngSanitize module and register $sanitize service
angular.module('ngSanitize', []).provider('$sanitize', $SanitizeProvider);

/* global sanitizeText: false */

/**
 * @ngdoc filter
 * @name linky
 * @kind function
 *
 * @description
 * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
 * plain email address links.
 *
 * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
 *
 * @param {string} text Input text.
 * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
 * @returns {string} Html-linkified text.
 *
 * @usage
   <span ng-bind-html="linky_expression | linky"></span>
 *
 * @example
   <example module="linkyExample" deps="angular-sanitize.js">
     <file name="index.html">
       <script>
         angular.module('linkyExample', ['ngSanitize'])
           .controller('ExampleController', ['$scope', function($scope) {
             $scope.snippet =
               'Pretty text with some links:\n'+
               'http://angularjs.org/,\n'+
               'mailto:us@somewhere.org,\n'+
               'another@somewhere.org,\n'+
               'and one more: ftp://127.0.0.1/.';
             $scope.snippetWithTarget = 'http://angularjs.org/';
           }]);
       </script>
       <div ng-controller="ExampleController">
       Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
       <table>
         <tr>
           <td>Filter</td>
           <td>Source</td>
           <td>Rendered</td>
         </tr>
         <tr id="linky-filter">
           <td>linky filter</td>
           <td>
             <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
           </td>
           <td>
             <div ng-bind-html="snippet | linky"></div>
           </td>
         </tr>
         <tr id="linky-target">
          <td>linky target</td>
          <td>
            <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
          </td>
          <td>
            <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
          </td>
         </tr>
         <tr id="escaped-html">
           <td>no filter</td>
           <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
           <td><div ng-bind="snippet"></div></td>
         </tr>
       </table>
     </file>
     <file name="protractor.js" type="protractor">
       it('should linkify the snippet with urls', function() {
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
       });

       it('should not linkify snippet without the linky filter', function() {
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
             toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
                  'another@somewhere.org, and one more: ftp://127.0.0.1/.');
         expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
       });

       it('should update', function() {
         element(by.model('snippet')).clear();
         element(by.model('snippet')).sendKeys('new http://link.');
         expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
             toBe('new http://link.');
         expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
         expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
             .toBe('new http://link.');
       });

       it('should work with the target property', function() {
        expect(element(by.id('linky-target')).
            element(by.binding("snippetWithTarget | linky:'_blank'")).getText()).
            toBe('http://angularjs.org/');
        expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
       });
     </file>
   </example>
 */
angular.module('ngSanitize').filter('linky', ['$sanitize', function($sanitize) {
  var LINKY_URL_REGEXP =
        /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"Ã¢â¬ÂÃ¢â¬â¢]/,
      MAILTO_REGEXP = /^mailto:/;

  return function(text, target) {
    if (!text) return text;
    var match;
    var raw = text;
    var html = [];
    var url;
    var i;
    while ((match = raw.match(LINKY_URL_REGEXP))) {
      // We can not end in these as they are sometimes found at the end of the sentence
      url = match[0];
      // if we did not match ftp/http/www/mailto then assume mailto
      if (!match[2] && !match[4]) {
        url = (match[3] ? 'http://' : 'mailto:') + url;
      }
      i = match.index;
      addText(raw.substr(0, i));
      addLink(url, match[0].replace(MAILTO_REGEXP, ''));
      raw = raw.substring(i + match[0].length);
    }
    addText(raw);
    return $sanitize(html.join(''));

    function addText(text) {
      if (!text) {
        return;
      }
      html.push(sanitizeText(text));
    }

    function addLink(url, text) {
      html.push('<a ');
      if (angular.isDefined(target)) {
        html.push('target="',
                  target,
                  '" ');
      }
      html.push('href="',
                url.replace(/"/g, '&quot;'),
                '">');
      addText(text);
      html.push('</a>');
    }
  };
}]);


})(window, window.angular);;
/*!
 AngularJS v1.3.16
 (c) 2010-2014 Google, Inc. http://angularjs.org
 License: MIT
*/
(function(n,h,p){'use strict';function E(a){var e=[];r(e,h.noop).chars(a);return e.join("")}function g(a){var e={};a=a.split(",");var d;for(d=0;d<a.length;d++)e[a[d]]=!0;return e}function F(a,e){function d(a,b,d,l){b=h.lowercase(b);if(s[b])for(;f.last()&&t[f.last()];)c("",f.last());u[b]&&f.last()==b&&c("",b);(l=v[b]||!!l)||f.push(b);var m={};d.replace(G,function(a,b,e,c,d){m[b]=q(e||c||d||"")});e.start&&e.start(b,m,l)}function c(a,b){var c=0,d;if(b=h.lowercase(b))for(c=f.length-1;0<=c&&f[c]!=b;c--);
if(0<=c){for(d=f.length-1;d>=c;d--)e.end&&e.end(f[d]);f.length=c}}"string"!==typeof a&&(a=null===a||"undefined"===typeof a?"":""+a);var b,k,f=[],m=a,l;for(f.last=function(){return f[f.length-1]};a;){l="";k=!0;if(f.last()&&w[f.last()])a=a.replace(new RegExp("([\\W\\w]*)<\\s*\\/\\s*"+f.last()+"[^>]*>","i"),function(a,b){b=b.replace(H,"$1").replace(I,"$1");e.chars&&e.chars(q(b));return""}),c("",f.last());else{if(0===a.indexOf("\x3c!--"))b=a.indexOf("--",4),0<=b&&a.lastIndexOf("--\x3e",b)===b&&(e.comment&&
e.comment(a.substring(4,b)),a=a.substring(b+3),k=!1);else if(x.test(a)){if(b=a.match(x))a=a.replace(b[0],""),k=!1}else if(J.test(a)){if(b=a.match(y))a=a.substring(b[0].length),b[0].replace(y,c),k=!1}else K.test(a)&&((b=a.match(z))?(b[4]&&(a=a.substring(b[0].length),b[0].replace(z,d)),k=!1):(l+="<",a=a.substring(1)));k&&(b=a.indexOf("<"),l+=0>b?a:a.substring(0,b),a=0>b?"":a.substring(b),e.chars&&e.chars(q(l)))}if(a==m)throw L("badparse",a);m=a}c()}function q(a){if(!a)return"";A.innerHTML=a.replace(/</g,
"&lt;");return A.textContent}function B(a){return a.replace(/&/g,"&amp;").replace(M,function(a){var d=a.charCodeAt(0);a=a.charCodeAt(1);return"&#"+(1024*(d-55296)+(a-56320)+65536)+";"}).replace(N,function(a){return"&#"+a.charCodeAt(0)+";"}).replace(/</g,"&lt;").replace(/>/g,"&gt;")}function r(a,e){var d=!1,c=h.bind(a,a.push);return{start:function(a,k,f){a=h.lowercase(a);!d&&w[a]&&(d=a);d||!0!==C[a]||(c("<"),c(a),h.forEach(k,function(d,f){var k=h.lowercase(f),g="img"===a&&"src"===k||"background"===
k;!0!==O[k]||!0===D[k]&&!e(d,g)||(c(" "),c(f),c('="'),c(B(d)),c('"'))}),c(f?"/>":">"))},end:function(a){a=h.lowercase(a);d||!0!==C[a]||(c("</"),c(a),c(">"));a==d&&(d=!1)},chars:function(a){d||c(B(a))}}}var L=h.$$minErr("$sanitize"),z=/^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,y=/^<\/\s*([\w:-]+)[^>]*>/,G=/([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,K=/^</,J=/^<\//,H=/\x3c!--(.*?)--\x3e/g,x=/<!DOCTYPE([^>]*?)>/i,
I=/<!\[CDATA\[(.*?)]]\x3e/g,M=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,N=/([^\#-~| |!])/g,v=g("area,br,col,hr,img,wbr");n=g("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr");p=g("rp,rt");var u=h.extend({},p,n),s=h.extend({},n,g("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul")),t=h.extend({},p,g("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var"));
n=g("animate,animateColor,animateMotion,animateTransform,circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set,stop,svg,switch,text,title,tspan,use");var w=g("script,style"),C=h.extend({},v,s,t,u,n),D=g("background,cite,href,longdesc,src,usemap,xlink:href");n=g("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,target,title,type,valign,value,vspace,width");
p=g("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan");
var O=h.extend({},D,p,n),A=document.createElement("pre");h.module("ngSanitize",[]).provider("$sanitize",function(){this.$get=["$$sanitizeUri",function(a){return function(e){var d=[];F(e,r(d,function(c,b){return!/^unsafe/.test(a(c,b))}));return d.join("")}}]});h.module("ngSanitize").filter("linky",["$sanitize",function(a){var e=/((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/,d=/^mailto:/;return function(c,b){function k(a){a&&g.push(E(a))}function f(a,c){g.push("<a ");
h.isDefined(b)&&g.push('target="',b,'" ');g.push('href="',a.replace(/"/g,"&quot;"),'">');k(c);g.push("</a>")}if(!c)return c;for(var m,l=c,g=[],n,p;m=l.match(e);)n=m[0],m[2]||m[4]||(n=(m[3]?"http://":"mailto:")+n),p=m.index,k(l.substr(0,p)),f(n,m[0].replace(d,"")),l=l.substring(p+m[0].length);k(l);return a(g.join(""))}}])})(window,window.angular);;
/*!
LICENSE-START
The MIT License (MIT)

Copyright (c) 2014 Geoffrey Bauduin

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
LICENSE-END
**/
/*
Modified for Elements EL-1567
*/
(function() {
  angular.module("ngJScrollPane", []);

  angular.module("ngJScrollPane").directive("scrollPane", [
    '$timeout', function($timeout) {
      return {
        restrict: 'A',
        transclude: true,
        template: '<div class="scroll-pane"><div ng-transclude></div></div>',
        link: function($scope, $elem, $attrs) {
          var config, fn, selector;

          config = {};
          if ($attrs.scrollConfig) {
            config = $scope.$eval($attrs.scrollConfig);
          }
          fn = function() {
            $elem.jScrollPane(config);
            return $scope.pane = $elem.data("jsp");
          };
          if ($attrs.scrollTimeout) {
            $timeout(fn, $scope.$eval($attrs.scrollTimeout));
          } else {
            $timeout(fn, 0);
          }

          // HPE Elements Modification
          $scope.$on('$destroy', function() {
            if($scope.pane) {
              $scope.pane.destroy(true);
            }
          });
          // End Modification

          return $scope.$on("reinit-pane", function(event, id) {
            if ($scope.pane) {
              return $scope.$apply(function() {
                $scope.pane.destroy();
                return fn();
              });
            }
          });
        },
        replace: true
      };
    }
  ]);

}).call(this);
;
/*!
LICENSE-START
The MIT License (MIT)

Copyright (c) 2014 Alec LaLonde and contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
LICENSE-END
*/

(function (angular) {
  'use strict';
  angular.module('scrollable-table', [])
    .directive('scrollableTable', ['$timeout', '$q', '$parse', '$animate', function ($timeout, $q, $parse, $animate) {
      return {
        transclude: true,
        restrict: 'E',
        scope: {
          rows: '=watch',
          containerHeight:"=",
          headerHeight: "=",
          watchHeaders: "="
        },
        template: '<div class="scrollableContainer">' +
                    '<div class="headerSpacer"></div>' +
                    '<div class="scrollArea" ng-transclude></div>' +
                  '</div>',
        controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {

          //HPEElements - modification
          window.requestAnimFrame = (function(){
              return  window.requestAnimationFrame       ||
                      window.webkitRequestAnimationFrame ||
                      window.mozRequestAnimationFrame    ||
                      function( callback ){
                        window.setTimeout(callback, 1000 / 60);
                      };
          })();

          var rendered = false;
          var renderedHeader = false;

          // define an API for child directives to view and modify sorting parameters

          this.renderTalble = function (){
            return waitForRender().then(fixHeaderWidths);
          };

          this.getTableElement = function (){
            return $element;
          };

          /**
           * append handle function to execute after table header resize.
           */
          this.appendTableResizingHandler = function (handler){
            var handlerSequence = $scope.headerResizeHanlers || [];
            for(var i = 0;i < handlerSequence.length;i++){
              if(handlerSequence[i].name === handler.name){
                return;
              }
            }
            handlerSequence.push(handler);
            $scope.headerResizeHanlers = handlerSequence;
          };

          function defaultCompare(row1, row2) {
            var exprParts = $scope.sortExpr.match(/(.+)\s+as\s+(.+)/);
            var scope = {};
            scope[exprParts[1]] = row1;
            var x = $parse(exprParts[2])(scope);

            scope[exprParts[1]] = row2;
            var y = $parse(exprParts[2])(scope);

            if (x === y) return 0;
            return x > y ? 1 : -1;
          }

          function scrollToRow(row) {
            var offset = $element.find(".headerSpacer").height();
            var currentScrollTop = $element.find(".scrollArea").scrollTop();
            $element.find(".scrollArea").scrollTop(currentScrollTop + row.position().top - offset);
          }

          $scope.$on('rowSelected', function (event, rowId) {
            var row = $element.find(".scrollArea table tr[row-id='" + rowId + "']");
            if (row.length === 1) {
              // Ensure that the headers have been fixed before scrolling, to ensure accurate
              // position calculations
              $q.all([waitForRender(), headersAreFixed.promise]).then(function () {
                scrollToRow(row);
              });
            }
          });

          // Set fixed widths for the table headers in case the text overflows.
          // There's no callback for when rendering is complete, so check the visibility of the table
          // periodically -- see http://stackoverflow.com/questions/11125078

          //HPEElements - modified to reduce flicker when element is initially hidden
          function waitForRender() {

            var deferredRender = $q.defer();

            var table = $element.find('table');

            //hide table until render is complete
            if(rendered === false)
              table.css('visibility', 'hidden');

            function wait() {

              var resolve = true;

              var tableDisplayed = table[0];

              while(tableDisplayed !== null) {

                // do some light checking first before checking for computed values
                if(tableDisplayed.style.display === 'none' || tableDisplayed.style.width === '0px' || tableDisplayed.style.width === '0%') {
                  resolve = false;
                  break;
                }

                var computedStyles = window.getComputedStyle(tableDisplayed);

                // get properties we are going to check
                var display = computedStyles.display;
                var width = parseInt(computedStyles.width);
                // use offsetHeight as getting height from computed style is buggy in IE
                var height = tableDisplayed.offsetHeight;

                //check if a parent element has a display of none or a width of 0px and if so dont fix the header widths
                if(display === 'none' || display === 'block' && height === 0 || width === 0){
                  resolve = false;                 
                  break;
                }

                tableDisplayed = tableDisplayed.parentElement || null;
              }

              if(resolve){
                deferredRender.resolve();
                renderedHeader = true;
              }
              else
                requestAnimFrame(wait);
            }

            requestAnimFrame(wait);

            return deferredRender.promise;
          }

          var headersAreFixed = $q.defer();

          function fixHeaderWidths() {
            
            if (!$element.find("thead th .th-inner").length) {
              $element.find("thead th").wrapInner('<div class="th-inner"></div>');
            }
            if($element.find("thead th .th-inner:not(:has(.box))").length) {
              $element.find("thead th .th-inner:not(:has(.box))").wrapInner('<div class="box"></div>');
            }
            $element.find("table th .th-inner:visible").each(function (index, el) {
              el = angular.element(el);
              var width = el.parent().width(),
                lastCol = $element.find("table th:visible:last"),
                headerWidth = width;
              if (lastCol.css("text-align") !== "center") {
                var hasScrollbar = $element.find(".scrollArea").height() < $element.find("table").height();
                if (lastCol[0] == el.parent()[0] && hasScrollbar) {
                  headerWidth += $element.find(".scrollArea").width() - $element.find("tbody tr").width();
                  headerWidth = Math.max(headerWidth, width);
                }
              }
              var minWidth = _getScale(el.parent().css('min-width')),
                title = el.parent().attr("titleName");
              headerWidth = Math.max(minWidth, headerWidth);
              el.css("width", headerWidth);
              if (!title) {
                // ordinary column(not sortableHeader) has box child div element that contained title string.
                title = el.find(".title .ng-scope").html() || el.find(".box").html();
              }
              el.attr("titleName", title.trim());
            });
            headersAreFixed.resolve();

            //HPEElements - modification to show table after render
            if(rendered === false) {
              $element.find('table').css('visibility', '');      
            }
            if(renderedHeader === true) {
              $element.find('thead').css('visibility', '');      
            } 
          }

          // when the data model changes, fix the header widths.  See the comments here:
          // http://docs.angularjs.org/api/ng.$timeout
          $scope.$watch('rows', function (newValue, oldValue) {
            if (newValue) {
              renderChains($element.find('.scrollArea').width());
              // clean sort status and scroll to top of table once records replaced.
              $scope.sortExpr = null;
              // FIXME what is the reason here must scroll to top? This may cause confusing if using scrolling to implement pagination.
              $element.find('.scrollArea').scrollTop(0);
            }
          });

          //Elements watch added for headers
          $scope.$watch('watchHeaders', function (newValue, oldValue) {
            if (newValue) {
              $element.find('thead').css('visibility', 'hidden');
              renderChains($element.find('.scrollArea').width());
            }
          });

          $scope.asc = !$attrs.hasOwnProperty("desc");
          $scope.sortAttr = $attrs.sortAttr;

          $element.find(".scrollArea").scroll(function (event) {
            $element.find("thead th .th-inner").css('margin-left', 0 - event.target.scrollLeft);
          });

          $scope.$on("renderScrollableTable", function() {
            renderChains($element.find('.scrollArea').width());
          });

          angular.element(window).on('resize', function(){
            $timeout(function(){
              $scope.$apply();
            });
          });
          $scope.$watch(function(){
            return $element.find('.scrollArea').width();
          }, function(newWidth, oldWidth){
            if(newWidth * oldWidth < 0) {
              return;
            }
            renderChains();
          });

          function renderChains(){
            var resizeQueue = waitForRender().then(fixHeaderWidths);
            
              var customHandlers = $scope.headerResizeHanlers || [];
              for(var i = 0;i < customHandlers.length;i++){
                resizeQueue = resizeQueue.then(customHandlers[i]);
              }
            return resizeQueue;
          }
        }],
        link: function(scope, element) {

          // HPEElements - modification
          $animate.enabled(false, element);

          /*! HPElements  - code added to configure the container height */
          angular.element('.scrollableContainer').height(scope.containerHeight);
          angular.element('.scrollableContainer .headerSpacer').height(scope.headerHeight);
          /*! HPElements   - code added to configure the container height */
        }
      };
    }])
    .directive('resizable', ['$compile', function($compile){
      return {
        restrict: 'A',
        priority: 0,
        scope: false,
        require: 'scrollableTable',
        link: function postLink(scope, elm, attrs, tableController){
          tableController.appendTableResizingHandler(function(){
            _init();
          });

          tableController.appendTableResizingHandler(function relayoutHeaders(){
            var tableElement = tableController.getTableElement().find('.scrollArea table');
            if(tableElement.css('table-layout') === 'auto'){
              initRodPos();
            }else{
              _resetColumnsSize(tableElement.parent().width());
            }
          });

          scope.resizing = function(e){
            var screenOffset = tableController.getTableElement().find('.scrollArea').scrollLeft(),
              thInnerElm =  angular.element(e.target).parent(),
              thElm = thInnerElm.parent(),
              startPoint = _getScale(thInnerElm.css('left')) + thInnerElm.width() - screenOffset,
              movingPos = e.pageX,
              _document = angular.element(document),
              _body = angular.element('body'),
              coverPanel = angular.element('.scrollableContainer .resizing-cover'),
              scaler = angular.element('<div class="scaler">');

            _body.addClass('scrollable-resizing');
            coverPanel.addClass('active');
            angular.element('.scrollableContainer').append(scaler);
            scaler.css('left', startPoint);

            _document.bind('mousemove', function (e){
              var offsetX = e.pageX - movingPos,
                movedOffset = _getScale(scaler.css('left')) - startPoint,
                widthOfActiveCol = thElm.width(),
                nextElm = thElm.nextAll('th:visible').first(),
                minWidthOfActiveCol = _getScale(thElm.css('min-width')),
                widthOfNextColOfActive = nextElm.width(),
                minWidthOfNextColOfActive = _getScale(nextElm.css('min-width'));
              movingPos = e.pageX;
              e.preventDefault();
              if((offsetX > 0 && widthOfNextColOfActive - movedOffset <= minWidthOfNextColOfActive)
                || (offsetX < 0 && widthOfActiveCol + movedOffset <= minWidthOfActiveCol)){
                //stopping resize if user trying to extension and the active/next column already minimised.
                return;
              }
              scaler.css('left', _getScale(scaler.css('left')) + offsetX);
            });
            _document.bind('mouseup', function (e) {
              e.preventDefault();
              scaler.remove();
              _body.removeClass('scrollable-resizing');
              coverPanel.removeClass('active');
              _document.unbind('mousemove');
              _document.unbind('mouseup');

              var offsetX = _getScale(scaler.css('left')) - startPoint,
                newWidth = thElm.width(),
                minWidth = _getScale(thElm.css('min-width')),
                nextElm = thElm.nextAll('th:visible').first(),
                widthOfNextColOfActive = nextElm.width(),
                minWidthOfNextColOfActive = _getScale(nextElm.css('min-width')),
                tableElement = tableController.getTableElement().find('.scrollArea table');

              //hold original width of cells, to display cells as their original width after turn table-layout to fixed.
              if(tableElement.css('table-layout') === 'auto'){
                tableElement.find("th .th-inner").each(function (index, el) {
                  el = angular.element(el);
                  var width = el.parent().width();
                  el.parent().css('width', width);
                });
              }

              tableElement.css('table-layout', 'fixed');

              if(offsetX > 0 && widthOfNextColOfActive - offsetX <= minWidthOfNextColOfActive){
                offsetX = widthOfNextColOfActive - minWidthOfNextColOfActive;
              }
              nextElm.removeAttr('style');
              newWidth += offsetX;
              thElm.css('width', Math.max(minWidth, newWidth));
              nextElm.css('width', widthOfNextColOfActive - offsetX);
              tableController.renderTalble().then(resizeHeaderWidth());
            });
          };

          function _init(){
            var thInnerElms = elm.find('table th:not(:last-child) .th-inner');
            if(thInnerElms.find('.resize-rod').length == 0){
              tableController.getTableElement().find('.scrollArea table').css('table-layout', 'auto');
              var resizeRod = angular.element('<div class="resize-rod" ng-mousedown="resizing($event)"></div>');
              thInnerElms.append($compile(resizeRod)(scope));
            }
          }

          function initRodPos(){
            var tableElement = tableController.getTableElement();
            var headerPos = 1;//  1 is the width of right border;
            tableElement.find("table th .th-inner:visible").each(function (index, el) {
              el = angular.element(el);
              var width = el.parent().width(),   //to made header consistent with its parent.
              // if it's the last header, add space for the scrollbar equivalent unless it's centered
                minWidth = _getScale(el.parent().css('min-width'));
              width = Math.max(minWidth, width);
              el.css("left", headerPos);
              headerPos += width;
            });
          }

          function resizeHeaderWidth(){
            var headerPos = 1,//  1 is the width of right border;
              tableElement = tableController.getTableElement();
            tableController.getTableElement().find("table th .th-inner:visible").each(function (index, el) {
              el = angular.element(el);
              var width = el.parent().width(),   //to made header consistent with its parent.
              // if it's the last header, add space for the scrollbar equivalent unless it's centered
                lastCol = tableElement.find("table th:visible:last"),
                minWidth = _getScale(el.parent().css('min-width'));
              width = Math.max(minWidth, width);
              //following are resize stuff, to made th-inner position correct.
              //last column's width should be automatically, to avoid horizontal scroll.
              if (lastCol[0] != el.parent()[0]){
                el.parent().css('width', width);
              }
              el.css("left", headerPos);
              headerPos += width;
            });
          }

          function _resetColumnsSize(tableWidth){
            var tableElement = tableController.getTableElement(),
              columnLength = tableElement.find("table th:visible").length,
              lastCol = tableElement.find("table th:visible:last");
            tableElement.find("table th:visible").each(function (index, el) {
              el = angular.element(el);
              if(lastCol.get(0) == el.get(0)){
                //last column's width should be automaically, to avoid horizontal scroll.
                el.css('width', 'auto');
                return;
              }
              var _width = el.data('width');
              if(/\d+%$/.test(_width)){    //percentage
                _width = Math.ceil(tableWidth * _getScale(_width) / 100);
              } else {
                // if data-width not exist, use average width for each columns.
                _width = tableWidth / columnLength;
              }
              el.css('width', _width + 'px');
            });
            tableController.renderTalble().then(resizeHeaderWidth());
          }
        }
      }
    }]);

  function _getScale(sizeCss){
    return parseInt(sizeCss.replace(/px|%/, ''), 10);
  }
})(angular);
;
/*!
LICENSE-START
Copyright 2015 Robert Pocklington
http://github.com/rpocklin/angular-timeline

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
LICENSE-END
*/(function () {
'use strict';
angular.module('angular-timeline', []);// Source: src/timeline-badge-directive.js
/**
 * @ngdoc directive
 * @name angular-timeline.directive:timeline-badge
 * @restrict AE
 *
 * @description
 * Shown in the centre pane (or left on narrow devices) to indicate the activity.
 */
angular.module('angular-timeline').directive('timelineBadge',['$timeout',function($timeout) {
  return {
    require: '^timelineEvent',
    restrict: 'AE',
    transclude: true,
    template: '<div class="timeline-badge"><span ng-transclude></span></div>',
    link: function (scope, element, attrs,controller) {
        controller.setWidths(element.width());

      //Allow any bindings to be processed
      $timeout(function(){
          //make sure the span ellipsis text on overflow
          var textContainer= element.find('span')[0];
          textContainer.style.textOverflow= 'ellipsis';
          textContainer.style.whiteSpace= 'nowrap';
          textContainer.style.display= 'block';
          textContainer.style.overflow= 'hidden';
          //check if we need to truncate the text
          var textWidth= textContainer.scrollWidth;
          var textContainerWidth= textContainer.offsetWidth;
          //get the text
          var text= textContainer.innerHTML;

          //then show the tooltip
          if(textWidth > textContainerWidth)
            $(textContainer).tooltip({container:'body',title:text,html:true});
      });

    }
  };
}]);

// Source: src/timeline-directive.js
/**
 * @ngdoc directive
 * @name angular-timeline
 * @restrict AE
 *
 * @description
 * Primary container for displaying a vertical set of timeline events.
 */
angular.module('angular-timeline').directive('timeline', function() {
  return {
    restrict: 'AE',
    transclude: true,
    template: '<ul class="timeline hp-timeline-down-arrow" ng-transclude></ul>',
    controller: function() {}
  };
});

// Source: src/timeline-event-directive.js
/**
 * @ngdoc directive
 * @name angular-timeline.directive:timeline
 * @restrict AE
 *
 * @description
 * Represents an event occuring at a point in time, displayed on the left or the right
 * of the timeline line.
 *
 * You typically embed a `timeline-badge` and `timeline-panel` element within a `timeline-event`.
 *
 * @param {string=} side  Define the side of the element (i.e. side="left", side="right", or use an {{ expression }}).
 */

angular.module('angular-timeline').directive('timelineEvent', function() {
  return {
    require: '^timeline',
    restrict: 'AE',
    transclude: true,
    template: '<li ng-class-odd="oddClass" ng-class-even="evenClass" ng-transclude></li>',
    controller: ['$scope', '$element', function($scope,$element){
      this.setWidths= function(badgeWidth) {

        var side= $element[0].getAttribute("side");
        if(side==="alternate")
        {
          var alternateSubtractWidth= badgeWidth+25;
          $element.find("timeline-panel")[0].style.width='calc(50% - '+alternateSubtractWidth+'px)';
        }

      }
    }],
    link: function(scope, element, attrs, controller) {

      //Set the side as right for elements timeline
      element[0].setAttribute("side","right");
      attrs.side = "right";

      var checkClass = function(side, leftSide) {

        var leftClass = '';
        var rightClass = 'timeline-inverted';

        if (side === 'left' || (!side && leftSide === true)) {
          return leftClass;
        }
        else if ((side === 'alternate' || !side) && leftSide === false) {
          return rightClass;
        }
        else if (side === 'right') {
          return rightClass;
        }
        else {
          return leftClass;
        }
      };

      var updateRowClasses = function(value) {
        scope.oddClass = checkClass(value, true);
        scope.evenClass = checkClass(value, false);
         element[0].parentNode.parentNode.setAttribute("side",value);
      };

      attrs.$observe('side', function(newValue) {
        updateRowClasses(newValue);
      });

      updateRowClasses(attrs.side);
    }
  };
});

// Source: src/timeline-footer-directive.js
/**
 * @ngdoc directive
 * @name angular-timeline.directive:timeline-footer
 * @restrict AE
 *
 * @description
 * Optional element to add a footer section to the `timeline-panel` for links or other actions.
 */
angular.module('angular-timeline').directive('timelineFooter', function() {
  return {
    require: '^timelinePanel',
    restrict: 'AE',
    transclude: true,
    template: '<div class="timeline-footer" ng-transclude></div>'
  };
});

// Source: src/timeline-heading-directive.js
/**
 * @ngdoc directive
 * @name angular-timeline.directive:timeline-heading
 * @restrict AE
 *
 * @description
 * Optional element to show the heading for a `timeline-panel`.
 */
angular.module('angular-timeline').directive('timelineHeading', function() {
  return {
    require: '^timelinePanel',
    restrict: 'AE',
    transclude: true,
    template: '<div class="timeline-heading" ng-transclude></div>'
  };
});

// Source: src/timeline-panel-directive.js
/**
 * @ngdoc directive
 * @name angular-timeline.directive:timeline-panel
 * @restrict AE
 *
 * @description
 * An panel inside the `timeline-event` which shows detailed information about the event.
 */
angular.module('angular-timeline').directive('timelinePanel', function() {
  return {
    require: '^timeline',
    restrict: 'AE',
    transclude: true,
    template: '<div class="timeline-panel" ng-transclude></div>'
  };
});
})();;
/**
LICENSE-START
 * State-based routing for AngularJS
 * @version v0.2.13
 * @link http://angular-ui.github.com/
 * @license MIT License, http://www.opensource.org/licenses/MIT
 LICENSE-END
 */

/* commonjs package manager support (eg componentjs) */
if (typeof module !== "undefined" && typeof exports !== "undefined" && module.exports === exports){
  module.exports = 'ui.router';
}

(function (window, angular, undefined) {
/*jshint globalstrict:true*/
/*global angular:false*/
'use strict';

var isDefined = angular.isDefined,
    isFunction = angular.isFunction,
    isString = angular.isString,
    isObject = angular.isObject,
    isArray = angular.isArray,
    forEach = angular.forEach,
    extend = angular.extend,
    copy = angular.copy;

function inherit(parent, extra) {
  return extend(new (extend(function() {}, { prototype: parent }))(), extra);
}

function merge(dst) {
  forEach(arguments, function(obj) {
    if (obj !== dst) {
      forEach(obj, function(value, key) {
        if (!dst.hasOwnProperty(key)) dst[key] = value;
      });
    }
  });
  return dst;
}

/**
 * Finds the common ancestor path between two states.
 *
 * @param {Object} first The first state.
 * @param {Object} second The second state.
 * @return {Array} Returns an array of state names in descending order, not including the root.
 */
function ancestors(first, second) {
  var path = [];

  for (var n in first.path) {
    if (first.path[n] !== second.path[n]) break;
    path.push(first.path[n]);
  }
  return path;
}

/**
 * IE8-safe wrapper for `Object.keys()`.
 *
 * @param {Object} object A JavaScript object.
 * @return {Array} Returns the keys of the object as an array.
 */
function objectKeys(object) {
  if (Object.keys) {
    return Object.keys(object);
  }
  var result = [];

  angular.forEach(object, function(val, key) {
    result.push(key);
  });
  return result;
}

/**
 * IE8-safe wrapper for `Array.prototype.indexOf()`.
 *
 * @param {Array} array A JavaScript array.
 * @param {*} value A value to search the array for.
 * @return {Number} Returns the array index value of `value`, or `-1` if not present.
 */
function indexOf(array, value) {
  if (Array.prototype.indexOf) {
    return array.indexOf(value, Number(arguments[2]) || 0);
  }
  var len = array.length >>> 0, from = Number(arguments[2]) || 0;
  from = (from < 0) ? Math.ceil(from) : Math.floor(from);

  if (from < 0) from += len;

  for (; from < len; from++) {
    if (from in array && array[from] === value) return from;
  }
  return -1;
}

/**
 * Merges a set of parameters with all parameters inherited between the common parents of the
 * current state and a given destination state.
 *
 * @param {Object} currentParams The value of the current state parameters ($stateParams).
 * @param {Object} newParams The set of parameters which will be composited with inherited params.
 * @param {Object} $current Internal definition of object representing the current state.
 * @param {Object} $to Internal definition of object representing state to transition to.
 */
function inheritParams(currentParams, newParams, $current, $to) {
  var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];

  for (var i in parents) {
    if (!parents[i].params) continue;
    parentParams = objectKeys(parents[i].params);
    if (!parentParams.length) continue;

    for (var j in parentParams) {
      if (indexOf(inheritList, parentParams[j]) >= 0) continue;
      inheritList.push(parentParams[j]);
      inherited[parentParams[j]] = currentParams[parentParams[j]];
    }
  }
  return extend({}, inherited, newParams);
}

/**
 * Performs a non-strict comparison of the subset of two objects, defined by a list of keys.
 *
 * @param {Object} a The first object.
 * @param {Object} b The second object.
 * @param {Array} keys The list of keys within each object to compare. If the list is empty or not specified,
 *                     it defaults to the list of keys in `a`.
 * @return {Boolean} Returns `true` if the keys match, otherwise `false`.
 */
function equalForKeys(a, b, keys) {
  if (!keys) {
    keys = [];
    for (var n in a) keys.push(n); // Used instead of Object.keys() for IE8 compatibility
  }

  for (var i=0; i<keys.length; i++) {
    var k = keys[i];
    if (a[k] != b[k]) return false; // Not '===', values aren't necessarily normalized
  }
  return true;
}

/**
 * Returns the subset of an object, based on a list of keys.
 *
 * @param {Array} keys
 * @param {Object} values
 * @return {Boolean} Returns a subset of `values`.
 */
function filterByKeys(keys, values) {
  var filtered = {};

  forEach(keys, function (name) {
    filtered[name] = values[name];
  });
  return filtered;
}

// like _.indexBy
// when you know that your index values will be unique, or you want last-one-in to win
function indexBy(array, propName) {
  var result = {};
  forEach(array, function(item) {
    result[item[propName]] = item;
  });
  return result;
}

// extracted from underscore.js
// Return a copy of the object only containing the whitelisted properties.
function pick(obj) {
  var copy = {};
  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
  forEach(keys, function(key) {
    if (key in obj) copy[key] = obj[key];
  });
  return copy;
}

// extracted from underscore.js
// Return a copy of the object omitting the blacklisted properties.
function omit(obj) {
  var copy = {};
  var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
  for (var key in obj) {
    if (indexOf(keys, key) == -1) copy[key] = obj[key];
  }
  return copy;
}

function pluck(collection, key) {
  var result = isArray(collection) ? [] : {};

  forEach(collection, function(val, i) {
    result[i] = isFunction(key) ? key(val) : val[key];
  });
  return result;
}

function filter(collection, callback) {
  var array = isArray(collection);
  var result = array ? [] : {};
  forEach(collection, function(val, i) {
    if (callback(val, i)) {
      result[array ? result.length : i] = val;
    }
  });
  return result;
}

function map(collection, callback) {
  var result = isArray(collection) ? [] : {};

  forEach(collection, function(val, i) {
    result[i] = callback(val, i);
  });
  return result;
}

/**
 * @ngdoc overview
 * @name ui.router.util
 *
 * @description
 * # ui.router.util sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 *
 */
angular.module('ui.router.util', ['ng']);

/**
 * @ngdoc overview
 * @name ui.router.router
 * 
 * @requires ui.router.util
 *
 * @description
 * # ui.router.router sub-module
 *
 * This module is a dependency of other sub-modules. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 */
angular.module('ui.router.router', ['ui.router.util']);

/**
 * @ngdoc overview
 * @name ui.router.state
 * 
 * @requires ui.router.router
 * @requires ui.router.util
 *
 * @description
 * # ui.router.state sub-module
 *
 * This module is a dependency of the main ui.router module. Do not include this module as a dependency
 * in your angular app (use {@link ui.router} module instead).
 * 
 */
angular.module('ui.router.state', ['ui.router.router', 'ui.router.util']);

/**
 * @ngdoc overview
 * @name ui.router
 *
 * @requires ui.router.state
 *
 * @description
 * # ui.router
 * 
 * ## The main module for ui.router 
 * There are several sub-modules included with the ui.router module, however only this module is needed
 * as a dependency within your angular app. The other modules are for organization purposes. 
 *
 * The modules are:
 * * ui.router - the main "umbrella" module
 * * ui.router.router - 
 * 
 * *You'll need to include **only** this module as the dependency within your angular app.*
 * 
 * <pre>
 * <!doctype html>
 * <html ng-app="myApp">
 * <head>
 *   <script src="js/angular.js"></script>
 *   <!-- Include the ui-router script -->
 *   <script src="js/angular-ui-router.min.js"></script>
 *   <script>
 *     // ...and add 'ui.router' as a dependency
 *     var myApp = angular.module('myApp', ['ui.router']);
 *   </script>
 * </head>
 * <body>
 * </body>
 * </html>
 * </pre>
 */
angular.module('ui.router', ['ui.router.state']);

angular.module('ui.router.compat', ['ui.router']);

/**
 * @ngdoc object
 * @name ui.router.util.$resolve
 *
 * @requires $q
 * @requires $injector
 *
 * @description
 * Manages resolution of (acyclic) graphs of promises.
 */
$Resolve.$inject = ['$q', '$injector'];
function $Resolve(  $q,    $injector) {
  
  var VISIT_IN_PROGRESS = 1,
      VISIT_DONE = 2,
      NOTHING = {},
      NO_DEPENDENCIES = [],
      NO_LOCALS = NOTHING,
      NO_PARENT = extend($q.when(NOTHING), { $$promises: NOTHING, $$values: NOTHING });
  

  /**
   * @ngdoc function
   * @name ui.router.util.$resolve#study
   * @methodOf ui.router.util.$resolve
   *
   * @description
   * Studies a set of invocables that are likely to be used multiple times.
   * <pre>
   * $resolve.study(invocables)(locals, parent, self)
   * </pre>
   * is equivalent to
   * <pre>
   * $resolve.resolve(invocables, locals, parent, self)
   * </pre>
   * but the former is more efficient (in fact `resolve` just calls `study` 
   * internally).
   *
   * @param {object} invocables Invocable objects
   * @return {function} a function to pass in locals, parent and self
   */
  this.study = function (invocables) {
    if (!isObject(invocables)) throw new Error("'invocables' must be an object");
    var invocableKeys = objectKeys(invocables || {});
    
    // Perform a topological sort of invocables to build an ordered plan
    var plan = [], cycle = [], visited = {};
    function visit(value, key) {
      if (visited[key] === VISIT_DONE) return;
      
      cycle.push(key);
      if (visited[key] === VISIT_IN_PROGRESS) {
        cycle.splice(0, indexOf(cycle, key));
        throw new Error("Cyclic dependency: " + cycle.join(" -> "));
      }
      visited[key] = VISIT_IN_PROGRESS;
      
      if (isString(value)) {
        plan.push(key, [ function() { return $injector.get(value); }], NO_DEPENDENCIES);
      } else {
        var params = $injector.annotate(value);
        forEach(params, function (param) {
          if (param !== key && invocables.hasOwnProperty(param)) visit(invocables[param], param);
        });
        plan.push(key, value, params);
      }
      
      cycle.pop();
      visited[key] = VISIT_DONE;
    }
    forEach(invocables, visit);
    invocables = cycle = visited = null; // plan is all that's required
    
    function isResolve(value) {
      return isObject(value) && value.then && value.$$promises;
    }
    
    return function (locals, parent, self) {
      if (isResolve(locals) && self === undefined) {
        self = parent; parent = locals; locals = null;
      }
      if (!locals) locals = NO_LOCALS;
      else if (!isObject(locals)) {
        throw new Error("'locals' must be an object");
      }       
      if (!parent) parent = NO_PARENT;
      else if (!isResolve(parent)) {
        throw new Error("'parent' must be a promise returned by $resolve.resolve()");
      }
      
      // To complete the overall resolution, we have to wait for the parent
      // promise and for the promise for each invokable in our plan.
      var resolution = $q.defer(),
          result = resolution.promise,
          promises = result.$$promises = {},
          values = extend({}, locals),
          wait = 1 + plan.length/3,
          merged = false;
          
      function done() {
        // Merge parent values we haven't got yet and publish our own $$values
        if (!--wait) {
          if (!merged) merge(values, parent.$$values); 
          result.$$values = values;
          result.$$promises = result.$$promises || true; // keep for isResolve()
          delete result.$$inheritedValues;
          resolution.resolve(values);
        }
      }
      
      function fail(reason) {
        result.$$failure = reason;
        resolution.reject(reason);
      }

      // Short-circuit if parent has already failed
      if (isDefined(parent.$$failure)) {
        fail(parent.$$failure);
        return result;
      }
      
      if (parent.$$inheritedValues) {
        merge(values, omit(parent.$$inheritedValues, invocableKeys));
      }

      // Merge parent values if the parent has already resolved, or merge
      // parent promises and wait if the parent resolve is still in progress.
      extend(promises, parent.$$promises);
      if (parent.$$values) {
        merged = merge(values, omit(parent.$$values, invocableKeys));
        result.$$inheritedValues = omit(parent.$$values, invocableKeys);
        done();
      } else {
        if (parent.$$inheritedValues) {
          result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
        }        
        parent.then(done, fail);
      }
      
      // Process each invocable in the plan, but ignore any where a local of the same name exists.
      for (var i=0, ii=plan.length; i<ii; i+=3) {
        if (locals.hasOwnProperty(plan[i])) done();
        else invoke(plan[i], plan[i+1], plan[i+2]);
      }
      
      function invoke(key, invocable, params) {
        // Create a deferred for this invocation. Failures will propagate to the resolution as well.
        var invocation = $q.defer(), waitParams = 0;
        function onfailure(reason) {
          invocation.reject(reason);
          fail(reason);
        }
        // Wait for any parameter that we have a promise for (either from parent or from this
        // resolve; in that case study() will have made sure it's ordered before us in the plan).
        forEach(params, function (dep) {
          if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
            waitParams++;
            promises[dep].then(function (result) {
              values[dep] = result;
              if (!(--waitParams)) proceed();
            }, onfailure);
          }
        });
        if (!waitParams) proceed();
        function proceed() {
          if (isDefined(result.$$failure)) return;
          try {
            invocation.resolve($injector.invoke(invocable, self, values));
            invocation.promise.then(function (result) {
              values[key] = result;
              done();
            }, onfailure);
          } catch (e) {
            onfailure(e);
          }
        }
        // Publish promise synchronously; invocations further down in the plan may depend on it.
        promises[key] = invocation.promise;
      }
      
      return result;
    };
  };
  
  /**
   * @ngdoc function
   * @name ui.router.util.$resolve#resolve
   * @methodOf ui.router.util.$resolve
   *
   * @description
   * Resolves a set of invocables. An invocable is a function to be invoked via 
   * `$injector.invoke()`, and can have an arbitrary number of dependencies. 
   * An invocable can either return a value directly,
   * or a `$q` promise. If a promise is returned it will be resolved and the 
   * resulting value will be used instead. Dependencies of invocables are resolved 
   * (in this order of precedence)
   *
   * - from the specified `locals`
   * - from another invocable that is part of this `$resolve` call
   * - from an invocable that is inherited from a `parent` call to `$resolve` 
   *   (or recursively
   * - from any ancestor `$resolve` of that parent).
   *
   * The return value of `$resolve` is a promise for an object that contains 
   * (in this order of precedence)
   *
   * - any `locals` (if specified)
   * - the resolved return values of all injectables
   * - any values inherited from a `parent` call to `$resolve` (if specified)
   *
   * The promise will resolve after the `parent` promise (if any) and all promises 
   * returned by injectables have been resolved. If any invocable 
   * (or `$injector.invoke`) throws an exception, or if a promise returned by an 
   * invocable is rejected, the `$resolve` promise is immediately rejected with the 
   * same error. A rejection of a `parent` promise (if specified) will likewise be 
   * propagated immediately. Once the `$resolve` promise has been rejected, no 
   * further invocables will be called.
   * 
   * Cyclic dependencies between invocables are not permitted and will caues `$resolve`
   * to throw an error. As a special case, an injectable can depend on a parameter 
   * with the same name as the injectable, which will be fulfilled from the `parent` 
   * injectable of the same name. This allows inherited values to be decorated. 
   * Note that in this case any other injectable in the same `$resolve` with the same
   * dependency would see the decorated value, not the inherited value.
   *
   * Note that missing dependencies -- unlike cyclic dependencies -- will cause an 
   * (asynchronous) rejection of the `$resolve` promise rather than a (synchronous) 
   * exception.
   *
   * Invocables are invoked eagerly as soon as all dependencies are available. 
   * This is true even for dependencies inherited from a `parent` call to `$resolve`.
   *
   * As a special case, an invocable can be a string, in which case it is taken to 
   * be a service name to be passed to `$injector.get()`. This is supported primarily 
   * for backwards-compatibility with the `resolve` property of `$routeProvider` 
   * routes.
   *
   * @param {object} invocables functions to invoke or 
   * `$injector` services to fetch.
   * @param {object} locals  values to make available to the injectables
   * @param {object} parent  a promise returned by another call to `$resolve`.
   * @param {object} self  the `this` for the invoked methods
   * @return {object} Promise for an object that contains the resolved return value
   * of all invocables, as well as any inherited and local values.
   */
  this.resolve = function (invocables, locals, parent, self) {
    return this.study(invocables)(locals, parent, self);
  };
}

angular.module('ui.router.util').service('$resolve', $Resolve);


/**
 * @ngdoc object
 * @name ui.router.util.$templateFactory
 *
 * @requires $http
 * @requires $templateCache
 * @requires $injector
 *
 * @description
 * Service. Manages loading of templates.
 */
$TemplateFactory.$inject = ['$http', '$templateCache', '$injector'];
function $TemplateFactory(  $http,   $templateCache,   $injector) {

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromConfig
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template from a configuration object. 
   *
   * @param {object} config Configuration object for which to load a template. 
   * The following properties are search in the specified order, and the first one 
   * that is defined is used to create the template:
   *
   * @param {string|object} config.template html string template or function to 
   * load via {@link ui.router.util.$templateFactory#fromString fromString}.
   * @param {string|object} config.templateUrl url to load or a function returning 
   * the url to load via {@link ui.router.util.$templateFactory#fromUrl fromUrl}.
   * @param {Function} config.templateProvider function to invoke via 
   * {@link ui.router.util.$templateFactory#fromProvider fromProvider}.
   * @param {object} params  Parameters to pass to the template function.
   * @param {object} locals Locals to pass to `invoke` if the template is loaded 
   * via a `templateProvider`. Defaults to `{ params: params }`.
   *
   * @return {string|object}  The template html as a string, or a promise for 
   * that string,or `null` if no template is configured.
   */
  this.fromConfig = function (config, params, locals) {
    return (
      isDefined(config.template) ? this.fromString(config.template, params) :
      isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) :
      isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) :
      null
    );
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromString
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template from a string or a function returning a string.
   *
   * @param {string|object} template html template as a string or function that 
   * returns an html template as a string.
   * @param {object} params Parameters to pass to the template function.
   *
   * @return {string|object} The template html as a string, or a promise for that 
   * string.
   */
  this.fromString = function (template, params) {
    return isFunction(template) ? template(params) : template;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromUrl
   * @methodOf ui.router.util.$templateFactory
   * 
   * @description
   * Loads a template from the a URL via `$http` and `$templateCache`.
   *
   * @param {string|Function} url url of the template to load, or a function 
   * that returns a url.
   * @param {Object} params Parameters to pass to the url function.
   * @return {string|Promise.<string>} The template html as a string, or a promise 
   * for that string.
   */
  this.fromUrl = function (url, params) {
    if (isFunction(url)) url = url(params);
    if (url == null) return null;
    else return $http
        .get(url, { cache: $templateCache, headers: { Accept: 'text/html' }})
        .then(function(response) { return response.data; });
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$templateFactory#fromProvider
   * @methodOf ui.router.util.$templateFactory
   *
   * @description
   * Creates a template by invoking an injectable provider function.
   *
   * @param {Function} provider Function to invoke via `$injector.invoke`
   * @param {Object} params Parameters for the template.
   * @param {Object} locals Locals to pass to `invoke`. Defaults to 
   * `{ params: params }`.
   * @return {string|Promise.<string>} The template html as a string, or a promise 
   * for that string.
   */
  this.fromProvider = function (provider, params, locals) {
    return $injector.invoke(provider, null, locals || { params: params });
  };
}

angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);

var $$UMFP; // reference to $UrlMatcherFactoryProvider

/**
 * @ngdoc object
 * @name ui.router.util.type:UrlMatcher
 *
 * @description
 * Matches URLs against patterns and extracts named parameters from the path or the search
 * part of the URL. A URL pattern consists of a path pattern, optionally followed by '?' and a list
 * of search parameters. Multiple search parameter names are separated by '&'. Search parameters
 * do not influence whether or not a URL is matched, but their values are passed through into
 * the matched parameters returned by {@link ui.router.util.type:UrlMatcher#methods_exec exec}.
 * 
 * Path parameter placeholders can be specified using simple colon/catch-all syntax or curly brace
 * syntax, which optionally allows a regular expression for the parameter to be specified:
 *
 * * `':'` name - colon placeholder
 * * `'*'` name - catch-all placeholder
 * * `'{' name '}'` - curly placeholder
 * * `'{' name ':' regexp|type '}'` - curly placeholder with regexp or type name. Should the
 *   regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.
 *
 * Parameter names may contain only word characters (latin letters, digits, and underscore) and
 * must be unique within the pattern (across both path and search parameters). For colon 
 * placeholders or curly placeholders without an explicit regexp, a path parameter matches any
 * number of characters other than '/'. For catch-all placeholders the path parameter matches
 * any number of characters.
 * 
 * Examples:
 * 
 * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for
 *   trailing slashes, and patterns have to match the entire path, not just a prefix.
 * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or
 *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.
 * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.
 * * `'/user/{id:[^/]*}'` - Same as the previous example.
 * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id
 *   parameter consists of 1 to 8 hex digits.
 * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the
 *   path into the parameter 'path'.
 * * `'/files/*path'` - ditto.
 * * `'/calendar/{start:date}'` - Matches "/calendar/2014-11-12" (because the pattern defined
 *   in the built-in  `date` Type matches `2014-11-12`) and provides a Date object in $stateParams.start
 *
 * @param {string} pattern  The pattern to compile into a matcher.
 * @param {Object} config  A configuration object hash:
 * @param {Object=} parentMatcher Used to concatenate the pattern/config onto
 *   an existing UrlMatcher
 *
 * * `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.
 * * `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.
 *
 * @property {string} prefix  A static prefix of this pattern. The matcher guarantees that any
 *   URL matching this matcher (i.e. any string for which {@link ui.router.util.type:UrlMatcher#methods_exec exec()} returns
 *   non-null) will start with this prefix.
 *
 * @property {string} source  The pattern that was passed into the constructor
 *
 * @property {string} sourcePath  The path portion of the source property
 *
 * @property {string} sourceSearch  The search portion of the source property
 *
 * @property {string} regex  The constructed regex that will be used to match against the url when 
 *   it is time to determine which url will match.
 *
 * @returns {Object}  New `UrlMatcher` object
 */
function UrlMatcher(pattern, config, parentMatcher) {
  config = extend({ params: {} }, isObject(config) ? config : {});

  // Find all placeholders and create a compiled pattern, using either classic or curly syntax:
  //   '*' name
  //   ':' name
  //   '{' name '}'
  //   '{' name ':' regexp '}'
  // The regular expression is somewhat complicated due to the need to allow curly braces
  // inside the regular expression. The placeholder regexp breaks down as follows:
  //    ([:*])([\w\[\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)
  //    \{([\w\[\]]+)(?:\:( ... ))?\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case
  //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either
  //    [^{}\\]+                       - anything other than curly braces or backslash
  //    \\.                            - a backslash escape
  //    \{(?:[^{}\\]+|\\.)*\}          - a matched set of curly braces containing other atoms
  var placeholder       = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      searchPlaceholder = /([:]?)([\w\[\]-]+)|\{([\w\[\]-]+)(?:\:((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
      compiled = '^', last = 0, m,
      segments = this.segments = [],
      parentParams = parentMatcher ? parentMatcher.params : {},
      params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(),
      paramNames = [];

  function addParameter(id, type, config, location) {
    paramNames.push(id);
    if (parentParams[id]) return parentParams[id];
    if (!/^\w+(-+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
    if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
    params[id] = new $$UMFP.Param(id, type, config, location);
    return params[id];
  }

  function quoteRegExp(string, pattern, squash) {
    var surroundPattern = ['',''], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
    if (!pattern) return result;
    switch(squash) {
      case false: surroundPattern = ['(', ')'];   break;
      case true:  surroundPattern = ['?(', ')?']; break;
      default:    surroundPattern = ['(' + squash + "|", ')?'];  break;
    }
    return result + surroundPattern[0] + pattern + surroundPattern[1];
  }

  this.source = pattern;

  // Split into static segments separated by path parameter placeholders.
  // The number of segments is always 1 more than the number of parameters.
  function matchDetails(m, isSearch) {
    var id, regexp, segment, type, cfg, arrayMode;
    id          = m[2] || m[3]; // IE[78] returns '' for unmatched groups instead of null
    cfg         = config.params[id];
    segment     = pattern.substring(last, m.index);
    regexp      = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
    type        = $$UMFP.type(regexp || "string") || inherit($$UMFP.type("string"), { pattern: new RegExp(regexp) });
    return {
      id: id, regexp: regexp, segment: segment, type: type, cfg: cfg
    };
  }

  var p, param, segment;
  while ((m = placeholder.exec(pattern))) {
    p = matchDetails(m, false);
    if (p.segment.indexOf('?') >= 0) break; // we're into the search part

    param = addParameter(p.id, p.type, p.cfg, "path");
    compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash);
    segments.push(p.segment);
    last = placeholder.lastIndex;
  }
  segment = pattern.substring(last);

  // Find any search parameter names and remove them from the last segment
  var i = segment.indexOf('?');

  if (i >= 0) {
    var search = this.sourceSearch = segment.substring(i);
    segment = segment.substring(0, i);
    this.sourcePath = pattern.substring(0, last + i);

    if (search.length > 0) {
      last = 0;
      while ((m = searchPlaceholder.exec(search))) {
        p = matchDetails(m, true);
        param = addParameter(p.id, p.type, p.cfg, "search");
        last = placeholder.lastIndex;
        // check if ?&
      }
    }
  } else {
    this.sourcePath = pattern;
    this.sourceSearch = '';
  }

  compiled += quoteRegExp(segment) + (config.strict === false ? '\/?' : '') + '$';
  segments.push(segment);

  this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
  this.prefix = segments[0];
  this.$$paramNames = paramNames;
}

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#concat
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Returns a new matcher for a pattern constructed by appending the path part and adding the
 * search parameters of the specified pattern to this pattern. The current pattern is not
 * modified. This can be understood as creating a pattern for URLs that are relative to (or
 * suffixes of) the current pattern.
 *
 * @example
 * The following two matchers are equivalent:
 * <pre>
 * new UrlMatcher('/user/{id}?q').concat('/details?date');
 * new UrlMatcher('/user/{id}/details?q&date');
 * </pre>
 *
 * @param {string} pattern  The pattern to append.
 * @param {Object} config  An object hash of the configuration for the matcher.
 * @returns {UrlMatcher}  A matcher for the concatenated pattern.
 */
UrlMatcher.prototype.concat = function (pattern, config) {
  // Because order of search parameters is irrelevant, we can add our own search
  // parameters to the end of the new pattern. Parse the new pattern by itself
  // and then join the bits together, but it's much easier to do this on a string level.
  var defaultConfig = {
    caseInsensitive: $$UMFP.caseInsensitive(),
    strict: $$UMFP.strictMode(),
    squash: $$UMFP.defaultSquashPolicy()
  };
  return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
};

UrlMatcher.prototype.toString = function () {
  return this.source;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#exec
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Tests the specified path against this matcher, and returns an object containing the captured
 * parameter values, or null if the path does not match. The returned object contains the values
 * of any search parameters that are mentioned in the pattern, but their value may be null if
 * they are not present in `searchParams`. This means that search parameters are always treated
 * as optional.
 *
 * @example
 * <pre>
 * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {
 *   x: '1', q: 'hello'
 * });
 * // returns { id: 'bob', q: 'hello', r: null }
 * </pre>
 *
 * @param {string} path  The URL path to match, e.g. `$location.path()`.
 * @param {Object} searchParams  URL search parameters, e.g. `$location.search()`.
 * @returns {Object}  The captured parameter values.
 */
UrlMatcher.prototype.exec = function (path, searchParams) {
  var m = this.regexp.exec(path);
  if (!m) return null;
  searchParams = searchParams || {};

  var paramNames = this.parameters(), nTotal = paramNames.length,
    nPath = this.segments.length - 1,
    values = {}, i, j, cfg, paramName;

  if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");

  function decodePathArray(string) {
    function reverseString(str) { return str.split("").reverse().join(""); }
    function unquoteDashes(str) { return str.replace(/\\-/, "-"); }

    var split = reverseString(string).split(/-(?!\\)/);
    var allReversed = map(split, reverseString);
    return map(allReversed, unquoteDashes).reverse();
  }

  for (i = 0; i < nPath; i++) {
    paramName = paramNames[i];
    var param = this.params[paramName];
    var paramVal = m[i+1];
    // if the param value matches a pre-replace pair, replace the value before decoding.
    for (j = 0; j < param.replace; j++) {
      if (param.replace[j].from === paramVal) paramVal = param.replace[j].to;
    }
    if (paramVal && param.array === true) paramVal = decodePathArray(paramVal);
    values[paramName] = param.value(paramVal);
  }
  for (/**/; i < nTotal; i++) {
    paramName = paramNames[i];
    values[paramName] = this.params[paramName].value(searchParams[paramName]);
  }

  return values;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#parameters
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Returns the names of all path and search parameters of this pattern in an unspecified order.
 * 
 * @returns {Array.<string>}  An array of parameter names. Must be treated as read-only. If the
 *    pattern has no parameters, an empty array is returned.
 */
UrlMatcher.prototype.parameters = function (param) {
  if (!isDefined(param)) return this.$$paramNames;
  return this.params[param] || null;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#validate
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Checks an object hash of parameters to validate their correctness according to the parameter
 * types of this `UrlMatcher`.
 *
 * @param {Object} params The object hash of parameters to validate.
 * @returns {boolean} Returns `true` if `params` validates, otherwise `false`.
 */
UrlMatcher.prototype.validates = function (params) {
  return this.params.$$validates(params);
};

/**
 * @ngdoc function
 * @name ui.router.util.type:UrlMatcher#format
 * @methodOf ui.router.util.type:UrlMatcher
 *
 * @description
 * Creates a URL that matches this pattern by substituting the specified values
 * for the path and search parameters. Null values for path parameters are
 * treated as empty strings.
 *
 * @example
 * <pre>
 * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });
 * // returns '/user/bob?q=yes'
 * </pre>
 *
 * @param {Object} values  the values to substitute for the parameters in this pattern.
 * @returns {string}  the formatted URL (path and optionally search part).
 */
UrlMatcher.prototype.format = function (values) {
  values = values || {};
  var segments = this.segments, params = this.parameters(), paramset = this.params;
  if (!this.validates(values)) return null;

  var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];

  function encodeDashes(str) { // Replace dashes with encoded "\-"
    return encodeURIComponent(str).replace(/-/g, function(c) { return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase(); });
  }

  for (i = 0; i < nTotal; i++) {
    var isPathParam = i < nPath;
    var name = params[i], param = paramset[name], value = param.value(values[name]);
    var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
    var squash = isDefaultValue ? param.squash : false;
    var encoded = param.type.encode(value);

    if (isPathParam) {
      var nextSegment = segments[i + 1];
      if (squash === false) {
        if (encoded != null) {
          if (isArray(encoded)) {
            result += map(encoded, encodeDashes).join("-");
          } else {
            result += encodeURIComponent(encoded);
          }
        }
        result += nextSegment;
      } else if (squash === true) {
        var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
        result += nextSegment.match(capture)[1];
      } else if (isString(squash)) {
        result += squash + nextSegment;
      }
    } else {
      if (encoded == null || (isDefaultValue && squash !== false)) continue;
      if (!isArray(encoded)) encoded = [ encoded ];
      encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
      result += (search ? '&' : '?') + (name + '=' + encoded);
      search = true;
    }
  }

  return result;
};

/**
 * @ngdoc object
 * @name ui.router.util.type:Type
 *
 * @description
 * Implements an interface to define custom parameter types that can be decoded from and encoded to
 * string parameters matched in a URL. Used by {@link ui.router.util.type:UrlMatcher `UrlMatcher`}
 * objects when matching or formatting URLs, or comparing or validating parameter values.
 *
 * See {@link ui.router.util.$urlMatcherFactory#methods_type `$urlMatcherFactory#type()`} for more
 * information on registering custom types.
 *
 * @param {Object} config  A configuration object which contains the custom type definition.  The object's
 *        properties will override the default methods and/or pattern in `Type`'s public interface.
 * @example
 * <pre>
 * {
 *   decode: function(val) { return parseInt(val, 10); },
 *   encode: function(val) { return val && val.toString(); },
 *   equals: function(a, b) { return this.is(a) && a === b; },
 *   is: function(val) { return angular.isNumber(val) isFinite(val) && val % 1 === 0; },
 *   pattern: /\d+/
 * }
 * </pre>
 *
 * @property {RegExp} pattern The regular expression pattern used to match values of this type when
 *           coming from a substring of a URL.
 *
 * @returns {Object}  Returns a new `Type` object.
 */
function Type(config) {
  extend(this, config);
}

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#is
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Detects whether a value is of a particular type. Accepts a native (decoded) value
 * and determines whether it matches the current `Type` object.
 *
 * @param {*} val  The value to check.
 * @param {string} key  Optional. If the type check is happening in the context of a specific
 *        {@link ui.router.util.type:UrlMatcher `UrlMatcher`} object, this is the name of the
 *        parameter in which `val` is stored. Can be used for meta-programming of `Type` objects.
 * @returns {Boolean}  Returns `true` if the value matches the type, otherwise `false`.
 */
Type.prototype.is = function(val, key) {
  return true;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#encode
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Encodes a custom/native type value to a string that can be embedded in a URL. Note that the
 * return value does *not* need to be URL-safe (i.e. passed through `encodeURIComponent()`), it
 * only needs to be a representation of `val` that has been coerced to a string.
 *
 * @param {*} val  The value to encode.
 * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
 *        meta-programming of `Type` objects.
 * @returns {string}  Returns a string representation of `val` that can be encoded in a URL.
 */
Type.prototype.encode = function(val, key) {
  return val;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#decode
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Converts a parameter value (from URL string or transition param) to a custom/native value.
 *
 * @param {string} val  The URL parameter value to decode.
 * @param {string} key  The name of the parameter in which `val` is stored. Can be used for
 *        meta-programming of `Type` objects.
 * @returns {*}  Returns a custom representation of the URL parameter value.
 */
Type.prototype.decode = function(val, key) {
  return val;
};

/**
 * @ngdoc function
 * @name ui.router.util.type:Type#equals
 * @methodOf ui.router.util.type:Type
 *
 * @description
 * Determines whether two decoded values are equivalent.
 *
 * @param {*} a  A value to compare against.
 * @param {*} b  A value to compare against.
 * @returns {Boolean}  Returns `true` if the values are equivalent/equal, otherwise `false`.
 */
Type.prototype.equals = function(a, b) {
  return a == b;
};

Type.prototype.$subPattern = function() {
  var sub = this.pattern.toString();
  return sub.substr(1, sub.length - 2);
};

Type.prototype.pattern = /.*/;

Type.prototype.toString = function() { return "{Type:" + this.name + "}"; };

/*
 * Wraps an existing custom Type as an array of Type, depending on 'mode'.
 * e.g.:
 * - urlmatcher pattern "/path?{queryParam[]:int}"
 * - url: "/path?queryParam=1&queryParam=2
 * - $stateParams.queryParam will be [1, 2]
 * if `mode` is "auto", then
 * - url: "/path?queryParam=1 will create $stateParams.queryParam: 1
 * - url: "/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]
 */
Type.prototype.$asArray = function(mode, isSearch) {
  if (!mode) return this;
  if (mode === "auto" && !isSearch) throw new Error("'auto' array mode is for query parameters only");
  return new ArrayType(this, mode);

  function ArrayType(type, mode) {
    function bindTo(type, callbackName) {
      return function() {
        return type[callbackName].apply(type, arguments);
      };
    }

    // Wrap non-array value as array
    function arrayWrap(val) { return isArray(val) ? val : (isDefined(val) ? [ val ] : []); }
    // Unwrap array value for "auto" mode. Return undefined for empty array.
    function arrayUnwrap(val) {
      switch(val.length) {
        case 0: return undefined;
        case 1: return mode === "auto" ? val[0] : val;
        default: return val;
      }
    }
    function falsey(val) { return !val; }

    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array
    function arrayHandler(callback, allTruthyMode) {
      return function handleArray(val) {
        val = arrayWrap(val);
        var result = map(val, callback);
        if (allTruthyMode === true)
          return filter(result, falsey).length === 0;
        return arrayUnwrap(result);
      };
    }

    // Wraps type (.equals) functions to operate on each value of an array
    function arrayEqualsHandler(callback) {
      return function handleArray(val1, val2) {
        var left = arrayWrap(val1), right = arrayWrap(val2);
        if (left.length !== right.length) return false;
        for (var i = 0; i < left.length; i++) {
          if (!callback(left[i], right[i])) return false;
        }
        return true;
      };
    }

    this.encode = arrayHandler(bindTo(type, 'encode'));
    this.decode = arrayHandler(bindTo(type, 'decode'));
    this.is     = arrayHandler(bindTo(type, 'is'), true);
    this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
    this.pattern = type.pattern;
    this.$arrayMode = mode;
  }
};



/**
 * @ngdoc object
 * @name ui.router.util.$urlMatcherFactory
 *
 * @description
 * Factory for {@link ui.router.util.type:UrlMatcher `UrlMatcher`} instances. The factory
 * is also available to providers under the name `$urlMatcherFactoryProvider`.
 */
function $UrlMatcherFactory() {
  $$UMFP = this;

  var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;

  function valToString(val) { return val != null ? val.toString().replace(/\//g, "%2F") : val; }
  function valFromString(val) { return val != null ? val.toString().replace(/%2F/g, "/") : val; }
//  TODO: in 1.0, make string .is() return false if value is undefined by default.
//  function regexpMatches(val) { /*jshint validthis:true */ return isDefined(val) && this.pattern.test(val); }
  function regexpMatches(val) { /*jshint validthis:true */ return this.pattern.test(val); }

  var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
    string: {
      encode: valToString,
      decode: valFromString,
      is: regexpMatches,
      pattern: /[^/]*/
    },
    int: {
      encode: valToString,
      decode: function(val) { return parseInt(val, 10); },
      is: function(val) { return isDefined(val) && this.decode(val.toString()) === val; },
      pattern: /\d+/
    },
    bool: {
      encode: function(val) { return val ? 1 : 0; },
      decode: function(val) { return parseInt(val, 10) !== 0; },
      is: function(val) { return val === true || val === false; },
      pattern: /0|1/
    },
    date: {
      encode: function (val) {
        if (!this.is(val))
          return undefined;
        return [ val.getFullYear(),
          ('0' + (val.getMonth() + 1)).slice(-2),
          ('0' + val.getDate()).slice(-2)
        ].join("-");
      },
      decode: function (val) {
        if (this.is(val)) return val;
        var match = this.capture.exec(val);
        return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
      },
      is: function(val) { return val instanceof Date && !isNaN(val.valueOf()); },
      equals: function (a, b) { return this.is(a) && this.is(b) && a.toISOString() === b.toISOString(); },
      pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
      capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
    },
    json: {
      encode: angular.toJson,
      decode: angular.fromJson,
      is: angular.isObject,
      equals: angular.equals,
      pattern: /[^/]*/
    },
    any: { // does not encode/decode
      encode: angular.identity,
      decode: angular.identity,
      is: angular.identity,
      equals: angular.equals,
      pattern: /.*/
    }
  };

  function getDefaultConfig() {
    return {
      strict: isStrictMode,
      caseInsensitive: isCaseInsensitive
    };
  }

  function isInjectable(value) {
    return (isFunction(value) || (isArray(value) && isFunction(value[value.length - 1])));
  }

  /**
   * [Internal] Get the default value of a parameter, which may be an injectable function.
   */
  $UrlMatcherFactory.$$getDefaultValue = function(config) {
    if (!isInjectable(config.value)) return config.value;
    if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
    return injector.invoke(config.value);
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#caseInsensitive
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Defines whether URL matching should be case sensitive (the default behavior), or not.
   *
   * @param {boolean} value `false` to match URL in a case sensitive manner; otherwise `true`;
   * @returns {boolean} the current value of caseInsensitive
   */
  this.caseInsensitive = function(value) {
    if (isDefined(value))
      isCaseInsensitive = value;
    return isCaseInsensitive;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#strictMode
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Defines whether URLs should match trailing slashes, or not (the default behavior).
   *
   * @param {boolean=} value `false` to match trailing slashes in URLs, otherwise `true`.
   * @returns {boolean} the current value of strictMode
   */
  this.strictMode = function(value) {
    if (isDefined(value))
      isStrictMode = value;
    return isStrictMode;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#defaultSquashPolicy
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Sets the default behavior when generating or matching URLs with default parameter values.
   *
   * @param {string} value A string that defines the default parameter URL squashing behavior.
   *    `nosquash`: When generating an href with a default parameter value, do not squash the parameter value from the URL
   *    `slash`: When generating an href with a default parameter value, squash (remove) the parameter value, and, if the
   *             parameter is surrounded by slashes, squash (remove) one slash from the URL
   *    any other string, e.g. "~": When generating an href with a default parameter value, squash (remove)
   *             the parameter value from the URL and replace it with this string.
   */
  this.defaultSquashPolicy = function(value) {
    if (!isDefined(value)) return defaultSquashPolicy;
    if (value !== true && value !== false && !isString(value))
      throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
    defaultSquashPolicy = value;
    return value;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#compile
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Creates a {@link ui.router.util.type:UrlMatcher `UrlMatcher`} for the specified pattern.
   *
   * @param {string} pattern  The URL pattern.
   * @param {Object} config  The config object hash.
   * @returns {UrlMatcher}  The UrlMatcher.
   */
  this.compile = function (pattern, config) {
    return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#isMatcher
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Returns true if the specified object is a `UrlMatcher`, or false otherwise.
   *
   * @param {Object} object  The object to perform the type check against.
   * @returns {Boolean}  Returns `true` if the object matches the `UrlMatcher` interface, by
   *          implementing all the same methods.
   */
  this.isMatcher = function (o) {
    if (!isObject(o)) return false;
    var result = true;

    forEach(UrlMatcher.prototype, function(val, name) {
      if (isFunction(val)) {
        result = result && (isDefined(o[name]) && isFunction(o[name]));
      }
    });
    return result;
  };

  /**
   * @ngdoc function
   * @name ui.router.util.$urlMatcherFactory#type
   * @methodOf ui.router.util.$urlMatcherFactory
   *
   * @description
   * Registers a custom {@link ui.router.util.type:Type `Type`} object that can be used to
   * generate URLs with typed parameters.
   *
   * @param {string} name  The type name.
   * @param {Object|Function} definition   The type definition. See
   *        {@link ui.router.util.type:Type `Type`} for information on the values accepted.
   * @param {Object|Function} definitionFn (optional) A function that is injected before the app
   *        runtime starts.  The result of this function is merged into the existing `definition`.
   *        See {@link ui.router.util.type:Type `Type`} for information on the values accepted.
   *
   * @returns {Object}  Returns `$urlMatcherFactoryProvider`.
   *
   * @example
   * This is a simple example of a custom type that encodes and decodes items from an
   * array, using the array index as the URL-encoded value:
   *
   * <pre>
   * var list = ['John', 'Paul', 'George', 'Ringo'];
   *
   * $urlMatcherFactoryProvider.type('listItem', {
   *   encode: function(item) {
   *     // Represent the list item in the URL using its corresponding index
   *     return list.indexOf(item);
   *   },
   *   decode: function(item) {
   *     // Look up the list item by index
   *     return list[parseInt(item, 10)];
   *   },
   *   is: function(item) {
   *     // Ensure the item is valid by checking to see that it appears
   *     // in the list
   *     return list.indexOf(item) > -1;
   *   }
   * });
   *
   * $stateProvider.state('list', {
   *   url: "/list/{item:listItem}",
   *   controller: function($scope, $stateParams) {
   *     console.log($stateParams.item);
   *   }
   * });
   *
   * // ...
   *
   * // Changes URL to '/list/3', logs "Ringo" to the console
   * $state.go('list', { item: "Ringo" });
   * </pre>
   *
   * This is a more complex example of a type that relies on dependency injection to
   * interact with services, and uses the parameter name from the URL to infer how to
   * handle encoding and decoding parameter values:
   *
   * <pre>
   * // Defines a custom type that gets a value from a service,
   * // where each service gets different types of values from
   * // a backend API:
   * $urlMatcherFactoryProvider.type('dbObject', {}, function(Users, Posts) {
   *
   *   // Matches up services to URL parameter names
   *   var services = {
   *     user: Users,
   *     post: Posts
   *   };
   *
   *   return {
   *     encode: function(object) {
   *       // Represent the object in the URL using its unique ID
   *       return object.id;
   *     },
   *     decode: function(value, key) {
   *       // Look up the object by ID, using the parameter
   *       // name (key) to call the correct service
   *       return services[key].findById(value);
   *     },
   *     is: function(object, key) {
   *       // Check that object is a valid dbObject
   *       return angular.isObject(object) && object.id && services[key];
   *     }
   *     equals: function(a, b) {
   *       // Check the equality of decoded objects by comparing
   *       // their unique IDs
   *       return a.id === b.id;
   *     }
   *   };
   * });
   *
   * // In a config() block, you can then attach URLs with
   * // type-annotated parameters:
   * $stateProvider.state('users', {
   *   url: "/users",
   *   // ...
   * }).state('users.item', {
   *   url: "/{user:dbObject}",
   *   controller: function($scope, $stateParams) {
   *     // $stateParams.user will now be an object returned from
   *     // the Users service
   *   },
   *   // ...
   * });
   * </pre>
   */
  this.type = function (name, definition, definitionFn) {
    if (!isDefined(definition)) return $types[name];
    if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");

    $types[name] = new Type(extend({ name: name }, definition));
    if (definitionFn) {
      typeQueue.push({ name: name, def: definitionFn });
      if (!enqueue) flushTypeQueue();
    }
    return this;
  };

  // `flushTypeQueue()` waits until `$urlMatcherFactory` is injected before invoking the queued `definitionFn`s
  function flushTypeQueue() {
    while(typeQueue.length) {
      var type = typeQueue.shift();
      if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
      angular.extend($types[type.name], injector.invoke(type.def));
    }
  }

  // Register default types. Store them in the prototype of $types.
  forEach(defaultTypes, function(type, name) { $types[name] = new Type(extend({name: name}, type)); });
  $types = inherit($types, {});

  /* No need to document $get, since it returns this */
  this.$get = ['$injector', function ($injector) {
    injector = $injector;
    enqueue = false;
    flushTypeQueue();

    forEach(defaultTypes, function(type, name) {
      if (!$types[name]) $types[name] = new Type(type);
    });
    return this;
  }];

  this.Param = function Param(id, type, config, location) {
    var self = this;
    config = unwrapShorthand(config);
    type = getType(config, type, location);
    var arrayMode = getArrayMode();
    type = arrayMode ? type.$asArray(arrayMode, location === "search") : type;
    if (type.name === "string" && !arrayMode && location === "path" && config.value === undefined)
      config.value = ""; // for 0.2.x; in 0.3.0+ do not automatically default to ""
    var isOptional = config.value !== undefined;
    var squash = getSquashPolicy(config, isOptional);
    var replace = getReplace(config, arrayMode, isOptional, squash);

    function unwrapShorthand(config) {
      var keys = isObject(config) ? objectKeys(config) : [];
      var isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 &&
                        indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
      if (isShorthand) config = { value: config };
      config.$$fn = isInjectable(config.value) ? config.value : function () { return config.value; };
      return config;
    }

    function getType(config, urlType, location) {
      if (config.type && urlType) throw new Error("Param '"+id+"' has two type configurations.");
      if (urlType) return urlType;
      if (!config.type) return (location === "config" ? $types.any : $types.string);
      return config.type instanceof Type ? config.type : new Type(config.type);
    }

    // array config: param name (param[]) overrides default settings.  explicit config overrides param name.
    function getArrayMode() {
      var arrayDefaults = { array: (location === "search" ? "auto" : false) };
      var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
      return extend(arrayDefaults, arrayParamNomenclature, config).array;
    }

    /**
     * returns false, true, or the squash value to indicate the "default parameter url squash policy".
     */
    function getSquashPolicy(config, isOptional) {
      var squash = config.squash;
      if (!isOptional || squash === false) return false;
      if (!isDefined(squash) || squash == null) return defaultSquashPolicy;
      if (squash === true || isString(squash)) return squash;
      throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string");
    }

    function getReplace(config, arrayMode, isOptional, squash) {
      var replace, configuredKeys, defaultPolicy = [
        { from: "",   to: (isOptional || arrayMode ? undefined : "") },
        { from: null, to: (isOptional || arrayMode ? undefined : "") }
      ];
      replace = isArray(config.replace) ? config.replace : [];
      if (isString(squash))
        replace.push({ from: squash, to: undefined });
      configuredKeys = map(replace, function(item) { return item.from; } );
      return filter(defaultPolicy, function(item) { return indexOf(configuredKeys, item.from) === -1; }).concat(replace);
    }

    /**
     * [Internal] Get the default value of a parameter, which may be an injectable function.
     */
    function $$getDefaultValue() {
      if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
      return injector.invoke(config.$$fn);
    }

    /**
     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the
     * default value, which may be the result of an injectable function.
     */
    function $value(value) {
      function hasReplaceVal(val) { return function(obj) { return obj.from === val; }; }
      function $replace(value) {
        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) { return obj.to; });
        return replacement.length ? replacement[0] : value;
      }
      value = $replace(value);
      return isDefined(value) ? self.type.decode(value) : $$getDefaultValue();
    }

    function toString() { return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}"; }

    extend(this, {
      id: id,
      type: type,
      location: location,
      array: arrayMode,
      squash: squash,
      replace: replace,
      isOptional: isOptional,
      value: $value,
      dynamic: undefined,
      config: config,
      toString: toString
    });
  };

  function ParamSet(params) {
    extend(this, params || {});
  }

  ParamSet.prototype = {
    $$new: function() {
      return inherit(this, extend(new ParamSet(), { $$parent: this}));
    },
    $$keys: function () {
      var keys = [], chain = [], parent = this,
        ignore = objectKeys(ParamSet.prototype);
      while (parent) { chain.push(parent); parent = parent.$$parent; }
      chain.reverse();
      forEach(chain, function(paramset) {
        forEach(objectKeys(paramset), function(key) {
            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1) keys.push(key);
        });
      });
      return keys;
    },
    $$values: function(paramValues) {
      var values = {}, self = this;
      forEach(self.$$keys(), function(key) {
        values[key] = self[key].value(paramValues && paramValues[key]);
      });
      return values;
    },
    $$equals: function(paramValues1, paramValues2) {
      var equal = true, self = this;
      forEach(self.$$keys(), function(key) {
        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
        if (!self[key].type.equals(left, right)) equal = false;
      });
      return equal;
    },
    $$validates: function $$validate(paramValues) {
      var result = true, isOptional, val, param, self = this;

      forEach(this.$$keys(), function(key) {
        param = self[key];
        val = paramValues[key];
        isOptional = !val && param.isOptional;
        result = result && (isOptional || !!param.type.is(val));
      });
      return result;
    },
    $$parent: undefined
  };

  this.ParamSet = ParamSet;
}

// Register as a provider so it's available to other providers
angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
angular.module('ui.router.util').run(['$urlMatcherFactory', function($urlMatcherFactory) { }]);

/**
 * @ngdoc object
 * @name ui.router.router.$urlRouterProvider
 *
 * @requires ui.router.util.$urlMatcherFactoryProvider
 * @requires $locationProvider
 *
 * @description
 * `$urlRouterProvider` has the responsibility of watching `$location`. 
 * When `$location` changes it runs through a list of rules one by one until a 
 * match is found. `$urlRouterProvider` is used behind the scenes anytime you specify 
 * a url in a state configuration. All urls are compiled into a UrlMatcher object.
 *
 * There are several methods on `$urlRouterProvider` that make it useful to use directly
 * in your module config.
 */
$UrlRouterProvider.$inject = ['$locationProvider', '$urlMatcherFactoryProvider'];
function $UrlRouterProvider(   $locationProvider,   $urlMatcherFactory) {
  var rules = [], otherwise = null, interceptDeferred = false, listener;

  // Returns a string that is a prefix of all strings matching the RegExp
  function regExpPrefix(re) {
    var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
    return (prefix != null) ? prefix[1].replace(/\\(.)/g, "$1") : '';
  }

  // Interpolates matched values into a String.replace()-style pattern
  function interpolate(pattern, match) {
    return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
      return match[what === '$' ? 0 : Number(what)];
    });
  }

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#rule
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Defines rules that are used by `$urlRouterProvider` to find matches for
   * specific URLs.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   // Here's an example of how you might allow case insensitive urls
   *   $urlRouterProvider.rule(function ($injector, $location) {
   *     var path = $location.path(),
   *         normalized = path.toLowerCase();
   *
   *     if (path !== normalized) {
   *       return normalized;
   *     }
   *   });
   * });
   * </pre>
   *
   * @param {object} rule Handler function that takes `$injector` and `$location`
   * services as arguments. You can use them to return a valid path as a string.
   *
   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
   */
  this.rule = function (rule) {
    if (!isFunction(rule)) throw new Error("'rule' must be a function");
    rules.push(rule);
    return this;
  };

  /**
   * @ngdoc object
   * @name ui.router.router.$urlRouterProvider#otherwise
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Defines a path that is used when an invalid route is requested.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   // if the path doesn't match any of the urls you configured
   *   // otherwise will take care of routing the user to the
   *   // specified url
   *   $urlRouterProvider.otherwise('/index');
   *
   *   // Example of using function rule as param
   *   $urlRouterProvider.otherwise(function ($injector, $location) {
   *     return '/a/valid/url';
   *   });
   * });
   * </pre>
   *
   * @param {string|object} rule The url path you want to redirect to or a function 
   * rule that returns the url path. The function version is passed two params: 
   * `$injector` and `$location` services, and must return a url string.
   *
   * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance
   */
  this.otherwise = function (rule) {
    if (isString(rule)) {
      var redirect = rule;
      rule = function () { return redirect; };
    }
    else if (!isFunction(rule)) throw new Error("'rule' must be a function");
    otherwise = rule;
    return this;
  };


  function handleIfMatch($injector, handler, match) {
    if (!match) return false;
    var result = $injector.invoke(handler, handler, { $match: match });
    return isDefined(result) ? result : true;
  }

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#when
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Registers a handler for a given url matching. if handle is a string, it is
   * treated as a redirect, and is interpolated according to the syntax of match
   * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).
   *
   * If the handler is a function, it is injectable. It gets invoked if `$location`
   * matches. You have the option of inject the match object as `$match`.
   *
   * The handler can return
   *
   * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`
   *   will continue trying to find another one that matches.
   * - **string** which is treated as a redirect and passed to `$location.url()`
   * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {
   *     if ($state.$current.navigable !== state ||
   *         !equalForKeys($match, $stateParams) {
   *      $state.transitionTo(state, $match, false);
   *     }
   *   });
   * });
   * </pre>
   *
   * @param {string|object} what The incoming path that you want to redirect.
   * @param {string|object} handler The path you want to redirect your user to.
   */
  this.when = function (what, handler) {
    var redirect, handlerIsString = isString(handler);
    if (isString(what)) what = $urlMatcherFactory.compile(what);

    if (!handlerIsString && !isFunction(handler) && !isArray(handler))
      throw new Error("invalid 'handler' in when()");

    var strategies = {
      matcher: function (what, handler) {
        if (handlerIsString) {
          redirect = $urlMatcherFactory.compile(handler);
          handler = ['$match', function ($match) { return redirect.format($match); }];
        }
        return extend(function ($injector, $location) {
          return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
        }, {
          prefix: isString(what.prefix) ? what.prefix : ''
        });
      },
      regex: function (what, handler) {
        if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");

        if (handlerIsString) {
          redirect = handler;
          handler = ['$match', function ($match) { return interpolate(redirect, $match); }];
        }
        return extend(function ($injector, $location) {
          return handleIfMatch($injector, handler, what.exec($location.path()));
        }, {
          prefix: regExpPrefix(what)
        });
      }
    };

    var check = { matcher: $urlMatcherFactory.isMatcher(what), regex: what instanceof RegExp };

    for (var n in check) {
      if (check[n]) return this.rule(strategies[n](what, handler));
    }

    throw new Error("invalid 'what' in when()");
  };

  /**
   * @ngdoc function
   * @name ui.router.router.$urlRouterProvider#deferIntercept
   * @methodOf ui.router.router.$urlRouterProvider
   *
   * @description
   * Disables (or enables) deferring location change interception.
   *
   * If you wish to customize the behavior of syncing the URL (for example, if you wish to
   * defer a transition but maintain the current URL), call this method at configuration time.
   * Then, at run time, call `$urlRouter.listen()` after you have configured your own
   * `$locationChangeSuccess` event handler.
   *
   * @example
   * <pre>
   * var app = angular.module('app', ['ui.router.router']);
   *
   * app.config(function ($urlRouterProvider) {
   *
   *   // Prevent $urlRouter from automatically intercepting URL changes;
   *   // this allows you to configure custom behavior in between
   *   // location changes and route synchronization:
   *   $urlRouterProvider.deferIntercept();
   *
   * }).run(function ($rootScope, $urlRouter, UserService) {
   *
   *   $rootScope.$on('$locationChangeSuccess', function(e) {
   *     // UserService is an example service for managing user state
   *     if (UserService.isLoggedIn()) return;
   *
   *     // Prevent $urlRouter's default handler from firing
   *     e.preventDefault();
   *
   *     UserService.handleLogin().then(function() {
   *       // Once the user has logged in, sync the current URL
   *       // to the router:
   *       $urlRouter.sync();
   *     });
   *   });
   *
   *   // Configures $urlRouter's listener *after* your custom listener
   *   $urlRouter.listen();
   * });
   * </pre>
   *
   * @param {boolean} defer Indicates whether to defer location change interception. Passing
            no parameter is equivalent to `true`.
   */
  this.deferIntercept = function (defer) {
    if (defer === undefined) defer = true;
    interceptDeferred = defer;
  };

  /**
   * @ngdoc object
   * @name ui.router.router.$urlRouter
   *
   * @requires $location
   * @requires $rootScope
   * @requires $injector
   * @requires $browser
   *
   * @description
   *
   */
  this.$get = $get;
  $get.$inject = ['$location', '$rootScope', '$injector', '$browser'];
  function $get(   $location,   $rootScope,   $injector,   $browser) {

    var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;

    function appendBasePath(url, isHtml5, absolute) {
      if (baseHref === '/') return url;
      if (isHtml5) return baseHref.slice(0, -1) + url;
      if (absolute) return baseHref.slice(1) + url;
      return url;
    }

    // TODO: Optimize groups of rules with non-empty prefix into some sort of decision tree
    function update(evt) {
      if (evt && evt.defaultPrevented) return;
      var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
      lastPushedUrl = undefined;
      if (ignoreUpdate) return true;

      function check(rule) {
        var handled = rule($injector, $location);

        if (!handled) return false;
        if (isString(handled)) $location.replace().url(handled);
        return true;
      }
      var n = rules.length, i;

      for (i = 0; i < n; i++) {
        if (check(rules[i])) return;
      }
      // always check otherwise last to allow dynamic updates to the set of rules
      if (otherwise) check(otherwise);
    }

    function listen() {
      listener = listener || $rootScope.$on('$locationChangeSuccess', update);
      return listener;
    }

    if (!interceptDeferred) listen();

    return {
      /**
       * @ngdoc function
       * @name ui.router.router.$urlRouter#sync
       * @methodOf ui.router.router.$urlRouter
       *
       * @description
       * Triggers an update; the same update that happens when the address bar url changes, aka `$locationChangeSuccess`.
       * This method is useful when you need to use `preventDefault()` on the `$locationChangeSuccess` event,
       * perform some custom logic (route protection, auth, config, redirection, etc) and then finally proceed
       * with the transition by calling `$urlRouter.sync()`.
       *
       * @example
       * <pre>
       * angular.module('app', ['ui.router'])
       *   .run(function($rootScope, $urlRouter) {
       *     $rootScope.$on('$locationChangeSuccess', function(evt) {
       *       // Halt state change from even starting
       *       evt.preventDefault();
       *       // Perform custom logic
       *       var meetsRequirement = ...
       *       // Continue with the update and state transition if logic allows
       *       if (meetsRequirement) $urlRouter.sync();
       *     });
       * });
       * </pre>
       */
      sync: function() {
        update();
      },

      listen: function() {
        return listen();
      },

      update: function(read) {
        if (read) {
          location = $location.url();
          return;
        }
        if ($location.url() === location) return;

        $location.url(location);
        $location.replace();
      },

      push: function(urlMatcher, params, options) {
        $location.url(urlMatcher.format(params || {}));
        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
        if (options && options.replace) $location.replace();
      },

      /**
       * @ngdoc function
       * @name ui.router.router.$urlRouter#href
       * @methodOf ui.router.router.$urlRouter
       *
       * @description
       * A URL generation method that returns the compiled URL for a given
       * {@link ui.router.util.type:UrlMatcher `UrlMatcher`}, populated with the provided parameters.
       *
       * @example
       * <pre>
       * $bob = $urlRouter.href(new UrlMatcher("/about/:person"), {
       *   person: "bob"
       * });
       * // $bob == "/about/bob";
       * </pre>
       *
       * @param {UrlMatcher} urlMatcher The `UrlMatcher` object which is used as the template of the URL to generate.
       * @param {object=} params An object of parameter values to fill the matcher's required parameters.
       * @param {object=} options Options object. The options are:
       *
       * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
       *
       * @returns {string} Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`
       */
      href: function(urlMatcher, params, options) {
        if (!urlMatcher.validates(params)) return null;

        var isHtml5 = $locationProvider.html5Mode();
        if (angular.isObject(isHtml5)) {
          isHtml5 = isHtml5.enabled;
        }
        
        var url = urlMatcher.format(params);
        options = options || {};

        if (!isHtml5 && url !== null) {
          url = "#" + $locationProvider.hashPrefix() + url;
        }
        url = appendBasePath(url, isHtml5, options.absolute);

        if (!options.absolute || !url) {
          return url;
        }

        var slash = (!isHtml5 && url ? '/' : ''), port = $location.port();
        port = (port === 80 || port === 443 ? '' : ':' + port);

        return [$location.protocol(), '://', $location.host(), port, slash, url].join('');
      }
    };
  }
}

angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);

/**
 * @ngdoc object
 * @name ui.router.state.$stateProvider
 *
 * @requires ui.router.router.$urlRouterProvider
 * @requires ui.router.util.$urlMatcherFactoryProvider
 *
 * @description
 * The new `$stateProvider` works similar to Angular's v1 router, but it focuses purely
 * on state.
 *
 * A state corresponds to a "place" in the application in terms of the overall UI and
 * navigation. A state describes (via the controller / template / view properties) what
 * the UI looks like and does at that place.
 *
 * States often have things in common, and the primary way of factoring out these
 * commonalities in this model is via the state hierarchy, i.e. parent/child states aka
 * nested states.
 *
 * The `$stateProvider` provides interfaces to declare these states for your app.
 */
$StateProvider.$inject = ['$urlRouterProvider', '$urlMatcherFactoryProvider'];
function $StateProvider(   $urlRouterProvider,   $urlMatcherFactory) {

  var root, states = {}, $state, queue = {}, abstractKey = 'abstract';

  // Builds state properties from definition passed to registerState()
  var stateBuilder = {

    // Derive parent state from a hierarchical name only if 'parent' is not explicitly defined.
    // state.children = [];
    // if (parent) parent.children.push(state);
    parent: function(state) {
      if (isDefined(state.parent) && state.parent) return findState(state.parent);
      // regex matches any valid composite state name
      // would match "contact.list" but not "contacts"
      var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
      return compositeName ? findState(compositeName[1]) : root;
    },

    // inherit 'data' from parent and override by own values (if any)
    data: function(state) {
      if (state.parent && state.parent.data) {
        state.data = state.self.data = extend({}, state.parent.data, state.data);
      }
      return state.data;
    },

    // Build a URLMatcher if necessary, either via a relative or absolute URL
    url: function(state) {
      var url = state.url, config = { params: state.params || {} };

      if (isString(url)) {
        if (url.charAt(0) == '^') return $urlMatcherFactory.compile(url.substring(1), config);
        return (state.parent.navigable || root).url.concat(url, config);
      }

      if (!url || $urlMatcherFactory.isMatcher(url)) return url;
      throw new Error("Invalid url '" + url + "' in state '" + state + "'");
    },

    // Keep track of the closest ancestor state that has a URL (i.e. is navigable)
    navigable: function(state) {
      return state.url ? state : (state.parent ? state.parent.navigable : null);
    },

    // Own parameters for this state. state.url.params is already built at this point. Create and add non-url params
    ownParams: function(state) {
      var params = state.url && state.url.params || new $$UMFP.ParamSet();
      forEach(state.params || {}, function(config, id) {
        if (!params[id]) params[id] = new $$UMFP.Param(id, null, config, "config");
      });
      return params;
    },

    // Derive parameters for this state and ensure they're a super-set of parent's parameters
    params: function(state) {
      return state.parent && state.parent.params ? extend(state.parent.params.$$new(), state.ownParams) : new $$UMFP.ParamSet();
    },

    // If there is no explicit multi-view configuration, make one up so we don't have
    // to handle both cases in the view directive later. Note that having an explicit
    // 'views' property will mean the default unnamed view properties are ignored. This
    // is also a good time to resolve view names to absolute names, so everything is a
    // straight lookup at link time.
    views: function(state) {
      var views = {};

      forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
        if (name.indexOf('@') < 0) name += '@' + state.parent.name;
        views[name] = view;
      });
      return views;
    },

    // Keep a full path from the root down to this state as this is needed for state activation.
    path: function(state) {
      return state.parent ? state.parent.path.concat(state) : []; // exclude root from path
    },

    // Speed up $state.contains() as it's used a lot
    includes: function(state) {
      var includes = state.parent ? extend({}, state.parent.includes) : {};
      includes[state.name] = true;
      return includes;
    },

    $delegates: {}
  };

  function isRelative(stateName) {
    return stateName.indexOf(".") === 0 || stateName.indexOf("^") === 0;
  }

  function findState(stateOrName, base) {
    if (!stateOrName) return undefined;

    var isStr = isString(stateOrName),
        name  = isStr ? stateOrName : stateOrName.name,
        path  = isRelative(name);

    if (path) {
      if (!base) throw new Error("No reference point given for path '"  + name + "'");
      base = findState(base);
      
      var rel = name.split("."), i = 0, pathLength = rel.length, current = base;

      for (; i < pathLength; i++) {
        if (rel[i] === "" && i === 0) {
          current = base;
          continue;
        }
        if (rel[i] === "^") {
          if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
          current = current.parent;
          continue;
        }
        break;
      }
      rel = rel.slice(i).join(".");
      name = current.name + (current.name && rel ? "." : "") + rel;
    }
    var state = states[name];

    if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {
      return state;
    }
    return undefined;
  }

  function queueState(parentName, state) {
    if (!queue[parentName]) {
      queue[parentName] = [];
    }
    queue[parentName].push(state);
  }

  function flushQueuedChildren(parentName) {
    var queued = queue[parentName] || [];
    while(queued.length) {
      registerState(queued.shift());
    }
  }

  function registerState(state) {
    // Wrap a new object around the state so we can store our private details easily.
    state = inherit(state, {
      self: state,
      resolve: state.resolve || {},
      toString: function() { return this.name; }
    });

    var name = state.name;
    if (!isString(name) || name.indexOf('@') >= 0) throw new Error("State must have a valid name");
    if (states.hasOwnProperty(name)) throw new Error("State '" + name + "'' is already defined");

    // Get parent name
    var parentName = (name.indexOf('.') !== -1) ? name.substring(0, name.lastIndexOf('.'))
        : (isString(state.parent)) ? state.parent
        : (isObject(state.parent) && isString(state.parent.name)) ? state.parent.name
        : '';

    // If parent is not registered yet, add state to queue and register later
    if (parentName && !states[parentName]) {
      return queueState(parentName, state.self);
    }

    for (var key in stateBuilder) {
      if (isFunction(stateBuilder[key])) state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
    }
    states[name] = state;

    // Register the state in the global state list and with $urlRouter if necessary.
    if (!state[abstractKey] && state.url) {
      $urlRouterProvider.when(state.url, ['$match', '$stateParams', function ($match, $stateParams) {
        if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
          $state.transitionTo(state, $match, { inherit: true, location: false });
        }
      }]);
    }

    // Register any queued children
    flushQueuedChildren(name);

    return state;
  }

  // Checks text to see if it looks like a glob.
  function isGlob (text) {
    return text.indexOf('*') > -1;
  }

  // Returns true if glob matches current $state name.
  function doesStateMatchGlob (glob) {
    var globSegments = glob.split('.'),
        segments = $state.$current.name.split('.');

    //match greedy starts
    if (globSegments[0] === '**') {
       segments = segments.slice(indexOf(segments, globSegments[1]));
       segments.unshift('**');
    }
    //match greedy ends
    if (globSegments[globSegments.length - 1] === '**') {
       segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
       segments.push('**');
    }

    if (globSegments.length != segments.length) {
      return false;
    }

    //match single stars
    for (var i = 0, l = globSegments.length; i < l; i++) {
      if (globSegments[i] === '*') {
        segments[i] = '*';
      }
    }

    return segments.join('') === globSegments.join('');
  }


  // Implicit root state that is always active
  root = registerState({
    name: '',
    url: '^',
    views: null,
    'abstract': true
  });
  root.navigable = null;


  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#decorator
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Allows you to extend (carefully) or override (at your own peril) the 
   * `stateBuilder` object used internally by `$stateProvider`. This can be used 
   * to add custom functionality to ui-router, for example inferring templateUrl 
   * based on the state name.
   *
   * When passing only a name, it returns the current (original or decorated) builder
   * function that matches `name`.
   *
   * The builder functions that can be decorated are listed below. Though not all
   * necessarily have a good use case for decoration, that is up to you to decide.
   *
   * In addition, users can attach custom decorators, which will generate new 
   * properties within the state's internal definition. There is currently no clear 
   * use-case for this beyond accessing internal states (i.e. $state.$current), 
   * however, expect this to become increasingly relevant as we introduce additional 
   * meta-programming features.
   *
   * **Warning**: Decorators should not be interdependent because the order of 
   * execution of the builder functions in non-deterministic. Builder functions 
   * should only be dependent on the state definition object and super function.
   *
   *
   * Existing builder functions and current return values:
   *
   * - **parent** `{object}` - returns the parent state object.
   * - **data** `{object}` - returns state data, including any inherited data that is not
   *   overridden by own values (if any).
   * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}
   *   or `null`.
   * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is 
   *   navigable).
   * - **params** `{object}` - returns an array of state params that are ensured to 
   *   be a super-set of parent's params.
   * - **views** `{object}` - returns a views object where each key is an absolute view 
   *   name (i.e. "viewName@stateName") and each value is the config object 
   *   (template, controller) for the view. Even when you don't use the views object 
   *   explicitly on a state config, one is still created for you internally.
   *   So by decorating this builder function you have access to decorating template 
   *   and controller properties.
   * - **ownParams** `{object}` - returns an array of params that belong to the state, 
   *   not including any params defined by ancestor states.
   * - **path** `{string}` - returns the full path from the root down to this state. 
   *   Needed for state activation.
   * - **includes** `{object}` - returns an object that includes every state that 
   *   would pass a `$state.includes()` test.
   *
   * @example
   * <pre>
   * // Override the internal 'views' builder with a function that takes the state
   * // definition, and a reference to the internal function being overridden:
   * $stateProvider.decorator('views', function (state, parent) {
   *   var result = {},
   *       views = parent(state);
   *
   *   angular.forEach(views, function (config, name) {
   *     var autoName = (state.name + '.' + name).replace('.', '/');
   *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';
   *     result[name] = config;
   *   });
   *   return result;
   * });
   *
   * $stateProvider.state('home', {
   *   views: {
   *     'contact.list': { controller: 'ListController' },
   *     'contact.item': { controller: 'ItemController' }
   *   }
   * });
   *
   * // ...
   *
   * $state.go('home');
   * // Auto-populates list and item views with /partials/home/contact/list.html,
   * // and /partials/home/contact/item.html, respectively.
   * </pre>
   *
   * @param {string} name The name of the builder function to decorate. 
   * @param {object} func A function that is responsible for decorating the original 
   * builder function. The function receives two parameters:
   *
   *   - `{object}` - state - The state config object.
   *   - `{object}` - super - The original builder function.
   *
   * @return {object} $stateProvider - $stateProvider instance
   */
  this.decorator = decorator;
  function decorator(name, func) {
    /*jshint validthis: true */
    if (isString(name) && !isDefined(func)) {
      return stateBuilder[name];
    }
    if (!isFunction(func) || !isString(name)) {
      return this;
    }
    if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
      stateBuilder.$delegates[name] = stateBuilder[name];
    }
    stateBuilder[name] = func;
    return this;
  }

  /**
   * @ngdoc function
   * @name ui.router.state.$stateProvider#state
   * @methodOf ui.router.state.$stateProvider
   *
   * @description
   * Registers a state configuration under a given state name. The stateConfig object
   * has the following acceptable properties.
   *
   * @param {string} name A unique state name, e.g. "home", "about", "contacts".
   * To create a parent/child state use a dot, e.g. "about.sales", "home.newest".
   * @param {object} stateConfig State configuration object.
   * @param {string|function=} stateConfig.template
   * <a id='template'></a>
   *   html template as a string or a function that returns
   *   an html template as a string which should be used by the uiView directives. This property 
   *   takes precedence over templateUrl.
   *   
   *   If `template` is a function, it will be called with the following parameters:
   *
   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by
   *     applying the current state
   *
   * <pre>template:
   *   "<h1>inline template definition</h1>" +
   *   "<div ui-view></div>"</pre>
   * <pre>template: function(params) {
   *       return "<h1>generated template</h1>"; }</pre>
   * </div>
   *
   * @param {string|function=} stateConfig.templateUrl
   * <a id='templateUrl'></a>
   *
   *   path or function that returns a path to an html
   *   template that should be used by uiView.
   *   
   *   If `templateUrl` is a function, it will be called with the following parameters:
   *
   *   - {array.&lt;object&gt;} - state parameters extracted from the current $location.path() by 
   *     applying the current state
   *
   * <pre>templateUrl: "home.html"</pre>
   * <pre>templateUrl: function(params) {
   *     return myTemplates[params.pageId]; }</pre>
   *
   * @param {function=} stateConfig.templateProvider
   * <a id='templateProvider'></a>
   *    Provider function that returns HTML content string.
   * <pre> templateProvider:
   *       function(MyTemplateService, params) {
   *         return MyTemplateService.getTemplate(params.pageId);
   *       }</pre>
   *
   * @param {string|function=} stateConfig.controller
   * <a id='controller'></a>
   *
   *  Controller fn that should be associated with newly
   *   related scope or the name of a registered controller if passed as a string.
   *   Optionally, the ControllerAs may be declared here.
   * <pre>controller: "MyRegisteredController"</pre>
   * <pre>controller:
   *     "MyRegisteredController as fooCtrl"}</pre>
   * <pre>controller: function($scope, MyService) {
   *     $scope.data = MyService.getData(); }</pre>
   *
   * @param {function=} stateConfig.controllerProvider
   * <a id='controllerProvider'></a>
   *
   * Injectable provider function that returns the actual controller or string.
   * <pre>controllerProvider:
   *   function(MyResolveData) {
   *     if (MyResolveData.foo)
   *       return "FooCtrl"
   *     else if (MyResolveData.bar)
   *       return "BarCtrl";
   *     else return function($scope) {
   *       $scope.baz = "Qux";
   *     }
   *   }</pre>
   *
   * @param {string=} stateConfig.controllerAs
   * <a id='controllerAs'></a>
   * 
   * A controller alias name. If present the controller will be
   *   published to scope under the controllerAs name.
   * <pre>controllerAs: "myCtrl"</pre>
   *
   * @param {object=} stateConfig.resolve
   * <a id='resolve'></a>
   *
   * An optional map&lt;string, function&gt; of dependencies which
   *   should be injected into the controller. If any of these dependencies are promises, 
   *   the router will wait for them all to be resolved before the controller is instantiated.
   *   If all the promises are resolved successfully, the $stateChangeSuccess event is fired
   *   and the values of the resolved promises are injected into any controllers that reference them.
   *   If any  of the promises are rejected the $stateChangeError event is fired.
   *
   *   The map object is:
   *   
   *   - key - {string}: name of dependency to be injected into controller
   *   - factory - {string|function}: If string then it is alias for service. Otherwise if function, 
   *     it is injected and return value it treated as dependency. If result is a promise, it is 
   *     resolved before its value is injected into controller.
   *
   * <pre>resolve: {
   *     myResolve1:
   *       function($http, $stateParams) {
   *         return $http.get("/api/foos/"+stateParams.fooID);
   *       }
   *     }</pre>
   *
   * @param {string=} stateConfig.url
   * <a id='url'></a>
   *
   *   A url fragment with optional parameters. When a state is navigated or
   *   transitioned to, the `$stateParams` service will be populated with any 
   *   parameters that were passed.
   *
   * examples:
   * <pre>url: "/home"
   * url: "/users/:userid"
   * url: "/books/{bookid:[a-zA-Z_-]}"
   * url: "/books/{categoryid:int}"
   * url: "/books/{publishername:string}/{categoryid:int}"
   * url: "/messages?before&after"
   * url: "/messages?{before:date}&{after:date}"</pre>
   * url: "/messages/:mailboxid?{before:date}&{after:date}"
   *
   * @param {object=} stateConfig.views
   * <a id='views'></a>
   * an optional map&lt;string, object&gt; which defined multiple views, or targets views
   * manually/explicitly.
   *
   * Examples:
   *
   * Targets three named `ui-view`s in the parent state's template
   * <pre>views: {
   *     header: {
   *       controller: "headerCtrl",
   *       templateUrl: "header.html"
   *     }, body: {
   *       controller: "bodyCtrl",
   *       templateUrl: "body.html"
   *     }, footer: {
   *       controller: "footCtrl",
   *       templateUrl: "footer.html"
   *     }
   *   }</pre>
   *
   * Targets named `ui-view="header"` from grandparent state 'top''s template, and named `ui-view="body" from parent state's template.
   * <pre>views: {
   *     'header@top': {
   *       controller: "msgHeaderCtrl",
   *       templateUrl: "msgHeader.html"
   *     }, 'body': {
   *       controller: "messagesCtrl",
   *       templateUrl: "messages.html"
   *     }
   *   }</pre>
   *
   * @param {boolean=} [stateConfig.abstract=false]
   * <a id='abstract'></a>
   * An abstract state will never be directly activated,
   *   but can provide inherited properties to its common children states.
   * <pre>abstract: true</pre>
   *
   * @param {function=} stateConfig.onEnter
   * <a id='onEnter'></a>
   *
   * Callback function for when a state is entered. Good way
   *   to trigger an action or dispatch an event, such as opening a dialog.
   * If minifying your scripts, make sure to explictly annotate this function,
   * because it won't be automatically annotated by your build tools.
   *
   * <pre>onEnter: function(MyService, $stateParams) {
   *     MyService.foo($stateParams.myParam);
   * }</pre>
   *
   * @param {function=} stateConfig.onExit
   * <a id='onExit'></a>
   *
   * Callback function for when a state is exited. Good way to
   *   trigger an action or dispatch an event, such as opening a dialog.
   * If minifying your scripts, make sure to explictly annotate this function,
   * because it won't be automatically annotated by your build tools.
   *
   * <pre>onExit: function(MyService, $stateParams) {
   *     MyService.cleanup($stateParams.myParam);
   * }</pre>
   *
   * @param {boolean=} [stateConfig.reloadOnSearch=true]
   * <a id='reloadOnSearch'></a>
   *
   * If `false`, will not retrigger the same state
   *   just because a search/query parameter has changed (via $location.search() or $location.hash()). 
   *   Useful for when you'd like to modify $location.search() without triggering a reload.
   * <pre>reloadOnSearch: false</pre>
   *
   * @param {object=} stateConfig.data
   * <a id='data'></a>
   *
   * Arbitrary data object, useful for custom configuration.  The parent state's `data` is
   *   prototypally inherited.  In other words, adding a data property to a state adds it to
   *   the entire subtree via prototypal inheritance.
   *
   * <pre>data: {
   *     requiredRole: 'foo'
   * } </pre>
   *
   * @param {object=} stateConfig.params
   * <a id='params'></a>
   *
   * A map which optionally configures parameters declared in the `url`, or
   *   defines additional non-url parameters.  For each parameter being
   *   configured, add a configuration object keyed to the name of the parameter.
   *
   *   Each parameter configuration object may contain the following properties:
   *
   *   - ** value ** - {object|function=}: specifies the default value for this
   *     parameter.  This implicitly sets this parameter as optional.
   *
   *     When UI-Router routes to a state and no value is
   *     specified for this parameter in the URL or transition, the
   *     default value will be used instead.  If `value` is a function,
   *     it will be injected and invoked, and the return value used.
   *
   *     *Note*: `undefined` is treated as "no default value" while `null`
   *     is treated as "the default value is `null`".
   *
   *     *Shorthand*: If you only need to configure the default value of the
   *     parameter, you may use a shorthand syntax.   In the **`params`**
   *     map, instead mapping the param name to a full parameter configuration
   *     object, simply set map it to the default parameter value, e.g.:
   *
   * <pre>// define a parameter's default value
   * params: {
   *     param1: { value: "defaultValue" }
   * }
   * // shorthand default values
   * params: {
   *     param1: "defaultValue",
   *     param2: "param2Default"
   * }</pre>
   *
   *   - ** array ** - {boolean=}: *(default: false)* If true, the param value will be
   *     treated as an array of values.  If you specified a Type, the value will be
   *     treated as an array of the specified Type.  Note: query parameter values
   *     default to a special `"auto"` mode.
   *
   *     For query parameters in `"auto"` mode, if multiple  values for a single parameter
   *     are present in the URL (e.g.: `/foo?bar=1&bar=2&bar=3`) then the values
   *     are mapped to an array (e.g.: `{ foo: [ '1', '2', '3' ] }`).  However, if
   *     only one value is present (e.g.: `/foo?bar=1`) then the value is treated as single
   *     value (e.g.: `{ foo: '1' }`).
   *
   * <pre>params: {
   *     param1: { array: true }
   * }</pre>
   *
   *   - ** squash ** - {bool|string=}: `squash` configures how a default parameter value is represented in the URL when
   *     the current parameter value is the same as the default value. If `squash` is not set, it uses the
   *     configured default squash policy.
   *     (See {@link ui.router.util.$urlMatcherFactory#methods_defaultSquashPolicy `defaultSquashPolicy()`})
   *
   *   There are three squash settings:
   *
   *     - false: The parameter's default value is not squashed.  It is encoded and included in the URL
   *     - true: The parameter's default value is omitted from the URL.  If the parameter is preceeded and followed
   *       by slashes in the state's `url` declaration, then one of those slashes are omitted.
   *       This can allow for cleaner looking URLs.
   *     - `"<arbitrary string>"`: The parameter's default value is replaced with an arbitrary placeholder of  your choice.
   *
   * <pre>params: {
   *     param1: {
   *       value: "defaultId",
   *       squash: true
   * } }
   * // squash "defaultValue" to "~"
   * params: {
   *     param1: {
   *       value: "defaultValue",
   *       squash: "~"
   * } }
   * </pre>
   *
   *
   * @example
   * <pre>
   * // Some state name examples
   *
   * // stateName can be a single top-level name (must be unique).
   * $stateProvider.state("home", {});
   *
   * // Or it can be a nested state name. This state is a child of the
   * // above "home" state.
   * $stateProvider.state("home.newest", {});
   *
   * // Nest states as deeply as needed.
   * $stateProvider.state("home.newest.abc.xyz.inception", {});
   *
   * // state() returns $stateProvider, so you can chain state declarations.
   * $stateProvider
   *   .state("home", {})
   *   .state("about", {})
   *   .state("contacts", {});
   * </pre>
   *
   */
  this.state = state;
  function state(name, definition) {
    /*jshint validthis: true */
    if (isObject(name)) definition = name;
    else definition.name = name;
    registerState(definition);
    return this;
  }

  /**
   * @ngdoc object
   * @name ui.router.state.$state
   *
   * @requires $rootScope
   * @requires $q
   * @requires ui.router.state.$view
   * @requires $injector
   * @requires ui.router.util.$resolve
   * @requires ui.router.state.$stateParams
   * @requires ui.router.router.$urlRouter
   *
   * @property {object} params A param object, e.g. {sectionId: section.id)}, that 
   * you'd like to test against the current active state.
   * @property {object} current A reference to the state's config object. However 
   * you passed it in. Useful for accessing custom data.
   * @property {object} transition Currently pending transition. A promise that'll 
   * resolve or reject.
   *
   * @description
   * `$state` service is responsible for representing states as well as transitioning
   * between them. It also provides interfaces to ask for current state or even states
   * you're coming from.
   */
  this.$get = $get;
  $get.$inject = ['$rootScope', '$q', '$view', '$injector', '$resolve', '$stateParams', '$urlRouter', '$location', '$urlMatcherFactory'];
  function $get(   $rootScope,   $q,   $view,   $injector,   $resolve,   $stateParams,   $urlRouter,   $location,   $urlMatcherFactory) {

    var TransitionSuperseded = $q.reject(new Error('transition superseded'));
    var TransitionPrevented = $q.reject(new Error('transition prevented'));
    var TransitionAborted = $q.reject(new Error('transition aborted'));
    var TransitionFailed = $q.reject(new Error('transition failed'));

    // Handles the case where a state which is the target of a transition is not found, and the user
    // can optionally retry or defer the transition
    function handleRedirect(redirect, state, params, options) {
      /**
       * @ngdoc event
       * @name ui.router.state.$state#$stateNotFound
       * @eventOf ui.router.state.$state
       * @eventType broadcast on root scope
       * @description
       * Fired when a requested state **cannot be found** using the provided state name during transition.
       * The event is broadcast allowing any handlers a single chance to deal with the error (usually by
       * lazy-loading the unfound state). A special `unfoundState` object is passed to the listener handler,
       * you can see its three properties in the example. You can use `event.preventDefault()` to abort the
       * transition and the promise returned from `go` will be rejected with a `'transition aborted'` value.
       *
       * @param {Object} event Event object.
       * @param {Object} unfoundState Unfound State information. Contains: `to, toParams, options` properties.
       * @param {State} fromState Current state object.
       * @param {Object} fromParams Current state params.
       *
       * @example
       *
       * <pre>
       * // somewhere, assume lazy.state has not been defined
       * $state.go("lazy.state", {a:1, b:2}, {inherit:false});
       *
       * // somewhere else
       * $scope.$on('$stateNotFound',
       * function(event, unfoundState, fromState, fromParams){
       *     console.log(unfoundState.to); // "lazy.state"
       *     console.log(unfoundState.toParams); // {a:1, b:2}
       *     console.log(unfoundState.options); // {inherit:false} + default options
       * })
       * </pre>
       */
      var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);

      if (evt.defaultPrevented) {
        $urlRouter.update();
        return TransitionAborted;
      }

      if (!evt.retry) {
        return null;
      }

      // Allow the handler to return a promise to defer state lookup retry
      if (options.$retry) {
        $urlRouter.update();
        return TransitionFailed;
      }
      var retryTransition = $state.transition = $q.when(evt.retry);

      retryTransition.then(function() {
        if (retryTransition !== $state.transition) return TransitionSuperseded;
        redirect.options.$retry = true;
        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
      }, function() {
        return TransitionAborted;
      });
      $urlRouter.update();

      return retryTransition;
    }

    root.locals = { resolve: null, globals: { $stateParams: {} } };

    $state = {
      params: {},
      current: root.self,
      $current: root,
      transition: null
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#reload
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method that force reloads the current state. All resolves are re-resolved, events are not re-fired, 
     * and controllers reinstantiated (bug with controllers reinstantiating right now, fixing soon).
     *
     * @example
     * <pre>
     * var app angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.reload = function(){
     *     $state.reload();
     *   }
     * });
     * </pre>
     *
     * `reload()` is just an alias for:
     * <pre>
     * $state.transitionTo($state.current, $stateParams, { 
     *   reload: true, inherit: false, notify: true
     * });
     * </pre>
     *
     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.reload = function reload() {
      return $state.transitionTo($state.current, $stateParams, { reload: true, inherit: false, notify: true });
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#go
     * @methodOf ui.router.state.$state
     *
     * @description
     * Convenience method for transitioning to a new state. `$state.go` calls 
     * `$state.transitionTo` internally but automatically sets options to 
     * `{ location: true, inherit: true, relative: $state.$current, notify: true }`. 
     * This allows you to easily use an absolute or relative to path and specify 
     * only the parameters you'd like to update (while letting unspecified parameters 
     * inherit from the currently active ancestor states).
     *
     * @example
     * <pre>
     * var app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.go('contact.detail');
     *   };
     * });
     * </pre>
     * <img src='../ngdoc_assets/StateGoExamples.png'/>
     *
     * @param {string} to Absolute state name or relative state path. Some examples:
     *
     * - `$state.go('contact.detail')` - will go to the `contact.detail` state
     * - `$state.go('^')` - will go to a parent state
     * - `$state.go('^.sibling')` - will go to a sibling state
     * - `$state.go('.child.grandchild')` - will go to grandchild state
     *
     * @param {object=} params A map of the parameters that will be sent to the state, 
     * will populate $stateParams. Any parameters that are not specified will be inherited from currently 
     * defined parameters. This allows, for example, going to a sibling state that shares parameters
     * specified in a parent state. Parameter inheritance only works between common ancestor states, I.e.
     * transitioning to a sibling will get you the parameters for all parents, transitioning to a child
     * will get you all current parameters, etc.
     * @param {object=} options Options object. The options are:
     *
     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params 
     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
     *    use this when you want to force a reload when *everything* is the same, including search params.
     *
     * @returns {promise} A promise representing the state of the new transition.
     *
     * Possible success values:
     *
     * - $state.current
     *
     * <br/>Possible rejection values:
     *
     * - 'transition superseded' - when a newer transition has been started after this one
     * - 'transition prevented' - when `event.preventDefault()` has been called in a `$stateChangeStart` listener
     * - 'transition aborted' - when `event.preventDefault()` has been called in a `$stateNotFound` listener or
     *   when a `$stateNotFound` `event.retry` promise errors.
     * - 'transition failed' - when a state has been unsuccessfully found after 2 tries.
     * - *resolve error* - when an error has occurred with a `resolve`
     *
     */
    $state.go = function go(to, params, options) {
      return $state.transitionTo(to, params, extend({ inherit: true, relative: $state.$current }, options));
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#transitionTo
     * @methodOf ui.router.state.$state
     *
     * @description
     * Low-level method for transitioning to a new state. {@link ui.router.state.$state#methods_go $state.go}
     * uses `transitionTo` internally. `$state.go` is recommended in most situations.
     *
     * @example
     * <pre>
     * var app = angular.module('app', ['ui.router']);
     *
     * app.controller('ctrl', function ($scope, $state) {
     *   $scope.changeState = function () {
     *     $state.transitionTo('contact.detail');
     *   };
     * });
     * </pre>
     *
     * @param {string} to State name.
     * @param {object=} toParams A map of the parameters that will be sent to the state,
     * will populate $stateParams.
     * @param {object=} options Options object. The options are:
     *
     * - **`location`** - {boolean=true|string=} - If `true` will update the url in the location bar, if `false`
     *    will not. If string, must be `"replace"`, which will update url and also replace last history record.
     * - **`inherit`** - {boolean=false}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`notify`** - {boolean=true}, If `true` will broadcast $stateChangeStart and $stateChangeSuccess events.
     * - **`reload`** (v0.2.5) - {boolean=false}, If `true` will force transition even if the state or params 
     *    have not changed, aka a reload of the same state. It differs from reloadOnSearch because you'd
     *    use this when you want to force a reload when *everything* is the same, including search params.
     *
     * @returns {promise} A promise representing the state of the new transition. See
     * {@link ui.router.state.$state#methods_go $state.go}.
     */
    $state.transitionTo = function transitionTo(to, toParams, options) {
      toParams = toParams || {};
      options = extend({
        location: true, inherit: false, relative: null, notify: true, reload: false, $retry: false
      }, options || {});

      var from = $state.$current, fromParams = $state.params, fromPath = from.path;
      var evt, toState = findState(to, options.relative);

      if (!isDefined(toState)) {
        var redirect = { to: to, toParams: toParams, options: options };
        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);

        if (redirectResult) {
          return redirectResult;
        }

        // Always retry once if the $stateNotFound was not prevented
        // (handles either redirect changed or state lazy-definition)
        to = redirect.to;
        toParams = redirect.toParams;
        options = redirect.options;
        toState = findState(to, options.relative);

        if (!isDefined(toState)) {
          if (!options.relative) throw new Error("No such state '" + to + "'");
          throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'");
        }
      }
      if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
      if (options.inherit) toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
      if (!toState.params.$$validates(toParams)) return TransitionFailed;

      toParams = toState.params.$$values(toParams);
      to = toState;

      var toPath = to.path;

      // Starting from the root of the path, keep all levels that haven't changed
      var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];

      if (!options.reload) {
        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
          locals = toLocals[keep] = state.locals;
          keep++;
          state = toPath[keep];
        }
      }

      // If we're going to the same state and all locals are kept, we've got nothing to do.
      // But clear 'transition', as we still want to cancel any other pending transitions.
      // TODO: We may not want to bump 'transition' if we're called from a location change
      // that we've initiated ourselves, because we might accidentally abort a legitimate
      // transition initiated from code?
      if (shouldTriggerReload(to, from, locals, options)) {
        if (to.self.reloadOnSearch !== false) $urlRouter.update();
        $state.transition = null;
        return $q.when($state.current);
      }

      // Filter parameters before we pass them to event handlers etc.
      toParams = filterByKeys(to.params.$$keys(), toParams || {});

      // Broadcast start event and cancel the transition if requested
      if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeStart
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when the state transition **begins**. You can use `event.preventDefault()`
         * to prevent the transition from happening and then the transition promise will be
         * rejected with a `'transition prevented'` value.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         *
         * @example
         *
         * <pre>
         * $rootScope.$on('$stateChangeStart',
         * function(event, toState, toParams, fromState, fromParams){
         *     event.preventDefault();
         *     // transitionTo() promise will be rejected with
         *     // a 'transition prevented' error
         * })
         * </pre>
         */
        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams).defaultPrevented) {
          $urlRouter.update();
          return TransitionPrevented;
        }

      }

      // Resolve locals for the remaining states, but don't update any global state just
      // yet -- if anything fails to resolve the current state needs to remain untouched.
      // We also set up an inheritance chain for the locals here. This allows the view directive
      // to quickly look up the correct definition for each view in the current state. Even
      // though we create the locals object itself outside resolveState(), it is initially
      // empty and gets filled asynchronously. We need to keep track of the promise for the
      // (fully resolved) current locals, and pass this down the chain.
      var resolved = $q.when(locals);

      for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
        locals = toLocals[l] = inherit(locals);
        resolved = resolveState(state, toParams, state === to, resolved, locals, options);
      }

      // Once everything is resolved, we are ready to perform the actual transition
      // and return a promise for the new state. We also keep track of what the
      // current promise is, so that we can detect overlapping transitions and
      // keep only the outcome of the last transition.
      var transition = $state.transition = resolved.then(function () {
        var l, entering, exiting;

        if ($state.transition !== transition) return TransitionSuperseded;

        // Exit 'from' states not kept
        for (l = fromPath.length - 1; l >= keep; l--) {
          exiting = fromPath[l];
          if (exiting.self.onExit) {
            $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
          }
          exiting.locals = null;
        }

        // Enter 'to' states not kept
        for (l = keep; l < toPath.length; l++) {
          entering = toPath[l];
          entering.locals = toLocals[l];
          if (entering.self.onEnter) {
            $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
          }
        }

        // Run it again, to catch any transitions in callbacks
        if ($state.transition !== transition) return TransitionSuperseded;

        // Update globals in $state
        $state.$current = to;
        $state.current = to.self;
        $state.params = toParams;
        copy($state.params, $stateParams);
        $state.transition = null;

        if (options.location && to.navigable) {
          $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
            $$avoidResync: true, replace: options.location === 'replace'
          });
        }

        if (options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeSuccess
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired once the state transition is **complete**.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         */
          $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
        }
        $urlRouter.update(true);

        return $state.current;
      }, function (error) {
        if ($state.transition !== transition) return TransitionSuperseded;

        $state.transition = null;
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$stateChangeError
         * @eventOf ui.router.state.$state
         * @eventType broadcast on root scope
         * @description
         * Fired when an **error occurs** during transition. It's important to note that if you
         * have any errors in your resolve functions (javascript errors, non-existent services, etc)
         * they will not throw traditionally. You must listen for this $stateChangeError event to
         * catch **ALL** errors.
         *
         * @param {Object} event Event object.
         * @param {State} toState The state being transitioned to.
         * @param {Object} toParams The params supplied to the `toState`.
         * @param {State} fromState The current state, pre-transition.
         * @param {Object} fromParams The params supplied to the `fromState`.
         * @param {Error} error The resolve error object.
         */
        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);

        if (!evt.defaultPrevented) {
            $urlRouter.update();
        }

        return $q.reject(error);
      });

      return transition;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#is
     * @methodOf ui.router.state.$state
     *
     * @description
     * Similar to {@link ui.router.state.$state#methods_includes $state.includes},
     * but only checks for the full state name. If params is supplied then it will be
     * tested for strict equality against the current active params object, so all params
     * must match with none missing and no extras.
     *
     * @example
     * <pre>
     * $state.$current.name = 'contacts.details.item';
     *
     * // absolute name
     * $state.is('contact.details.item'); // returns true
     * $state.is(contactDetailItemStateObject); // returns true
     *
     * // relative name (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * <div ng-class="{highlighted: $state.is('.item')}">Item</div>
     * </pre>
     *
     * @param {string|object} stateOrName The state name (absolute or relative) or state object you'd like to check.
     * @param {object=} params A param object, e.g. `{sectionId: section.id}`, that you'd like
     * to test against the current active state.
     * @param {object=} options An options object.  The options are:
     *
     * - **`relative`** - {string|object} -  If `stateOrName` is a relative state name and `options.relative` is set, .is will
     * test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it is the state.
     */
    $state.is = function is(stateOrName, params, options) {
      options = extend({ relative: $state.$current }, options || {});
      var state = findState(stateOrName, options.relative);

      if (!isDefined(state)) { return undefined; }
      if ($state.$current !== state) { return false; }
      return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#includes
     * @methodOf ui.router.state.$state
     *
     * @description
     * A method to determine if the current active state is equal to or is the child of the
     * state stateName. If any params are passed then they will be tested for a match as well.
     * Not all the parameters need to be passed, just the ones you'd like to test for equality.
     *
     * @example
     * Partial and relative names
     * <pre>
     * $state.$current.name = 'contacts.details.item';
     *
     * // Using partial names
     * $state.includes("contacts"); // returns true
     * $state.includes("contacts.details"); // returns true
     * $state.includes("contacts.details.item"); // returns true
     * $state.includes("contacts.list"); // returns false
     * $state.includes("about"); // returns false
     *
     * // Using relative names (. and ^), typically from a template
     * // E.g. from the 'contacts.details' template
     * <div ng-class="{highlighted: $state.includes('.item')}">Item</div>
     * </pre>
     *
     * Basic globbing patterns
     * <pre>
     * $state.$current.name = 'contacts.details.item.url';
     *
     * $state.includes("*.details.*.*"); // returns true
     * $state.includes("*.details.**"); // returns true
     * $state.includes("**.item.**"); // returns true
     * $state.includes("*.details.item.url"); // returns true
     * $state.includes("*.details.*.url"); // returns true
     * $state.includes("*.details.*"); // returns false
     * $state.includes("item.**"); // returns false
     * </pre>
     *
     * @param {string} stateOrName A partial name, relative name, or glob pattern
     * to be searched for within the current state name.
     * @param {object=} params A param object, e.g. `{sectionId: section.id}`,
     * that you'd like to test against the current active state.
     * @param {object=} options An options object.  The options are:
     *
     * - **`relative`** - {string|object=} -  If `stateOrName` is a relative state reference and `options.relative` is set,
     * .includes will test relative to `options.relative` state (or name).
     *
     * @returns {boolean} Returns true if it does include the state
     */
    $state.includes = function includes(stateOrName, params, options) {
      options = extend({ relative: $state.$current }, options || {});
      if (isString(stateOrName) && isGlob(stateOrName)) {
        if (!doesStateMatchGlob(stateOrName)) {
          return false;
        }
        stateOrName = $state.$current.name;
      }

      var state = findState(stateOrName, options.relative);
      if (!isDefined(state)) { return undefined; }
      if (!isDefined($state.$current.includes[state.name])) { return false; }
      return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
    };


    /**
     * @ngdoc function
     * @name ui.router.state.$state#href
     * @methodOf ui.router.state.$state
     *
     * @description
     * A url generation method that returns the compiled url for the given state populated with the given params.
     *
     * @example
     * <pre>
     * expect($state.href("about.person", { person: "bob" })).toEqual("/about/bob");
     * </pre>
     *
     * @param {string|object} stateOrName The state name or state object you'd like to generate a url from.
     * @param {object=} params An object of parameter values to fill the state's required parameters.
     * @param {object=} options Options object. The options are:
     *
     * - **`lossy`** - {boolean=true} -  If true, and if there is no url associated with the state provided in the
     *    first parameter, then the constructed href url will be built from the first navigable ancestor (aka
     *    ancestor with a valid url).
     * - **`inherit`** - {boolean=true}, If `true` will inherit url parameters from current url.
     * - **`relative`** - {object=$state.$current}, When transitioning with relative path (e.g '^'), 
     *    defines which state to be relative from.
     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. "http://www.example.com/fullurl".
     * 
     * @returns {string} compiled state url
     */
    $state.href = function href(stateOrName, params, options) {
      options = extend({
        lossy:    true,
        inherit:  true,
        absolute: false,
        relative: $state.$current
      }, options || {});

      var state = findState(stateOrName, options.relative);

      if (!isDefined(state)) return null;
      if (options.inherit) params = inheritParams($stateParams, params || {}, $state.$current, state);
      
      var nav = (state && options.lossy) ? state.navigable : state;

      if (!nav || nav.url === undefined || nav.url === null) {
        return null;
      }
      return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys(), params || {}), {
        absolute: options.absolute
      });
    };

    /**
     * @ngdoc function
     * @name ui.router.state.$state#get
     * @methodOf ui.router.state.$state
     *
     * @description
     * Returns the state configuration object for any specific state or all states.
     *
     * @param {string|object=} stateOrName (absolute or relative) If provided, will only get the config for
     * the requested state. If not provided, returns an array of ALL state configs.
     * @param {string|object=} context When stateOrName is a relative state reference, the state will be retrieved relative to context.
     * @returns {Object|Array} State configuration object or array of all objects.
     */
    $state.get = function (stateOrName, context) {
      if (arguments.length === 0) return map(objectKeys(states), function(name) { return states[name].self; });
      var state = findState(stateOrName, context || $state.$current);
      return (state && state.self) ? state.self : null;
    };

    function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
      // Make a restricted $stateParams with only the parameters that apply to this state if
      // necessary. In addition to being available to the controller and onEnter/onExit callbacks,
      // we also need $stateParams to be available for any $injector calls we make during the
      // dependency resolution process.
      var $stateParams = (paramsAreFiltered) ? params : filterByKeys(state.params.$$keys(), params);
      var locals = { $stateParams: $stateParams };

      // Resolve 'global' dependencies for the state, i.e. those not specific to a view.
      // We're also including $stateParams in this; that way the parameters are restricted
      // to the set that should be visible to the state, and are independent of when we update
      // the global $state and $stateParams values.
      dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
      var promises = [dst.resolve.then(function (globals) {
        dst.globals = globals;
      })];
      if (inherited) promises.push(inherited);

      // Resolve template and dependencies for all views.
      forEach(state.views, function (view, name) {
        var injectables = (view.resolve && view.resolve !== state.resolve ? view.resolve : {});
        injectables.$template = [ function () {
          return $view.load(name, { view: view, locals: locals, params: $stateParams, notify: options.notify }) || '';
        }];

        promises.push($resolve.resolve(injectables, locals, dst.resolve, state).then(function (result) {
          // References to the controller (only instantiated at link time)
          if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
            var injectLocals = angular.extend({}, injectables, locals);
            result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
          } else {
            result.$$controller = view.controller;
          }
          // Provide access to the state itself for internal use
          result.$$state = state;
          result.$$controllerAs = view.controllerAs;
          dst[name] = result;
        }));
      });

      // Wait for all the promises and then return the activation object
      return $q.all(promises).then(function (values) {
        return dst;
      });
    }

    return $state;
  }

  function shouldTriggerReload(to, from, locals, options) {
    if (to === from && ((locals === from.locals && !options.reload) || (to.self.reloadOnSearch === false))) {
      return true;
    }
  }
}

angular.module('ui.router.state')
  .value('$stateParams', {})
  .provider('$state', $StateProvider);


$ViewProvider.$inject = [];
function $ViewProvider() {

  this.$get = $get;
  /**
   * @ngdoc object
   * @name ui.router.state.$view
   *
   * @requires ui.router.util.$templateFactory
   * @requires $rootScope
   *
   * @description
   *
   */
  $get.$inject = ['$rootScope', '$templateFactory'];
  function $get(   $rootScope,   $templateFactory) {
    return {
      // $view.load('full.viewName', { template: ..., controller: ..., resolve: ..., async: false, params: ... })
      /**
       * @ngdoc function
       * @name ui.router.state.$view#load
       * @methodOf ui.router.state.$view
       *
       * @description
       *
       * @param {string} name name
       * @param {object} options option object.
       */
      load: function load(name, options) {
        var result, defaults = {
          template: null, controller: null, view: null, locals: null, notify: true, async: true, params: {}
        };
        options = extend(defaults, options);

        if (options.view) {
          result = $templateFactory.fromConfig(options.view, options.params, options.locals);
        }
        if (result && options.notify) {
        /**
         * @ngdoc event
         * @name ui.router.state.$state#$viewContentLoading
         * @eventOf ui.router.state.$view
         * @eventType broadcast on root scope
         * @description
         *
         * Fired once the view **begins loading**, *before* the DOM is rendered.
         *
         * @param {Object} event Event object.
         * @param {Object} viewConfig The view config properties (template, controller, etc).
         *
         * @example
         *
         * <pre>
         * $scope.$on('$viewContentLoading',
         * function(event, viewConfig){
         *     // Access to all the view config properties.
         *     // and one special property 'targetView'
         *     // viewConfig.targetView
         * });
         * </pre>
         */
          $rootScope.$broadcast('$viewContentLoading', options);
        }
        return result;
      }
    };
  }
}

angular.module('ui.router.state').provider('$view', $ViewProvider);

/**
 * @ngdoc object
 * @name ui.router.state.$uiViewScrollProvider
 *
 * @description
 * Provider that returns the {@link ui.router.state.$uiViewScroll} service function.
 */
function $ViewScrollProvider() {

  var useAnchorScroll = false;

  /**
   * @ngdoc function
   * @name ui.router.state.$uiViewScrollProvider#useAnchorScroll
   * @methodOf ui.router.state.$uiViewScrollProvider
   *
   * @description
   * Reverts back to using the core [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll) service for
   * scrolling based on the url anchor.
   */
  this.useAnchorScroll = function () {
    useAnchorScroll = true;
  };

  /**
   * @ngdoc object
   * @name ui.router.state.$uiViewScroll
   *
   * @requires $anchorScroll
   * @requires $timeout
   *
   * @description
   * When called with a jqLite element, it scrolls the element into view (after a
   * `$timeout` so the DOM has time to refresh).
   *
   * If you prefer to rely on `$anchorScroll` to scroll the view to the anchor,
   * this can be enabled by calling {@link ui.router.state.$uiViewScrollProvider#methods_useAnchorScroll `$uiViewScrollProvider.useAnchorScroll()`}.
   */
  this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {
    if (useAnchorScroll) {
      return $anchorScroll;
    }

    return function ($element) {
      $timeout(function () {
        $element[0].scrollIntoView();
      }, 0, false);
    };
  }];
}

angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-view
 *
 * @requires ui.router.state.$state
 * @requires $compile
 * @requires $controller
 * @requires $injector
 * @requires ui.router.state.$uiViewScroll
 * @requires $document
 *
 * @restrict ECA
 *
 * @description
 * The ui-view directive tells $state where to place your templates.
 *
 * @param {string=} name A view name. The name should be unique amongst the other views in the
 * same state. You can have views of the same name that live in different states.
 *
 * @param {string=} autoscroll It allows you to set the scroll behavior of the browser window
 * when a view is populated. By default, $anchorScroll is overridden by ui-router's custom scroll
 * service, {@link ui.router.state.$uiViewScroll}. This custom service let's you
 * scroll ui-view elements into view when they are populated during a state activation.
 *
 * *Note: To revert back to old [`$anchorScroll`](http://docs.angularjs.org/api/ng.$anchorScroll)
 * functionality, call `$uiViewScrollProvider.useAnchorScroll()`.*
 *
 * @param {string=} onload Expression to evaluate whenever the view updates.
 * 
 * @example
 * A view can be unnamed or named. 
 * <pre>
 * <!-- Unnamed -->
 * <div ui-view></div> 
 * 
 * <!-- Named -->
 * <div ui-view="viewName"></div>
 * </pre>
 *
 * You can only have one unnamed view within any template (or root html). If you are only using a 
 * single view and it is unnamed then you can populate it like so:
 * <pre>
 * <div ui-view></div> 
 * $stateProvider.state("home", {
 *   template: "<h1>HELLO!</h1>"
 * })
 * </pre>
 * 
 * The above is a convenient shortcut equivalent to specifying your view explicitly with the {@link ui.router.state.$stateProvider#views `views`}
 * config property, by name, in this case an empty name:
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }    
 * })
 * </pre>
 * 
 * But typically you'll only use the views property if you name your view or have more than one view 
 * in the same template. There's not really a compelling reason to name a view if its the only one, 
 * but you could if you wanted, like so:
 * <pre>
 * <div ui-view="main"></div>
 * </pre> 
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "main": {
 *       template: "<h1>HELLO!</h1>"
 *     }
 *   }    
 * })
 * </pre>
 * 
 * Really though, you'll use views to set up multiple views:
 * <pre>
 * <div ui-view></div>
 * <div ui-view="chart"></div> 
 * <div ui-view="data"></div> 
 * </pre>
 * 
 * <pre>
 * $stateProvider.state("home", {
 *   views: {
 *     "": {
 *       template: "<h1>HELLO!</h1>"
 *     },
 *     "chart": {
 *       template: "<chart_thing/>"
 *     },
 *     "data": {
 *       template: "<data_thing/>"
 *     }
 *   }    
 * })
 * </pre>
 *
 * Examples for `autoscroll`:
 *
 * <pre>
 * <!-- If autoscroll present with no expression,
 *      then scroll ui-view into view -->
 * <ui-view autoscroll/>
 *
 * <!-- If autoscroll present with valid expression,
 *      then scroll ui-view into view if expression evaluates to true -->
 * <ui-view autoscroll='true'/>
 * <ui-view autoscroll='false'/>
 * <ui-view autoscroll='scopeVariable'/>
 * </pre>
 */
$ViewDirective.$inject = ['$state', '$injector', '$uiViewScroll', '$interpolate'];
function $ViewDirective(   $state,   $injector,   $uiViewScroll,   $interpolate) {

  function getService() {
    return ($injector.has) ? function(service) {
      return $injector.has(service) ? $injector.get(service) : null;
    } : function(service) {
      try {
        return $injector.get(service);
      } catch (e) {
        return null;
      }
    };
  }

  var service = getService(),
      $animator = service('$animator'),
      $animate = service('$animate');

  // Returns a set of DOM manipulation functions based on which Angular version
  // it should use
  function getRenderer(attrs, scope) {
    var statics = function() {
      return {
        enter: function (element, target, cb) { target.after(element); cb(); },
        leave: function (element, cb) { element.remove(); cb(); }
      };
    };

    if ($animate) {
      return {
        enter: function(element, target, cb) {
          var promise = $animate.enter(element, null, target, cb);
          if (promise && promise.then) promise.then(cb);
        },
        leave: function(element, cb) {
          var promise = $animate.leave(element, cb);
          if (promise && promise.then) promise.then(cb);
        }
      };
    }

    if ($animator) {
      var animate = $animator && $animator(scope, attrs);

      return {
        enter: function(element, target, cb) {animate.enter(element, null, target); cb(); },
        leave: function(element, cb) { animate.leave(element); cb(); }
      };
    }

    return statics();
  }

  var directive = {
    restrict: 'ECA',
    terminal: true,
    priority: 400,
    transclude: 'element',
    compile: function (tElement, tAttrs, $transclude) {
      return function (scope, $element, attrs) {
        var previousEl, currentEl, currentScope, latestLocals,
            onloadExp     = attrs.onload || '',
            autoScrollExp = attrs.autoscroll,
            renderer      = getRenderer(attrs, scope);

        scope.$on('$stateChangeSuccess', function() {
          updateView(false);
        });
        scope.$on('$viewContentLoading', function() {
          updateView(false);
        });

        updateView(true);

        function cleanupLastView() {
          if (previousEl) {
            previousEl.remove();
            previousEl = null;
          }

          if (currentScope) {
            currentScope.$destroy();
            currentScope = null;
          }

          if (currentEl) {
            renderer.leave(currentEl, function() {
              previousEl = null;
            });

            previousEl = currentEl;
            currentEl = null;
          }
        }

        function updateView(firstTime) {
          var newScope,
              name            = getUiViewName(scope, attrs, $element, $interpolate),
              previousLocals  = name && $state.$current && $state.$current.locals[name];

          if (!firstTime && previousLocals === latestLocals) return; // nothing to do
          newScope = scope.$new();
          latestLocals = $state.$current.locals[name];

          var clone = $transclude(newScope, function(clone) {
            renderer.enter(clone, $element, function onUiViewEnter() {
              if(currentScope) {
                currentScope.$emit('$viewContentAnimationEnded');
              }

              if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                $uiViewScroll(clone);
              }
            });
            cleanupLastView();
          });

          currentEl = clone;
          currentScope = newScope;
          /**
           * @ngdoc event
           * @name ui.router.state.directive:ui-view#$viewContentLoaded
           * @eventOf ui.router.state.directive:ui-view
           * @eventType emits on ui-view directive scope
           * @description           *
           * Fired once the view is **loaded**, *after* the DOM is rendered.
           *
           * @param {Object} event Event object.
           */
          currentScope.$emit('$viewContentLoaded');
          currentScope.$eval(onloadExp);
        }
      };
    }
  };

  return directive;
}

$ViewDirectiveFill.$inject = ['$compile', '$controller', '$state', '$interpolate'];
function $ViewDirectiveFill (  $compile,   $controller,   $state,   $interpolate) {
  return {
    restrict: 'ECA',
    priority: -400,
    compile: function (tElement) {
      var initial = tElement.html();
      return function (scope, $element, attrs) {
        var current = $state.$current,
            name = getUiViewName(scope, attrs, $element, $interpolate),
            locals  = current && current.locals[name];

        if (! locals) {
          return;
        }

        $element.data('$uiView', { name: name, state: locals.$$state });
        $element.html(locals.$template ? locals.$template : initial);

        var link = $compile($element.contents());

        if (locals.$$controller) {
          locals.$scope = scope;
          var controller = $controller(locals.$$controller, locals);
          if (locals.$$controllerAs) {
            scope[locals.$$controllerAs] = controller;
          }
          $element.data('$ngControllerController', controller);
          $element.children().data('$ngControllerController', controller);
        }

        link(scope);
      };
    }
  };
}

/**
 * Shared ui-view code for both directives:
 * Given scope, element, and its attributes, return the view's name
 */
function getUiViewName(scope, attrs, element, $interpolate) {
  var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
  var inherited = element.inheritedData('$uiView');
  return name.indexOf('@') >= 0 ?  name :  (name + '@' + (inherited ? inherited.state.name : ''));
}

angular.module('ui.router.state').directive('uiView', $ViewDirective);
angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);

function parseStateRef(ref, current) {
  var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
  if (preparsed) ref = current + '(' + preparsed[1] + ')';
  parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
  if (!parsed || parsed.length !== 4) throw new Error("Invalid state ref '" + ref + "'");
  return { state: parsed[1], paramExpr: parsed[3] || null };
}

function stateContext(el) {
  var stateData = el.parent().inheritedData('$uiView');

  if (stateData && stateData.state && stateData.state.name) {
    return stateData.state;
  }
}

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref
 *
 * @requires ui.router.state.$state
 * @requires $timeout
 *
 * @restrict A
 *
 * @description
 * A directive that binds a link (`<a>` tag) to a state. If the state has an associated 
 * URL, the directive will automatically generate & update the `href` attribute via 
 * the {@link ui.router.state.$state#methods_href $state.href()} method. Clicking 
 * the link will trigger a state transition with optional parameters. 
 *
 * Also middle-clicking, right-clicking, and ctrl-clicking on the link will be 
 * handled natively by the browser.
 *
 * You can also use relative state paths within ui-sref, just like the relative 
 * paths passed to `$state.go()`. You just need to be aware that the path is relative
 * to the state that the link lives in, in other words the state that loaded the 
 * template containing the link.
 *
 * You can specify options to pass to {@link ui.router.state.$state#go $state.go()}
 * using the `ui-sref-opts` attribute. Options are restricted to `location`, `inherit`,
 * and `reload`.
 *
 * @example
 * Here's an example of how you'd use ui-sref and how it would compile. If you have the 
 * following template:
 * <pre>
 * <a ui-sref="home">Home</a> | <a ui-sref="about">About</a> | <a ui-sref="{page: 2}">Next page</a>
 * 
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a ui-sref="contacts.detail({ id: contact.id })">{{ contact.name }}</a>
 *     </li>
 * </ul>
 * </pre>
 * 
 * Then the compiled html would be (assuming Html5Mode is off and current state is contacts):
 * <pre>
 * <a href="#/home" ui-sref="home">Home</a> | <a href="#/about" ui-sref="about">About</a> | <a href="#/contacts?page=2" ui-sref="{page: 2}">Next page</a>
 * 
 * <ul>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/1" ui-sref="contacts.detail({ id: contact.id })">Joe</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/2" ui-sref="contacts.detail({ id: contact.id })">Alice</a>
 *     </li>
 *     <li ng-repeat="contact in contacts">
 *         <a href="#/contacts/3" ui-sref="contacts.detail({ id: contact.id })">Bob</a>
 *     </li>
 * </ul>
 *
 * <a ui-sref="home" ui-sref-opts="{reload: true}">Home</a>
 * </pre>
 *
 * @param {string} ui-sref 'stateName' can be any valid absolute or relative state
 * @param {Object} ui-sref-opts options to pass to {@link ui.router.state.$state#go $state.go()}
 */
$StateRefDirective.$inject = ['$state', '$timeout'];
function $StateRefDirective($state, $timeout) {
  var allowedOptions = ['location', 'inherit', 'reload'];

  return {
    restrict: 'A',
    require: ['?^uiSrefActive', '?^uiSrefActiveEq'],
    link: function(scope, element, attrs, uiSrefActive) {
      var ref = parseStateRef(attrs.uiSref, $state.current.name);
      var params = null, url = null, base = stateContext(element) || $state.$current;
      var newHref = null, isAnchor = element.prop("tagName") === "A";
      var isForm = element[0].nodeName === "FORM";
      var attr = isForm ? "action" : "href", nav = true;

      var options = { relative: base, inherit: true };
      var optionsOverride = scope.$eval(attrs.uiSrefOpts) || {};

      angular.forEach(allowedOptions, function(option) {
        if (option in optionsOverride) {
          options[option] = optionsOverride[option];
        }
      });

      var update = function(newVal) {
        if (newVal) params = angular.copy(newVal);
        if (!nav) return;

        newHref = $state.href(ref.state, params, options);

        var activeDirective = uiSrefActive[1] || uiSrefActive[0];
        if (activeDirective) {
          activeDirective.$$setStateInfo(ref.state, params);
        }
        if (newHref === null) {
          nav = false;
          return false;
        }
        attrs.$set(attr, newHref);
      };

      if (ref.paramExpr) {
        scope.$watch(ref.paramExpr, function(newVal, oldVal) {
          if (newVal !== params) update(newVal);
        }, true);
        params = angular.copy(scope.$eval(ref.paramExpr));
      }
      update();

      if (isForm) return;

      element.bind("click", function(e) {
        var button = e.which || e.button;
        if ( !(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || element.attr('target')) ) {
          // HACK: This is to allow ng-clicks to be processed before the transition is initiated:
          var transition = $timeout(function() {
            $state.go(ref.state, params, options);
          });
          e.preventDefault();

          // if the state has no URL, ignore one preventDefault from the <a> directive.
          var ignorePreventDefaultCount = isAnchor && !newHref ? 1: 0;
          e.preventDefault = function() {
            if (ignorePreventDefaultCount-- <= 0)
              $timeout.cancel(transition);
          };
        }
      });
    }
  };
}

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref-active
 *
 * @requires ui.router.state.$state
 * @requires ui.router.state.$stateParams
 * @requires $interpolate
 *
 * @restrict A
 *
 * @description
 * A directive working alongside ui-sref to add classes to an element when the
 * related ui-sref directive's state is active, and removing them when it is inactive.
 * The primary use-case is to simplify the special appearance of navigation menus
 * relying on `ui-sref`, by having the "active" state's menu button appear different,
 * distinguishing it from the inactive menu items.
 *
 * ui-sref-active can live on the same element as ui-sref or on a parent element. The first
 * ui-sref-active found at the same level or above the ui-sref will be used.
 *
 * Will activate when the ui-sref's target state or any child state is active. If you
 * need to activate only when the ui-sref target state is active and *not* any of
 * it's children, then you will use
 * {@link ui.router.state.directive:ui-sref-active-eq ui-sref-active-eq}
 *
 * @example
 * Given the following template:
 * <pre>
 * <ul>
 *   <li ui-sref-active="active" class="item">
 *     <a href ui-sref="app.user({user: 'bilbobaggins'})">@bilbobaggins</a>
 *   </li>
 * </ul>
 * </pre>
 *
 *
 * When the app state is "app.user" (or any children states), and contains the state parameter "user" with value "bilbobaggins",
 * the resulting HTML will appear as (note the 'active' class):
 * <pre>
 * <ul>
 *   <li ui-sref-active="active" class="item active">
 *     <a ui-sref="app.user({user: 'bilbobaggins'})" href="/users/bilbobaggins">@bilbobaggins</a>
 *   </li>
 * </ul>
 * </pre>
 *
 * The class name is interpolated **once** during the directives link time (any further changes to the
 * interpolated value are ignored).
 *
 * Multiple classes may be specified in a space-separated format:
 * <pre>
 * <ul>
 *   <li ui-sref-active='class1 class2 class3'>
 *     <a ui-sref="app.user">link</a>
 *   </li>
 * </ul>
 * </pre>
 */

/**
 * @ngdoc directive
 * @name ui.router.state.directive:ui-sref-active-eq
 *
 * @requires ui.router.state.$state
 * @requires ui.router.state.$stateParams
 * @requires $interpolate
 *
 * @restrict A
 *
 * @description
 * The same as {@link ui.router.state.directive:ui-sref-active ui-sref-active} but will only activate
 * when the exact target state used in the `ui-sref` is active; no child states.
 *
 */
$StateRefActiveDirective.$inject = ['$state', '$stateParams', '$interpolate'];
function $StateRefActiveDirective($state, $stateParams, $interpolate) {
  return  {
    restrict: "A",
    controller: ['$scope', '$element', '$attrs', function ($scope, $element, $attrs) {
      var state, params, activeClass;

      // There probably isn't much point in $observing this
      // uiSrefActive and uiSrefActiveEq share the same directive object with some
      // slight difference in logic routing
      activeClass = $interpolate($attrs.uiSrefActiveEq || $attrs.uiSrefActive || '', false)($scope);

      // Allow uiSref to communicate with uiSrefActive[Equals]
      this.$$setStateInfo = function (newState, newParams) {
        state = $state.get(newState, stateContext($element));
        params = newParams;
        update();
      };

      $scope.$on('$stateChangeSuccess', update);

      // Update route state
      function update() {
        if (isMatch()) {
          $element.addClass(activeClass);
        } else {
          $element.removeClass(activeClass);
        }
      }

      function isMatch() {
        if (typeof $attrs.uiSrefActiveEq !== 'undefined') {
          return state && $state.is(state.name, params);
        } else {
          return state && $state.includes(state.name, params);
        }
      }
    }]
  };
}

angular.module('ui.router.state')
  .directive('uiSref', $StateRefDirective)
  .directive('uiSrefActive', $StateRefActiveDirective)
  .directive('uiSrefActiveEq', $StateRefActiveDirective);

/**
 * @ngdoc filter
 * @name ui.router.state.filter:isState
 *
 * @requires ui.router.state.$state
 *
 * @description
 * Translates to {@link ui.router.state.$state#methods_is $state.is("stateName")}.
 */
$IsStateFilter.$inject = ['$state'];
function $IsStateFilter($state) {
  var isFilter = function (state) {
    return $state.is(state);
  };
  isFilter.$stateful = true;
  return isFilter;
}

/**
 * @ngdoc filter
 * @name ui.router.state.filter:includedByState
 *
 * @requires ui.router.state.$state
 *
 * @description
 * Translates to {@link ui.router.state.$state#methods_includes $state.includes('fullOrPartialStateName')}.
 */
$IncludedByStateFilter.$inject = ['$state'];
function $IncludedByStateFilter($state) {
  var includesFilter = function (state) {
    return $state.includes(state);
  };
  includesFilter.$stateful = true;
  return  includesFilter;
}

angular.module('ui.router.state')
  .filter('isState', $IsStateFilter)
  .filter('includedByState', $IncludedByStateFilter);
})(window, window.angular);;
/**
LICENSE-START
 * @license Angular UI Tree v2.9.0
 * (c) 2010-2015. https://github.com/angular-ui-tree/angular-ui-tree
 * License: MIT
 LICENSE-END
 */
(function () {
  'use strict';

  angular.module('ui.tree', [])
    .constant('treeConfig', {
      treeClass: 'angular-ui-tree',
      emptyTreeClass: 'angular-ui-tree-empty',
      hiddenClass: 'angular-ui-tree-hidden',
      nodesClass: 'angular-ui-tree-nodes',
      nodeClass: 'angular-ui-tree-node',
      handleClass: 'angular-ui-tree-handle',
      placeholderClass: 'angular-ui-tree-placeholder',
      dragClass: 'angular-ui-tree-drag',
      dragThreshold: 3,
      levelThreshold: 30
    });

})();

(function () {
  'use strict';

  angular.module('ui.tree')

    .controller('TreeHandleController', ['$scope', '$element',
      function ($scope, $element) {
        this.scope = $scope;

        $scope.$element = $element;
        $scope.$nodeScope = null;
        $scope.$type = 'uiTreeHandle';

      }
    ]);
})();

(function () {
  'use strict';

  angular.module('ui.tree')
    .controller('TreeNodeController', ['$scope', '$element',
      function ($scope, $element) {
        this.scope = $scope;

        $scope.$element = $element;
        $scope.$modelValue = null; // Model value for node;
        $scope.$parentNodeScope = null; // uiTreeNode Scope of parent node;
        $scope.$childNodesScope = null; // uiTreeNodes Scope of child nodes.
        $scope.$parentNodesScope = null; // uiTreeNodes Scope of parent nodes.
        $scope.$treeScope = null; // uiTree scope
        $scope.$handleScope = null; // it's handle scope
        $scope.$type = 'uiTreeNode';
        $scope.$$apply = false;
        $scope.collapsed = false;

        $scope.init = function (controllersArr) {
          var treeNodesCtrl = controllersArr[0];
          $scope.$treeScope = controllersArr[1] ? controllersArr[1].scope : null;

          // find the scope of it's parent node
          $scope.$parentNodeScope = treeNodesCtrl.scope.$nodeScope;
          // modelValue for current node
          $scope.$modelValue = treeNodesCtrl.scope.$modelValue[$scope.$index];
          $scope.$parentNodesScope = treeNodesCtrl.scope;
          treeNodesCtrl.scope.initSubNode($scope); // init sub nodes

          $element.on('$destroy', function () {
            treeNodesCtrl.scope.destroySubNode($scope); // destroy sub nodes
          });
        };

        $scope.index = function () {
          return $scope.$parentNodesScope.$modelValue.indexOf($scope.$modelValue);
        };

        $scope.dragEnabled = function () {
          return !($scope.$treeScope && !$scope.$treeScope.dragEnabled);
        };

        $scope.isSibling = function (targetNode) {
          return $scope.$parentNodesScope == targetNode.$parentNodesScope;
        };

        $scope.isChild = function (targetNode) {
          var nodes = $scope.childNodes();
          return nodes && nodes.indexOf(targetNode) > -1;
        };

        $scope.prev = function () {
          var index = $scope.index();
          if (index > 0) {
            return $scope.siblings()[index - 1];
          }
          return null;
        };

        $scope.siblings = function () {
          return $scope.$parentNodesScope.childNodes();
        };

        $scope.childNodesCount = function () {
          return $scope.childNodes() ? $scope.childNodes().length : 0;
        };

        $scope.hasChild = function () {
          return $scope.childNodesCount() > 0;
        };

        $scope.childNodes = function () {
          return $scope.$childNodesScope && $scope.$childNodesScope.$modelValue ?
            $scope.$childNodesScope.childNodes() :
            null;
        };

        $scope.accept = function (sourceNode, destIndex) {
          return $scope.$childNodesScope &&
            $scope.$childNodesScope.$modelValue &&
            $scope.$childNodesScope.accept(sourceNode, destIndex);
        };

        $scope.removeNode = function () {
          var node = $scope.remove();
          $scope.$callbacks.removed(node);
          return node;
        };

        $scope.remove = function () {
          return $scope.$parentNodesScope.removeNode($scope);
        };

        $scope.toggle = function () {
          $scope.collapsed = !$scope.collapsed;
        };

        $scope.select = function () {
          $scope.toggle();
        };

        $scope.collapse = function () {
          $scope.collapsed = true;
        };

        $scope.expand = function () {
          $scope.collapsed = false;
        };

        $scope.depth = function () {
          var parentNode = $scope.$parentNodeScope;
          if (parentNode) {
            return parentNode.depth() + 1;
          }
          return 1;
        };

        var subDepth = 0;
        function countSubDepth(scope) {
          var i, childNodes,
              count = 0,
              nodes = scope.childNodes();

          for (i = 0; i < nodes.length; i++) {
            childNodes = nodes[i].$childNodesScope;

            if (childNodes && childNodes.childNodesCount() > 0) {
              count = 1;
              countSubDepth(childNodes);
            }
          }
          subDepth += count;
        }

        $scope.maxSubDepth = function () {
          subDepth = 0;
          if ($scope.$childNodesScope) {
            countSubDepth($scope.$childNodesScope);
          }
          return subDepth;
        };

      }
    ]);
})();

(function () {
  'use strict';

  angular.module('ui.tree')

    .controller('TreeNodesController', ['$scope', '$element',
      function ($scope, $element) {
        this.scope = $scope;

        $scope.$element = $element;
        $scope.$modelValue = null;
        $scope.$nodeScope = null; // the scope of node which the nodes belongs to
        $scope.$treeScope = null;
        $scope.$type = 'uiTreeNodes';
        $scope.$nodesMap = {};

        $scope.nodropEnabled = false;
        $scope.maxDepth = 0;
        $scope.cloneEnabled = false;

        $scope.initSubNode = function (subNode) {
          if (!subNode.$modelValue) {
            return null;
          }
          $scope.$nodesMap[subNode.$modelValue.$$hashKey] = subNode;
        };

        $scope.destroySubNode = function (subNode) {
          if (!subNode.$modelValue) {
            return null;
          }
          $scope.$nodesMap[subNode.$modelValue.$$hashKey] = null;
        };

        $scope.accept = function (sourceNode, destIndex) {
          return $scope.$treeScope.$callbacks.accept(sourceNode, $scope, destIndex);
        };

        $scope.beforeDrag = function (sourceNode) {
          return $scope.$treeScope.$callbacks.beforeDrag(sourceNode);
        };

        $scope.isParent = function (node) {
          return node.$parentNodesScope == $scope;
        };

        $scope.hasChild = function () {
          return $scope.$modelValue.length > 0;
        };

        $scope.safeApply = function (fn) {
          var phase = this.$root.$$phase;
          if (phase == '$apply' || phase == '$digest') {
            if (fn && (typeof (fn) === 'function')) {
              fn();
            }
          } else {
            this.$apply(fn);
          }
        };

        $scope.removeNode = function (node) {
          var index = $scope.$modelValue.indexOf(node.$modelValue);
          if (index > -1) {
            $scope.safeApply(function () {
              $scope.$modelValue.splice(index, 1)[0];
            });
            return node;
          }
          return null;
        };

        $scope.insertNode = function (index, nodeData) {
          $scope.safeApply(function () {
            $scope.$modelValue.splice(index, 0, nodeData);
          });
        };

        $scope.childNodes = function () {
          var i, nodes = [];
          if ($scope.$modelValue) {
            for (i = 0; i < $scope.$modelValue.length; i++) {
              nodes.push($scope.$nodesMap[$scope.$modelValue[i].$$hashKey]);
            }
          }
          return nodes;
        };

        $scope.depth = function () {
          if ($scope.$nodeScope) {
            return $scope.$nodeScope.depth();
          }
          return 0; // if it has no $nodeScope, it's root
        };

        // check if depth limit has reached
        $scope.outOfDepth = function (sourceNode) {
          var maxDepth = $scope.maxDepth || $scope.$treeScope.maxDepth;
          if (maxDepth > 0) {
            return $scope.depth() + sourceNode.maxSubDepth() + 1 > maxDepth;
          }
          return false;
        };

      }
    ]);
})();

(function () {
  'use strict';

  angular.module('ui.tree')

    .controller('TreeController', ['$scope', '$element',
      function ($scope, $element) {
        this.scope = $scope;

        $scope.$element = $element;
        $scope.$nodesScope = null; // root nodes
        $scope.$type = 'uiTree';
        $scope.$emptyElm = null;
        $scope.$callbacks = null;

        $scope.dragEnabled = false;
        $scope.emptyPlaceholderEnabled = true;
        $scope.maxDepth = 0;
        $scope.dragDelay = 0;
        $scope.cloneEnabled = false;
        $scope.nodropEnabled = false;

        // Check if it's a empty tree
        $scope.isEmpty = function () {
          return ($scope.$nodesScope && $scope.$nodesScope.$modelValue
          && $scope.$nodesScope.$modelValue.length === 0);
        };

        // add placeholder to empty tree
        $scope.place = function (placeElm) {
          $scope.$nodesScope.$element.append(placeElm);
          $scope.$emptyElm.remove();
        };

        this.resetEmptyElement = function () {
          if ((!$scope.$nodesScope.$modelValue || $scope.$nodesScope.$modelValue.length === 0) &&
            $scope.emptyPlaceholderEnabled) {
            $element.append($scope.$emptyElm);
          } else {
            $scope.$emptyElm.remove();
          }
        };

        $scope.resetEmptyElement = this.resetEmptyElement;

        var collapseOrExpand = function (scope, collapsed) {
          var i, subScope,
              nodes = scope.childNodes();
          for (i = 0; i < nodes.length; i++) {
            collapsed ? nodes[i].collapse() : nodes[i].expand();
            subScope = nodes[i].$childNodesScope;
            if (subScope) {
              collapseOrExpand(subScope, collapsed);
            }
          }
        };

        $scope.collapseAll = function () {
          collapseOrExpand($scope.$nodesScope, true);
        };

        $scope.expandAll = function () {
          collapseOrExpand($scope.$nodesScope, false);
        };

      }
    ]);
})();

(function () {
  'use strict';

  angular.module('ui.tree')
    .directive('uiTree', ['treeConfig', '$window',
      function (treeConfig, $window) {
        return {
          restrict: 'A',
          scope: true,
          controller: 'TreeController',
          link: function (scope, element, attrs, ctrl) {
            var callbacks = {
              accept: null,
              beforeDrag: null
            },
              config = {};

            angular.extend(config, treeConfig);
            if (config.treeClass) {
              element.addClass(config.treeClass);
            }

            scope.$emptyElm = angular.element($window.document.createElement('div'));
            if (config.emptyTreeClass) {
              scope.$emptyElm.addClass(config.emptyTreeClass);
            }

            scope.$watch('$nodesScope.$modelValue.length', function () {
              if (!scope.$nodesScope.$modelValue) {
                return;
              }

              ctrl.resetEmptyElement();
            }, true);

            scope.$watch(attrs.dragEnabled, function (val) {
              if ((typeof val) == 'boolean') {
                scope.dragEnabled = val;
              }
            });

            scope.$watch(attrs.emptyPlaceholderEnabled, function (val) {
              if ((typeof val) == 'boolean') {
                scope.emptyPlaceholderEnabled = val;
                ctrl.resetEmptyElement();
              }
            });

            scope.$watch(attrs.nodropEnabled, function (val) {
              if ((typeof val) == 'boolean') {
                scope.nodropEnabled = val;
              }
            });

            scope.$watch(attrs.cloneEnabled, function (val) {
              if ((typeof val) == 'boolean') {
                scope.cloneEnabled = val;
              }
            });

            scope.$watch(attrs.maxDepth, function (val) {
              if ((typeof val) == 'number') {
                scope.maxDepth = val;
              }
            });

            scope.$watch(attrs.dragDelay, function (val) {
              if ((typeof val) == 'number') {
                scope.dragDelay = val;
              }
            });

            // check if the dest node can accept the dragging node
            // by default, we check the 'data-nodrop-enabled' attribute in `ui-tree-nodes`
            // and the 'max-depth' attribute in `ui-tree` or `ui-tree-nodes`.
            // the method can be overrided
            callbacks.accept = function (sourceNodeScope, destNodesScope, destIndex) {
              return !(destNodesScope.nodropEnabled || destNodesScope.outOfDepth(sourceNodeScope));
            };

            callbacks.beforeDrag = function (sourceNodeScope) {
              return true;
            };

            callbacks.removed = function (node) {

            };

            callbacks.dropped = function (event) {

            };

            callbacks.dragStart = function (event) {

            };

            callbacks.dragMove = function (event) {

            };

            callbacks.dragStop = function (event) {

            };

            callbacks.beforeDrop = function (event) {

            };

            scope.$watch(attrs.uiTree, function (newVal, oldVal) {
              angular.forEach(newVal, function (value, key) {
                if (callbacks[key]) {
                  if (typeof value === 'function') {
                    callbacks[key] = value;
                  }
                }
              });

              scope.$callbacks = callbacks;
            }, true);


          }
        };
      }
    ]);
})();

(function () {
  'use strict';

  angular.module('ui.tree')
    .directive('uiTreeHandle', ['treeConfig',
      function (treeConfig) {
        return {
          require: '^uiTreeNode',
          restrict: 'A',
          scope: true,
          controller: 'TreeHandleController',
          link: function (scope, element, attrs, treeNodeCtrl) {
            var config = {};
            angular.extend(config, treeConfig);
            if (config.handleClass) {
              element.addClass(config.handleClass);
            }
            // connect with the tree node.
            if (scope != treeNodeCtrl.scope) {
              scope.$nodeScope = treeNodeCtrl.scope;
              treeNodeCtrl.scope.$handleScope = scope;
            }
          }
        };
      }
    ]);
})();

(function () {
  'use strict';

  angular.module('ui.tree')

    .directive('uiTreeNode', ['treeConfig', 'UiTreeHelper', '$window', '$document', '$timeout',
      function (treeConfig, UiTreeHelper, $window, $document, $timeout) {
        return {
          require: ['^uiTreeNodes', '^uiTree'],
          restrict: 'A',
          controller: 'TreeNodeController',
          link: function (scope, element, attrs, controllersArr) {
            // todo startPos is unused
            var config = {},
              hasTouch = 'ontouchstart' in window,
              startPos, firstMoving, dragInfo, pos,
              placeElm, hiddenPlaceElm, dragElm,
              treeScope = null,
              elements, // As a parameter for callbacks
              dragDelaying = true,
              dragStarted = false,
              dragTimer = null,
              body = document.body,
              html = document.documentElement,
              document_height,
              document_width,
              dragStart,
              tagName,
              dragMove,
              dragEnd,
              dragStartEvent,
              dragMoveEvent,
              dragEndEvent,
              dragCancelEvent,
              dragDelay,
              bindDrag,
              keydownHandler,
              outOfBounds;
            angular.extend(config, treeConfig);
            if (config.nodeClass) {
              element.addClass(config.nodeClass);
            }
            scope.init(controllersArr);

            scope.collapsed = !!UiTreeHelper.getNodeAttribute(scope, 'collapsed');
            scope.sourceOnly = scope.nodropEnabled || scope.$treeScope.nodropEnabled;

            scope.$watch(attrs.collapsed, function (val) {
              if ((typeof val) == 'boolean') {
                scope.collapsed = val;
              }
            });

            scope.$watch('collapsed', function (val) {
              UiTreeHelper.setNodeAttribute(scope, 'collapsed', val);
              attrs.$set('collapsed', val);
            });

            dragStart = function (e) {
              if (!hasTouch && (e.button == 2 || e.which == 3)) {
                // disable right click
                return;
              }
              if (e.uiTreeDragging || (e.originalEvent && e.originalEvent.uiTreeDragging)) { // event has already fired in other scope.
                return;
              }

              // the element which is clicked.
              var eventElm = angular.element(e.target),
                eventScope = eventElm.scope(),
                cloneElm = element.clone(),
                eventElmTagName, tagName,
                eventObj, tdElm, hStyle;
              if (!eventScope || !eventScope.$type) {
                return;
              }
              if (eventScope.$type != 'uiTreeNode'
                && eventScope.$type != 'uiTreeHandle') { // Check if it is a node or a handle
                return;
              }
              if (eventScope.$type == 'uiTreeNode'
                && eventScope.$handleScope) { // If the node has a handle, then it should be clicked by the handle
                return;
              }

              eventElmTagName = eventElm.prop('tagName').toLowerCase();
              if (eventElmTagName == 'input' ||
                eventElmTagName == 'textarea' ||
                eventElmTagName == 'button' ||
                eventElmTagName == 'select') { // if it's a input or button, ignore it
                return;
              }

              // check if it or it's parents has a 'data-nodrag' attribute
              while (eventElm && eventElm[0] && eventElm[0] != element) {
                if (UiTreeHelper.nodrag(eventElm)) { // if the node mark as `nodrag`, DONOT drag it.
                  return;
                }
                eventElm = eventElm.parent();
              }

              if (!scope.beforeDrag(scope)) {
                return;
              }

              e.uiTreeDragging = true; // stop event bubbling
              if (e.originalEvent) {
                e.originalEvent.uiTreeDragging = true;
              }
              e.preventDefault();
              eventObj = UiTreeHelper.eventObj(e);

              firstMoving = true;
              dragInfo = UiTreeHelper.dragInfo(scope);

              // Fire dragStart callback
              scope.$apply(function () {
                scope.$treeScope.$callbacks.dragStart(dragInfo.eventArgs(elements, pos));
              });

              tagName = scope.$element.prop('tagName');

              if (tagName.toLowerCase() === 'tr') {
                placeElm = angular.element($window.document.createElement(tagName));
                tdElm = angular.element($window.document.createElement('td'))
                  .addClass(config.placeholderClass);
                placeElm.append(tdElm);
              } else {
                placeElm = angular.element($window.document.createElement(tagName))
                  .addClass(config.placeholderClass);
              }
              hiddenPlaceElm = angular.element($window.document.createElement(tagName));
              if (config.hiddenClass) {
                hiddenPlaceElm.addClass(config.hiddenClass);
              }

              pos = UiTreeHelper.positionStarted(eventObj, scope.$element);
              placeElm.css('height', UiTreeHelper.height(scope.$element) + 'px');
              placeElm.css('width', UiTreeHelper.width(scope.$element) + 'px');

              dragElm = angular.element($window.document.createElement(scope.$parentNodesScope.$element.prop('tagName')))
                .addClass(scope.$parentNodesScope.$element.attr('class')).addClass(config.dragClass);
              dragElm.css('width', UiTreeHelper.width(scope.$element) + 'px');
              dragElm.css('z-index', 9999);

              // Prevents cursor to change rapidly in Opera 12.16 and IE when dragging an element
              hStyle = (scope.$element[0].querySelector('.angular-ui-tree-handle') || scope.$element[0]).currentStyle;
              if (hStyle) {
                document.body.setAttribute('ui-tree-cursor', $document.find('body').css('cursor') || '');
                $document.find('body').css({'cursor': hStyle.cursor + '!important'});
              }

              if (scope.sourceOnly) {
                placeElm.css('display', 'none');
              }
              scope.$element.after(placeElm);
              scope.$element.after(hiddenPlaceElm);
              if (dragInfo.isClone() && scope.sourceOnly) {
                dragElm.append(cloneElm);
              } else {
                dragElm.append(scope.$element);
              }
              $document.find('body').append(dragElm);
              dragElm.css({
                'left': eventObj.pageX - pos.offsetX + 'px',
                'top': eventObj.pageY - pos.offsetY + 'px'
              });
              elements = {
                placeholder: placeElm,
                dragging: dragElm
              };

              angular.element($document).bind('touchend', dragEndEvent);
              angular.element($document).bind('touchcancel', dragEndEvent);
              angular.element($document).bind('touchmove', dragMoveEvent);
              angular.element($document).bind('mouseup', dragEndEvent);
              angular.element($document).bind('mousemove', dragMoveEvent);
              angular.element($document).bind('mouseleave', dragCancelEvent);

              document_height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
              document_width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
            };

            dragMove = function (e) {
              var eventObj = UiTreeHelper.eventObj(e),
                prev,
                next,
                leftElmPos,
                topElmPos,
                top_scroll,
                bottom_scroll,
                target,
                decrease,
                targetX,
                targetY,
                displayElm,
                targetNode,
                targetElm,
                isEmpty,
                targetOffset,
                targetBefore;

              if (dragElm) {
                e.preventDefault();

                if ($window.getSelection) {
                  $window.getSelection().removeAllRanges();
                } else if ($window.document.selection) {
                  $window.document.selection.empty();
                }

                leftElmPos = eventObj.pageX - pos.offsetX;
                topElmPos = eventObj.pageY - pos.offsetY;

                //dragElm can't leave the screen on the left
                if (leftElmPos < 0) {
                  leftElmPos = 0;
                }

                //dragElm can't leave the screen on the top
                if (topElmPos < 0) {
                  topElmPos = 0;
                }

                //dragElm can't leave the screen on the bottom
                if ((topElmPos + 10) > document_height) {
                  topElmPos = document_height - 10;
                }

                //dragElm can't leave the screen on the right
                if ((leftElmPos + 10) > document_width) {
                  leftElmPos = document_width - 10;
                }

                dragElm.css({
                  'left': leftElmPos + 'px',
                  'top': topElmPos + 'px'
                });

                top_scroll = window.pageYOffset || $window.document.documentElement.scrollTop;
                bottom_scroll = top_scroll + (window.innerHeight || $window.document.clientHeight || $window.document.clientHeight);

                // to scroll down if cursor y-position is greater than the bottom position the vertical scroll
                if (bottom_scroll < eventObj.pageY && bottom_scroll <= document_height) {
                  window.scrollBy(0, 10);
                }

                // to scroll top if cursor y-position is less than the top position the vertical scroll
                if (top_scroll > eventObj.pageY) {
                  window.scrollBy(0, -10);
                }

                UiTreeHelper.positionMoved(e, pos, firstMoving);
                if (firstMoving) {
                  firstMoving = false;
                  return;
                }

                // check if add it as a child node first
                // todo decrease is unused
                decrease = (UiTreeHelper.offset(dragElm).left - UiTreeHelper.offset(placeElm).left) >= config.threshold;
                targetX = eventObj.pageX - $window.document.body.scrollLeft;
                targetY = eventObj.pageY - (window.pageYOffset || $window.document.documentElement.scrollTop);

                // Select the drag target. Because IE does not support CSS 'pointer-events: none', it will always
                // pick the drag element itself as the target. To prevent this, we hide the drag element while
                // selecting the target.
                if (angular.isFunction(dragElm.hide)) {
                  dragElm.hide();
                } else {
                  displayElm = dragElm[0].style.display;
                  dragElm[0].style.display = 'none';
                }

                // when using elementFromPoint() inside an iframe, you have to call
                // elementFromPoint() twice to make sure IE8 returns the correct value
                $window.document.elementFromPoint(targetX, targetY);

                targetElm = angular.element($window.document.elementFromPoint(targetX, targetY));

                if (angular.isFunction(dragElm.show)) {
                  dragElm.show();
                } else {
                  dragElm[0].style.display = displayElm;
                }

                outOfBounds = !(targetElm.scope().$type);

                // Detect out of bounds condition, update drop target display, and prevent drop
                if (outOfBounds) {

                  // Remove the placeholder
                  placeElm.remove();

                  // If the target was an empty tree, replace the empty element placeholder
                  if (treeScope) {
                    treeScope.resetEmptyElement();
                    treeScope = null;
                  }
                }

                // move horizontal
                if (pos.dirAx && pos.distAxX >= config.levelThreshold) {
                  pos.distAxX = 0;

                  // increase horizontal level if previous sibling exists and is not collapsed
                  if (pos.distX > 0) {
                    prev = dragInfo.prev();
                    if (prev && !prev.collapsed
                      && prev.accept(scope, prev.childNodesCount())) {
                      prev.$childNodesScope.$element.append(placeElm);
                      dragInfo.moveTo(prev.$childNodesScope, prev.childNodes(), prev.childNodesCount());
                    }
                  }

                  // decrease horizontal level
                  if (pos.distX < 0) {
                    // we can't decrease a level if an item preceeds the current one
                    next = dragInfo.next();
                    if (!next) {
                      target = dragInfo.parentNode(); // As a sibling of it's parent node
                      if (target
                        && target.$parentNodesScope.accept(scope, target.index() + 1)) {
                        target.$element.after(placeElm);
                        dragInfo.moveTo(target.$parentNodesScope, target.siblings(), target.index() + 1);
                      }
                    }
                  }
                }

                // move vertical
                if (!pos.dirAx) {
                  // check it's new position
                  targetNode = targetElm.scope();
                  isEmpty = false;
                  if (!targetNode) {
                    return;
                  }

                  // Show the placeholder if it was hidden for nodrop-enabled and this is a new tree
                  if (targetNode.$treeScope && !targetNode.$parent.nodropEnabled && !targetNode.$treeScope.nodropEnabled) {
                    placeElm.css('display', 'block');
                  }

                  if (targetNode.$type == 'uiTree' && targetNode.dragEnabled) {
                    isEmpty = targetNode.isEmpty(); // Check if it's empty tree
                  }

                  if (targetNode.$type == 'uiTreeHandle') {
                    targetNode = targetNode.$nodeScope;
                  }

                  if (targetNode.$type != 'uiTreeNode'
                    && !isEmpty) { // Check if it is a uiTreeNode or it's an empty tree
                    return;
                  }

                  // if placeholder move from empty tree, reset it.
                  if (treeScope && placeElm.parent()[0] != treeScope.$element[0]) {
                    treeScope.resetEmptyElement();
                    treeScope = null;
                  }

                  if (isEmpty) { // it's an empty tree
                    treeScope = targetNode;
                    if (targetNode.$nodesScope.accept(scope, 0)) {
                      targetNode.place(placeElm);
                      dragInfo.moveTo(targetNode.$nodesScope, targetNode.$nodesScope.childNodes(), 0);
                    }
                  } else if (targetNode.dragEnabled()) { // drag enabled
                    targetElm = targetNode.$element; // Get the element of ui-tree-node
                    targetOffset = UiTreeHelper.offset(targetElm);
                    targetBefore = targetNode.horizontal ? eventObj.pageX < (targetOffset.left + UiTreeHelper.width(targetElm) / 2)
                      : eventObj.pageY < (targetOffset.top + UiTreeHelper.height(targetElm) / 2);

                    if (targetNode.$parentNodesScope.accept(scope, targetNode.index())) {
                      if (targetBefore) {
                        targetElm[0].parentNode.insertBefore(placeElm[0], targetElm[0]);
                        dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.siblings(), targetNode.index());
                      } else {
                        targetElm.after(placeElm);
                        dragInfo.moveTo(targetNode.$parentNodesScope, targetNode.siblings(), targetNode.index() + 1);
                      }
                    } else if (!targetBefore && targetNode.accept(scope, targetNode.childNodesCount())) { // we have to check if it can add the dragging node as a child
                      targetNode.$childNodesScope.$element.append(placeElm);
                      dragInfo.moveTo(targetNode.$childNodesScope, targetNode.childNodes(), targetNode.childNodesCount());
                    } else {
                      outOfBounds = true;
                    }
                  }
                }

                scope.$apply(function () {
                  scope.$treeScope.$callbacks.dragMove(dragInfo.eventArgs(elements, pos));
                });
              }
            };

            dragEnd = function (e) {

              e.preventDefault();

              if (dragElm) {
                scope.$treeScope.$apply(function () {
                  scope.$treeScope.$callbacks.beforeDrop(dragInfo.eventArgs(elements, pos));
                });
                // roll back elements changed
                hiddenPlaceElm.replaceWith(scope.$element);
                placeElm.remove();

                dragElm.remove();
                dragElm = null;
                if (scope.$$apply && !outOfBounds) {
                  scope.$treeScope.$apply(function () {
                    dragInfo.apply();
                    scope.$treeScope.$callbacks.dropped(dragInfo.eventArgs(elements, pos));
                  });
                } else {
                  bindDrag();
                }
                scope.$treeScope.$apply(function () {
                  scope.$treeScope.$callbacks.dragStop(dragInfo.eventArgs(elements, pos));
                });
                scope.$$apply = false;
                dragInfo = null;
              }

              // Restore cursor in Opera 12.16 and IE
              var oldCur = document.body.getAttribute('ui-tree-cursor');
              if (oldCur !== null) {
                $document.find('body').css({'cursor': oldCur});
                document.body.removeAttribute('ui-tree-cursor');
              }

              angular.element($document).unbind('touchend', dragEndEvent); // Mobile
              angular.element($document).unbind('touchcancel', dragEndEvent); // Mobile
              angular.element($document).unbind('touchmove', dragMoveEvent); // Mobile
              angular.element($document).unbind('mouseup', dragEndEvent);
              angular.element($document).unbind('mousemove', dragMoveEvent);
              angular.element($window.document.body).unbind('mouseleave', dragCancelEvent);
            };

            dragStartEvent = function (e) {
              if (scope.dragEnabled()) {
                dragStart(e);
              }
            };

            dragMoveEvent = function (e) {
              dragMove(e);
            };

            dragEndEvent = function (e) {
              scope.$$apply = true;
              dragEnd(e);
            };

            dragCancelEvent = function (e) {
              dragEnd(e);
            };

            dragDelay = (function () {
              var to;

              return {
                exec: function (fn, ms) {
                  if (!ms) {
                    ms = 0;
                  }
                  this.cancel();
                  to = $timeout(fn, ms);
                },
                cancel: function () {
                  $timeout.cancel(to);
                }
              };
            })();

            bindDrag = function () {
              element.bind('touchstart mousedown', function (e) {
                dragDelay.exec(function () {
                  dragStartEvent(e);
                }, scope.dragDelay || 0);
              });
              element.bind('touchend touchcancel mouseup', function () {
                dragDelay.cancel();
              });
            };
            bindDrag();

            keydownHandler = function (e) {
              if (e.keyCode == 27) {
                scope.$$apply = false;
                dragEnd(e);
              }
            };

            angular.element($window.document.body).bind('keydown', keydownHandler);

            //unbind handler that retains scope
            scope.$on('$destroy', function () {
              angular.element($window.document.body).unbind('keydown', keydownHandler);
            });
          }
        };
      }
    ]);

})();

(function () {
  'use strict';

  angular.module('ui.tree')
    .directive('uiTreeNodes', ['treeConfig', '$window',
      function (treeConfig) {
        return {
          require: ['ngModel', '?^uiTreeNode', '^uiTree'],
          restrict: 'A',
          scope: true,
          controller: 'TreeNodesController',
          link: function (scope, element, attrs, controllersArr) {

            var config = {},
                ngModel = controllersArr[0],
                treeNodeCtrl = controllersArr[1],
                treeCtrl = controllersArr[2];

            angular.extend(config, treeConfig);
            if (config.nodesClass) {
              element.addClass(config.nodesClass);
            }

            if (treeNodeCtrl) {
              treeNodeCtrl.scope.$childNodesScope = scope;
              scope.$nodeScope = treeNodeCtrl.scope;
            } else {
              // find the root nodes if there is no parent node and have a parent ui-tree
              treeCtrl.scope.$nodesScope = scope;
            }
            scope.$treeScope = treeCtrl.scope;

            if (ngModel) {
              ngModel.$render = function () {
                scope.$modelValue = ngModel.$modelValue;
              };
            }

            scope.$watch(attrs.maxDepth, function (val) {
              if ((typeof val) == 'number') {
                scope.maxDepth = val;
              }
            });

            scope.$watch(function () {
              return attrs.nodropEnabled;
            }, function (newVal) {
              if ((typeof newVal) != 'undefined') {
                scope.nodropEnabled = true;
              }
            }, true);

            attrs.$observe('horizontal', function (val) {
              scope.horizontal = ((typeof val) != 'undefined');
            });

          }
        };
      }
    ]);
})();

(function () {
  'use strict';

  angular.module('ui.tree')

  /**
   * @ngdoc service
   * @name ui.tree.service:UiTreeHelper
   * @requires ng.$document
   * @requires ng.$window
   *
   * @description
   * angular-ui-tree.
   */
    .factory('UiTreeHelper', ['$document', '$window',
      function ($document, $window) {
        return {

          /**
           * A hashtable used to storage data of nodes
           * @type {Object}
           */
          nodesData: {},

          setNodeAttribute: function (scope, attrName, val) {
            if (!scope.$modelValue) {
              return null;
            }
            var data = this.nodesData[scope.$modelValue.$$hashKey];
            if (!data) {
              data = {};
              this.nodesData[scope.$modelValue.$$hashKey] = data;
            }
            data[attrName] = val;
          },

          getNodeAttribute: function (scope, attrName) {
            if (!scope.$modelValue) {
              return null;
            }
            var data = this.nodesData[scope.$modelValue.$$hashKey];
            if (data) {
              return data[attrName];
            }
            return null;
          },

          /**
           * @ngdoc method
           * @methodOf ui.tree.service:$nodrag
           * @param  {Object} targetElm angular element
           * @return {Bool} check if the node can be dragged.
           */
          nodrag: function (targetElm) {
            if (typeof targetElm.attr('data-nodrag') != 'undefined') {
              return targetElm.attr('data-nodrag') !== 'false';
            }
            return false;
          },

          /**
           * get the event object for touches
           * @param  {[type]} e [description]
           * @return {[type]}   [description]
           */
          eventObj: function (e) {
            var obj = e;
            if (e.targetTouches !== undefined) {
              obj = e.targetTouches.item(0);
            } else if (e.originalEvent !== undefined && e.originalEvent.targetTouches !== undefined) {
              obj = e.originalEvent.targetTouches.item(0);
            }
            return obj;
          },

          dragInfo: function (node) {
            return {
              source: node,
              sourceInfo: {
                cloneModel: node.$treeScope.cloneEnabled === true ? angular.copy(node.$modelValue) : undefined,
                nodeScope: node,
                index: node.index(),
                nodesScope: node.$parentNodesScope
              },
              index: node.index(),
              siblings: node.siblings().slice(0),
              parent: node.$parentNodesScope,

              // Move the node to a new position
              moveTo: function (parent, siblings, index) {
                this.parent = parent;
                this.siblings = siblings.slice(0);

                // If source node is in the target nodes
                var i = this.siblings.indexOf(this.source);
                if (i > -1) {
                  this.siblings.splice(i, 1);
                  if (this.source.index() < index) {
                    index--;
                  }
                }

                this.siblings.splice(index, 0, this.source);
                this.index = index;
              },

              parentNode: function () {
                return this.parent.$nodeScope;
              },

              prev: function () {
                if (this.index > 0) {
                  return this.siblings[this.index - 1];
                }

                return null;
              },

              next: function () {
                if (this.index < this.siblings.length - 1) {
                  return this.siblings[this.index + 1];
                }

                return null;
              },

              isClone: function () {
                return this.source.$treeScope.cloneEnabled === true;
              },

              clonedNode: function (node) {
                return angular.copy(node);
              },

              isDirty: function () {
                return this.source.$parentNodesScope != this.parent ||
                  this.source.index() != this.index;
              },

              isForeign: function () {
                return this.source.$treeScope !== this.parent.$treeScope;
              },

              eventArgs: function (elements, pos) {
                return {
                  source: this.sourceInfo,
                  dest: {
                    index: this.index,
                    nodesScope: this.parent
                  },
                  elements: elements,
                  pos: pos
                };
              },

              apply: function () {

                var nodeData = this.source.$modelValue;

                // nodrop enabled on tree or parent
                if (this.parent.nodropEnabled || this.parent.$treeScope.nodropEnabled) {
                  return;
                }

                // node was dropped in the same place - do nothing
                if (!this.isDirty()) {
                  return;
                }

                // cloneEnabled and cross-tree so copy and do not remove from source
                if (this.isClone() && this.isForeign()) {
                  this.parent.insertNode(this.index, angular.copy(nodeData));
                } else { // Any other case, remove and reinsert
                  this.source.remove();
                  this.parent.insertNode(this.index, nodeData);
                }
              }
            };
          },

          /**
           * @ngdoc method
           * @name ui.tree#height
           * @methodOf ui.tree.service:UiTreeHelper
           *
           * @description
           * Get the height of an element.
           *
           * @param {Object} element Angular element.
           * @returns {String} Height
           */
          height: function (element) {
            return element.prop('scrollHeight');
          },

          /**
           * @ngdoc method
           * @name ui.tree#width
           * @methodOf ui.tree.service:UiTreeHelper
           *
           * @description
           * Get the width of an element.
           *
           * @param {Object} element Angular element.
           * @returns {String} Width
           */
          width: function (element) {
            return element.prop('scrollWidth');
          },

          /**
           * @ngdoc method
           * @name ui.tree#offset
           * @methodOf ui.nestedSortable.service:UiTreeHelper
           *
           * @description
           * Get the offset values of an element.
           *
           * @param {Object} element Angular element.
           * @returns {Object} Object with properties width, height, top and left
           */
          offset: function (element) {
            var boundingClientRect = element[0].getBoundingClientRect();

            return {
              width: element.prop('offsetWidth'),
              height: element.prop('offsetHeight'),
              top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
              left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft || $document[0].documentElement.scrollLeft)
            };
          },

          /**
           * @ngdoc method
           * @name ui.tree#positionStarted
           * @methodOf ui.tree.service:UiTreeHelper
           *
           * @description
           * Get the start position of the target element according to the provided event properties.
           *
           * @param {Object} e Event
           * @param {Object} target Target element
           * @returns {Object} Object with properties offsetX, offsetY, startX, startY, nowX and dirX.
           */
          positionStarted: function (e, target) {
            var pos = {},
              pageX = e.pageX,
              pageY = e.pageY;

            if (e.originalEvent && e.originalEvent.touches && (e.originalEvent.touches.length > 0)) {
              pageX = e.originalEvent.touches[0].pageX;
              pageY = e.originalEvent.touches[0].pageY;
            }
            pos.offsetX = pageX - this.offset(target).left;
            pos.offsetY = pageY - this.offset(target).top;
            pos.startX = pos.lastX = pageX;
            pos.startY = pos.lastY = pageY;
            pos.nowX = pos.nowY = pos.distX = pos.distY = pos.dirAx = 0;
            pos.dirX = pos.dirY = pos.lastDirX = pos.lastDirY = pos.distAxX = pos.distAxY = 0;
            return pos;
          },

          positionMoved: function (e, pos, firstMoving) {
            var pageX = e.pageX,
              pageY = e.pageY,
              newAx;
            if (e.originalEvent && e.originalEvent.touches && (e.originalEvent.touches.length > 0)) {
              pageX = e.originalEvent.touches[0].pageX;
              pageY = e.originalEvent.touches[0].pageY;
            }
            // mouse position last events
            pos.lastX = pos.nowX;
            pos.lastY = pos.nowY;

            // mouse position this events
            pos.nowX = pageX;
            pos.nowY = pageY;

            // distance mouse moved between events
            pos.distX = pos.nowX - pos.lastX;
            pos.distY = pos.nowY - pos.lastY;

            // direction mouse was moving
            pos.lastDirX = pos.dirX;
            pos.lastDirY = pos.dirY;

            // direction mouse is now moving (on both axis)
            pos.dirX = pos.distX === 0 ? 0 : pos.distX > 0 ? 1 : -1;
            pos.dirY = pos.distY === 0 ? 0 : pos.distY > 0 ? 1 : -1;

            // axis mouse is now moving on
            newAx = Math.abs(pos.distX) > Math.abs(pos.distY) ? 1 : 0;

            // do nothing on first move
            if (firstMoving) {
              pos.dirAx = newAx;
              pos.moving = true;
              return;
            }

            // calc distance moved on this axis (and direction)
            if (pos.dirAx !== newAx) {
              pos.distAxX = 0;
              pos.distAxY = 0;
            } else {
              pos.distAxX += Math.abs(pos.distX);
              if (pos.dirX !== 0 && pos.dirX !== pos.lastDirX) {
                pos.distAxX = 0;
              }

              pos.distAxY += Math.abs(pos.distY);
              if (pos.dirY !== 0 && pos.dirY !== pos.lastDirY) {
                pos.distAxY = 0;
              }
            }

            pos.dirAx = newAx;
          }
        };
      }

    ]);

})();
;
/*!
LICENSE-START
 * The MIT License

 * Copyright (c) 2013 Localytics http://www.localytics.com

 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
LICENSE-END
 */
/**
 * angular-chosen-localytics - Angular Chosen directive is an AngularJS Directive that brings the Chosen jQuery in a Angular way
 * @version v1.5.0
 * @link http://github.com/leocaseiro/angular-chosen
 * @license MIT
 */
(function() {
    var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

    angular.module('localytics.directives', []);

    angular.module('localytics.directives').directive('chosen', [
        '$timeout', function($timeout) {
            var CHOSEN_OPTION_WHITELIST, NG_OPTIONS_REGEXP, isEmpty, snakeCase;
            NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
            CHOSEN_OPTION_WHITELIST = ['persistentCreateOption', 'createOptionText', 'createOption', 'skipNoResults', 'noResultsText', 'allowSingleDeselect', 'disableSearchThreshold', 'disableSearch', 'enableSplitWordSearch', 'inheritSelectClasses', 'maxSelectedOptions', 'placeholderTextMultiple', 'placeholderTextSingle', 'searchContains', 'singleBackstrokeDelete', 'displayDisabledOptions', 'displaySelectedOptions', 'width', 'includeGroupLabelInSelected', 'maxShownResults'];
            snakeCase = function(input) {
                return input.replace(/[A-Z]/g, function($1) {
                    return "_" + ($1.toLowerCase());
                });
            };
            isEmpty = function(value) {
                var key;
                if (angular.isArray(value)) {
                    return value.length === 0;
                } else if (angular.isObject(value)) {
                    for (key in value) {
                        if (value.hasOwnProperty(key)) {
                            return false;
                        }
                    }
                }
                return true;
            };
            return {
                restrict: 'A',
                require: '?ngModel',
                priority: 1,
                link: function(scope, element, attr, ngModel) {
                    var chosen, empty, initOrUpdate, match, options, origRender, startLoading, stopLoading, updateMessage, valuesExpr, viewWatch;
                    // custom - Elements
                    var previousResult,
                        previousLastId = 0,
                        currentLastId = null,
                        pageNumber = 1,
                        parent, chosenRes, searchString = "",
                        debounceTimer;
                    // end custom
                    scope.disabledValuesHistory = scope.disabledValuesHistory ? scope.disabledValuesHistory : [];
                    element = $(element);
                    element.addClass('localytics-chosen');
                    options = scope.$eval(attr.chosen) || {};
                    angular.forEach(attr, function(value, key) {
                        if (indexOf.call(CHOSEN_OPTION_WHITELIST, key) >= 0) {
                            return attr.$observe(key, function(value) {
                                var prefix;
                                prefix = String(element.attr(attr.$attr[key])).slice(0, 2);
                                options[snakeCase(key)] = prefix === '{{' ? value : scope.$eval(value);
                                return updateMessage();
                            });
                        }
                    });
                    startLoading = function() {
                        return element.addClass('loading').attr('disabled', true).trigger('chosen:updated');
                    };
                    stopLoading = function() {
                        element.removeClass('loading');
                        if (angular.isDefined(attr.disabled)) {
                            element.attr('disabled', attr.disabled);
                        } else {
                            element.attr('disabled', false);
                        }
                        return element.trigger('chosen:updated');
                    };
                    chosen = null;
                    empty = false;
                    initOrUpdate = function() {
                        var defaultText, dropListDom;
                        if (chosen) {
                            dropListDom = $(element.parent()).find("div.chosen-drop");
                            if (dropListDom && dropListDom.length > 0 && dropListDom.css("left").indexOf("0") >= 0) {
                                return;
                            }
                            return element.trigger('chosen:updated');
                        } else {
                            scope.$evalAsync(function() {
                                chosen = element.chosen(options).data('chosen');

                                // custom - Elements
                                //when we need to update the list call this
                                var updateList = function() {
                                    previousScrollPos = chosenRes.scrollTop;
                                    var dataFunction = scope.$eval(attr.updateFn);

                                    //call the function and pass in page number and searchString as parameters
                                    if (dataFunction) {

                                        var selectedItem = $(element[0]).find('.highlighted');
                                        chosen.isPaging = true;

                                        dataFunction(pageNumber, searchString).then(function() {
                                            //After getting promise, remove loading and show results
                                            chosen.results_loaded = true;

                                            //get current results from search
                                            var results = scope.$eval(attr.ngOptions.match(NG_OPTIONS_REGEXP)[7]);

                                            //if the results from the previous search match the results form the current search then stop loading
                                            if(angular.equals(results, previousResult)) {
                                                stopLoading();
                                            }

                                            //store current search results
                                            previousResult = results.slice();
                                            previousLastId = currentLastId;

                                            //increment page number
                                            pageNumber++;
                                        });

                                    }
                                };

                                if (!(chosen.dynamic_search === undefined || chosen.dynamic_search === false)) {
                                    //get parent node
                                    parent = element[0].parentNode;
                                    //get the scrollable element
                                    chosenRes = parent.getElementsByClassName("chosen-results")[0];

                                    if (parent.getElementsByClassName("chosen-search").length > 0) {
                                        chosen.sb = parent.getElementsByClassName("chosen-search")[0].getElementsByTagName('input')[0];
                                    } else if (parent.getElementsByClassName("search-field").length > 0) {
                                        chosen.sb = parent.getElementsByClassName("search-field")[0].getElementsByTagName('input')[0];
                                    }
                                    //store previous scroll position
                                    var previousScrollPos;

                                    //update list for the first time
                                    updateList();

                                    //bind to scroll event
                                    angular.element(chosenRes).scroll(function() {
                                        //get scroll position
                                        var scrollPosition = chosenRes.scrollTop + chosenRes.offsetHeight;

                                        //get bottom of list
                                        var scrollHeight = chosenRes.scrollHeight;

                                        //check if we need to page
                                        if (scrollPosition + 1 >= scrollHeight) {
                                            //Check if there are more values to be loaded
                                            currentLastId = chosen.search_count;

                                            //if we dont need to request again or we have reached the bottom then do nothing
                                            if (previousLastId === currentLastId) return;
                                            chosen.results_loaded = false;
                                            element.addClass("loading");

                                            //update list
                                            updateList();
                                        }
                                    });

                                    //bind to text change event
                                    if (chosen.sb) {
                                        chosen.sb.addEventListener('input', function(e) {
                                            //store search string
                                            searchString = chosen.sb.value;
                                            chosen.search_text = searchString;
                                            chosen.search_results.hide();
                                            chosen.results_loaded = false;
                                            if (chosen.results_data[0] !== undefined && !chosen.results_data[0].empty) {
                                                element.addClass("loading");
                                            }

                                            //To prevent repeated calls to update while user is typing
                                            var debounce = function() {
                                                //reset the values
                                                pageNumber = 1;
                                                previousLastId = 0;
                                                currentLastId = null;

                                                //update the list
                                                updateList();
                                            };

                                            clearTimeout(debounceTimer);
                                            //call updateList only if search string does not change in 800ms
                                            debounceTimer = setTimeout(debounce, 800);
                                        });
                                    }
                                }
                                // end custom
                            });
                            if (angular.isObject(chosen)) {
                                return defaultText = chosen.default_text;
                            }
                        }
                    };
                    updateMessage = function() {
                        if (chosen && empty) {
                            element.attr('data-placeholder', chosen.results_none_found).attr('disabled', true);
                        } else {
                            element.removeAttr('data-placeholder');
                        }
                        return element.trigger('chosen:updated');
                    };
                    if (ngModel) {
                        origRender = ngModel.$render;
                        ngModel.$render = function() {
                            origRender();
                            return initOrUpdate();
                        };
                        element.on('chosen:hiding_dropdown', function() {
                            return scope.$apply(function() {
                                return ngModel.$setTouched();
                            });
                        });
                        if (attr.multiple) {
                            viewWatch = function() {
                                return ngModel.$viewValue;
                            };
                            scope.$watch(viewWatch, ngModel.$render, true);
                        }
                    } else {
                        initOrUpdate();
                    }
                    attr.$observe('disabled', function() {
                        return element.trigger('chosen:updated');
                    });
                    if (attr.ngOptions && ngModel) {
                        match = attr.ngOptions.match(NG_OPTIONS_REGEXP);
                        valuesExpr = match[7];
                        scope.$watchCollection(valuesExpr, function(newVal, oldVal) {
                            var timer;
                            return timer = $timeout(function() {
                                if (angular.isUndefined(newVal)) {
                                    return startLoading();
                                } else {
                                    empty = isEmpty(newVal);
                                    stopLoading();
                                    return updateMessage();
                                }
                            });
                        });
                        return scope.$on('$destroy', function(event) {
                            if (typeof timer !== "undefined" && timer !== null) {
                                return $timeout.cancel(timer);
                            }
                        });
                    }
                }
            };
        }
    ]);

}).call(this);
;
(function(){
	angular.module("hpe.elements.d3",[]);
})();;
(function () {
angular
	.module("hpe.elements.d3")
	.factory('d3', ['$window', function($window) {
			return $window.d3;
	}]);
})();;
/*!
The MIT License (MIT)

Copyright (c) 2014 ServerGrove

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

'use strict';

/**
 * Module to use Switchery as a directive for angular.
 * @TODO implement Switchery as a service, https://github.com/abpetkov/switchery/pull/11
 */
angular.module('NgSwitchery', [])
    .directive('uiSwitch', ['$window', '$timeout','$log', '$parse', function($window, $timeout, $log, $parse) {

        /**
         * Initializes the HTML element as a Switchery switch.
         *
         * $timeout is in place as a workaround to work within angular-ui tabs.
         *
         * @param scope
         * @param elem
         * @param attrs
         * @param ngModel
         */
        function linkSwitchery(scope, elem, attrs, ngModel) {
            if(!ngModel) return false;
            var options = {};
            try {
                options = $parse(attrs.uiSwitch)(scope);
            }
            catch (e) {}

            var switcher;

            attrs.$observe('disabled', function(value) {
              if (!switcher) {
                return;
              }

              if (value) {
                switcher.disable();
              }
              else {
                switcher.enable();
              }
            });

  
            function initializeSwitch() {
              $timeout(function() {
                // Remove any old switcher
                if (switcher) {
                  angular.element(switcher.switcher).remove();
                }
                // (re)create switcher to reflect latest state of the checkbox element
                switcher = new $window.Switchery(elem[0], options);
                var element = switcher.element;
                element.checked = scope.initValue;
                if (attrs.disabled) {
                  switcher.disable();
                }

                switcher.setPosition(false);

                scope.$watch(function() {
                    return ngModel.$modelValue;
                }, function(value) {
                      ngModel.$setViewValue(element.checked);
                    
                      if (document.createEvent && element.dispatchEvent) {
                          var evt = document.createEvent("HTMLEvents");
                          evt.initEvent("change", true, true);
                          element.dispatchEvent(evt); // for DOM-compliant browsers
                      } else if (element.fireEvent) {
                          element.fireEvent("onchange"); // for IE old 
                      }

                });

                element.addEventListener('change',function(evt) {
                    
                        ngModel.$setViewValue(element.checked);
                    
                })
              }, 0);
            }
            initializeSwitch();
          }

        return {
            require: 'ngModel',
            restrict: 'AE',
            scope : {
              initValue : '=ngModel'
            },
            link: linkSwitchery
        }
    }]);
;
/*!
LICENSE-START
 * ngTagsInput v3.0.0
 * http://mbenford.github.io/ngTagsInput
 *
 * Copyright (c) 2013-2015 Michael Benford
 * License: MIT
 *
 * Generated at 2015-07-13 02:08:11 -0300
LICENSE-END
 */
(function() {
'use strict';

var KEYS = {
    backspace: 8,
    tab: 9,
    enter: 13,
    escape: 27,
    space: 32,
    up: 38,
    down: 40,
    left: 37,
    right: 39,
    delete: 46,
    comma: 188
};

var MAX_SAFE_INTEGER = 9007199254740991;
var SUPPORTED_INPUT_TYPES = ['text', 'email', 'url'];

var tagsInput = angular.module('ngTagsInput', []);

tagsInput.directive('tagsInput', ["$timeout", "$document", "$window", "tagsInputConfig", "tiUtil", function($timeout, $document, $window, tagsInputConfig, tiUtil) {
    function TagList(options, events, onTagAdding, onTagRemoving) {
        var self = {}, getTagText, setTagText, tagIsValid;

        getTagText = function(tag) {
            return tiUtil.safeToString(tag[options.displayProperty]);
        };

        setTagText = function(tag, text) {
            tag[options.displayProperty] = text;
        };

        tagIsValid = function(tag) {
            var tagText = getTagText(tag);

            return tagText &&
                   tagText.length >= options.minLength &&
                   tagText.length <= options.maxLength &&
                   options.allowedTagsPattern.test(tagText) &&
                   !tiUtil.findInObjectArray(self.items, tag, options.keyProperty || options.displayProperty) &&
                   onTagAdding({ $tag: tag });
        };

        self.items = [];

        self.addText = function(text) {
            var tag = {};
            setTagText(tag, text);
            return self.add(tag);
        };

        self.add = function(tag) {
            var tagText = getTagText(tag);

            if (options.replaceSpacesWithDashes) {
                tagText = tiUtil.replaceSpacesWithDashes(tagText);
            }

            setTagText(tag, tagText);

            if (tagIsValid(tag)) {
                self.items.push(tag);
                events.trigger('tag-added', { $tag: tag });
            }
            else if (tagText) {
                events.trigger('invalid-tag', { $tag: tag });
            }

            return tag;
        };

        self.remove = function(index) {
            var tag = self.items[index];

            if (onTagRemoving({ $tag: tag }))  {
                self.items.splice(index, 1);
                self.clearSelection();
                events.trigger('tag-removed', { $tag: tag });
                return tag;
            }
        };

        self.select = function(index) {
            if (index < 0) {
                index = self.items.length - 1;
            }
            else if (index >= self.items.length) {
                index = 0;
            }

            self.index = index;
            self.selected = self.items[index];
        };

        self.selectPrior = function() {
            self.select(--self.index);
        };

        self.selectNext = function() {
            self.select(++self.index);
        };

        self.removeSelected = function() {
            return self.remove(self.index);
        };

        self.clearSelection = function() {
            self.selected = null;
            self.index = -1;
        };

        self.clearSelection();

        return self;
    }

    function validateType(type) {
        return SUPPORTED_INPUT_TYPES.indexOf(type) !== -1;
    }

    return {
        restrict: 'E',
        require: 'ngModel',
        scope: {
            tags: '=ngModel',
            text: '=?',
            onTagAdding: '&',
            onTagAdded: '&',
            onInvalidTag: '&',
            onTagRemoving: '&',
            onTagRemoved: '&',
            onTagClicked: '&'
        },
        replace: false,
        transclude: true,
        templateUrl: 'ngTagsInput/tags-input.html',
        controller: ["$scope", "$attrs", "$element", function($scope, $attrs, $element) {
            $scope.events = tiUtil.simplePubSub();

            tagsInputConfig.load('tagsInput', $scope, $attrs, {
                template: [String, 'ngTagsInput/tag-item.html'],
                type: [String, 'text', validateType],
                placeholder: [String, 'Add a tag'],
                tabindex: [Number, null],
                removeTagSymbol: [String, String.fromCharCode(215)],
                replaceSpacesWithDashes: [Boolean, true],
                minLength: [Number, 3],
                maxLength: [Number, MAX_SAFE_INTEGER],
                addOnEnter: [Boolean, true],
                addOnSpace: [Boolean, false],
                addOnComma: [Boolean, true],
                addOnBlur: [Boolean, true],
                addOnPaste: [Boolean, false],
                pasteSplitPattern: [RegExp, /,/],
                allowedTagsPattern: [RegExp, /.+/],
                enableEditingLastTag: [Boolean, false],
                minTags: [Number, 0],
                maxTags: [Number, MAX_SAFE_INTEGER],
                displayProperty: [String, 'text'],
                keyProperty: [String, ''],
                allowLeftoverText: [Boolean, false],
                addFromAutocompleteOnly: [Boolean, false],
                spellcheck: [Boolean, true],
                maxTagsHidden: [Boolean, false]
            });

            $scope.tagList = new TagList($scope.options, $scope.events,
                tiUtil.handleUndefinedResult($scope.onTagAdding, true),
                tiUtil.handleUndefinedResult($scope.onTagRemoving, true));

            this.registerAutocomplete = function() {
                var input = $element.find('input');

                return {
                    addTag: function(tag) {
                        return $scope.tagList.add(tag);
                    },
                    focusInput: function() {
                        input[0].focus();
                    },
                    getTags: function() {
                        return $scope.tagList.items;
                    },
                    getCurrentTagText: function() {
                        return $scope.newTag.text();
                    },
                    getOptions: function() {
                        return $scope.options;
                    },
                    on: function(name, handler) {
                        $scope.events.on(name, handler);
                        return this;
                    }
                };
            };

            this.registerTagItem = function() {
                return {
                    getOptions: function() {
                        return $scope.options;
                    },
                    removeTag: function(index) {
                        if ($scope.disabled) {
                            return;
                        }
                        $scope.tagList.remove(index);
                    }
                };
            };
        }],
        link: function(scope, element, attrs, ngModelCtrl) {
            var hotkeys = [KEYS.enter, KEYS.comma, KEYS.space, KEYS.backspace, KEYS.delete, KEYS.left, KEYS.right],
                tagList = scope.tagList,
                events = scope.events,
                options = scope.options,
                input = element.find('input'),
                validationOptions = ['minTags', 'maxTags', 'allowLeftoverText'],
                placeholderOriginal = options.placeholder,
                setElementValidity;

            setElementValidity = function() {
                ngModelCtrl.$setValidity('maxTags', tagList.items.length <= options.maxTags);
                ngModelCtrl.$setValidity('minTags', tagList.items.length >= options.minTags);
                ngModelCtrl.$setValidity('leftoverText', scope.hasFocus || options.allowLeftoverText ? true : !scope.newTag.text());
            };

            ngModelCtrl.$isEmpty = function(value) {
                return !value || !value.length;
            };

            scope.newTag = {
                text: function(value) {
                    if (angular.isDefined(value)) {
                        scope.text = value;
                        events.trigger('input-change', value);
                    }
                    else {
                        return scope.text || '';
                    }
                },
                invalid: null
            };

            scope.track = function(tag) {
                return tag[options.keyProperty || options.displayProperty];
            };

            scope.$watch('tags', function(value) {
                if (value) {
                    tagList.items = tiUtil.makeObjectArray(value, options.displayProperty);
                    scope.tags = tagList.items;
                }
                else {
                    tagList.items = [];
                }
            });

            scope.$watch('tags.length', function() {
                setElementValidity();
                if(options.maxTagsHidden && tagList.items.length >= options.maxTags)
                    options.placeholder = "";
                else if(options.maxTagsHidden)
                    options.placeholder = placeholderOriginal;
                // ngModelController won't trigger validators when the model changes (because it's an array),
                // so we need to do it ourselves. Unfortunately this won't trigger any registered formatter.
                ngModelCtrl.$validate();
            });

            attrs.$observe('disabled', function(value) {
                scope.disabled = value;
            });

            scope.eventHandlers = {
                input: {
                    keydown: function($event) {
                        events.trigger('input-keydown', $event);
                    },
                    focus: function() {
                        if (scope.hasFocus) {
                            return;
                        }

                        scope.hasFocus = true;
                        events.trigger('input-focus');
                    },
                    blur: function() {
                        $timeout(function() {
                            var activeElement = $document.prop('activeElement'),
                                lostFocusToBrowserWindow = activeElement === input[0],
                                lostFocusToChildElement = element[0].contains(activeElement);

                            if (lostFocusToBrowserWindow || !lostFocusToChildElement) {
                                scope.hasFocus = false;
                                events.trigger('input-blur');
                            }
                        });
                    },
                    paste: function($event) {
                        $event.getTextData = function() {
                            var clipboardData = $event.clipboardData || ($event.originalEvent && $event.originalEvent.clipboardData);
                            return clipboardData ? clipboardData.getData('text/plain') : $window.clipboardData.getData('Text');
                        };
                        events.trigger('input-paste', $event);
                    }
                },
                host: {
                    click: function() {
                        if (scope.disabled) {
                            return;
                        }
                        input[0].focus();
                    }
                },
                tag: {
                    click: function(tag) {
                        events.trigger('tag-clicked', { $tag: tag });
                    }
                }
            };

            events
                .on('tag-added', scope.onTagAdded)
                .on('invalid-tag', scope.onInvalidTag)
                .on('tag-removed', scope.onTagRemoved)
                .on('tag-clicked', scope.onTagClicked)
                .on('tag-added', function() {
                    scope.newTag.text('');
                })
                .on('tag-added tag-removed', function() {
                    scope.tags = tagList.items;
                    // Ideally we should be able call $setViewValue here and let it in turn call $setDirty and $validate
                    // automatically, but since the model is an array, $setViewValue does nothing and it's up to us to do it.
                    // Unfortunately this won't trigger any registered $parser and there's no safe way to do it.
                    ngModelCtrl.$setDirty();
                })
                .on('invalid-tag', function() {
                    scope.newTag.invalid = true;
                })
                .on('option-change', function(e) {
                    if (validationOptions.indexOf(e.name) !== -1) {
                        setElementValidity();
                    }
                })
                .on('input-change', function() {
                    tagList.clearSelection();
                    scope.newTag.invalid = null;
                })
                .on('input-focus', function() {
                    element.triggerHandler('focus');
                    ngModelCtrl.$setValidity('leftoverText', true);
                })
                .on('input-blur', function() {
                    if (options.addOnBlur && !options.addFromAutocompleteOnly) {
                        tagList.addText(scope.newTag.text());
                    }
                    element.triggerHandler('blur');
                    setElementValidity();
                })
                .on('input-keydown', function(event) {

                    var key = event.keyCode,
                        addKeys = {},
                        shouldAdd, shouldRemove, shouldSelect, shouldEditLastTag, autocompleteSelected, maxTagsReached;

                    maxTagsReached = options.maxTagsHidden && scope.tags.length >= options.maxTags;
                    
                    if(maxTagsReached){
                        event.preventDefault();
                    }

                    if (tiUtil.isModifierOn(event) || hotkeys.indexOf(key) === -1) {
                        return;
                    }

                    addKeys[KEYS.enter] = options.addOnEnter;
                    addKeys[KEYS.comma] = options.addOnComma;
                    addKeys[KEYS.space] = options.addOnSpace;

                    /*
                    Logic added for Elements
                    ------------------------
                    As safely as possible, look for the autocomplete directive and check if there is a highlighted
                    element. In the case that there is, don't add the entered text.
                    */
                    autocompleteSelected = false;
                    var autocompleteEl = element.find("auto-complete");
                    if (autocompleteEl.length){
                        var acScope = autocompleteEl.scope();
                        if (acScope){
                            var acScopeViewModel = acScope.$$childTail;
                            if (acScopeViewModel){
                                var suggestionList = acScopeViewModel.suggestionList;
                                if (suggestionList){
                                    autocompleteSelected = suggestionList.selected;
                                }
                            }
                        }
                    }
                    //error text colour for autocompleteOnly
                    if(options.addFromAutocompleteOnly && !autocompleteSelected && addKeys[key])
                        scope.newTag.invalid = true;

                    shouldAdd = !options.addFromAutocompleteOnly && !autocompleteSelected && addKeys[key];
                    shouldRemove = (key === KEYS.backspace || key === KEYS.delete) && tagList.selected;
                    shouldEditLastTag = key === KEYS.backspace && scope.newTag.text().length === 0 && options.enableEditingLastTag;
                    shouldSelect = (key === KEYS.backspace || key === KEYS.left || key === KEYS.right) && (scope.newTag.text().length === 0 || options.maxTagsHidden && scope.tags.length >= options.maxTags) && !options.enableEditingLastTag ;
                    
                    
                    if (shouldAdd) {
                        tagList.addText(scope.newTag.text());
                    }
                    else if (shouldEditLastTag) {
                        var tag;

                        tagList.selectPrior();
                        tag = tagList.removeSelected();

                        if (tag) {
                            scope.newTag.text(tag[options.displayProperty]);
                        }
                    }
                    else if (shouldRemove) {
                        tagList.removeSelected();
                    }
                    else if (shouldSelect) {
                        if (key === KEYS.left || key === KEYS.backspace) {
                            tagList.selectPrior();
                        }
                        else if (key === KEYS.right) {
                            tagList.selectNext();
                        }
                    }

                    if (shouldAdd || shouldSelect || shouldRemove || shouldEditLastTag) {
                        event.preventDefault();
                    }
                })
                .on('input-paste', function(event) {
                    if (options.addOnPaste) {
                        var data = event.getTextData();
                        var tags = data.split(options.pasteSplitPattern);

                        if (tags.length > 1) {
                            tags.forEach(function(tag) {
                                tagList.addText(tag);
                            });
                            event.preventDefault();
                        }
                    }
                });
        }
    };
}]);


/**
 * @ngdoc directive
 * @name tiTagItem
 * @module ngTagsInput
 *
 * @description
 * Represents a tag item. Used internally by the tagsInput directive.
 */
tagsInput.directive('tiTagItem', ["tiUtil", function(tiUtil) {
    return {
        restrict: 'E',
        require: '^tagsInput',
        template: '<ng-include src="$$template"></ng-include>',
        scope: { data: '=' },
        link: function(scope, element, attrs, tagsInputCtrl) {
            var tagsInput = tagsInputCtrl.registerTagItem(),
                options = tagsInput.getOptions();

            scope.$$template = options.template;
            scope.$$removeTagSymbol = options.removeTagSymbol;

            scope.$getDisplayText = function() {
                return tiUtil.safeToString(scope.data[options.displayProperty]);
            };
            scope.$removeTag = function() {
                tagsInput.removeTag(scope.$index);
            };

            scope.$watch('$parent.$index', function(value) {
                scope.$index = value;
            });
        }
    };
}]);

tagsInput.directive('autoComplete', ["$document", "$timeout", "$sce", "$q", "tagsInputConfig", "tiUtil", function($document, $timeout, $sce, $q, tagsInputConfig, tiUtil) {
    function SuggestionList(loadFn, options, events) {
        var self = {}, getDifference, lastPromise, getTagId;

        getTagId = function() {
            return options.tagsInput.keyProperty || options.tagsInput.displayProperty;
        };

        getDifference = function(array1, array2) {
            return array1.filter(function(item) {
                return !tiUtil.findInObjectArray(array2, item, getTagId(), function(a, b) {
                    if (options.tagsInput.replaceSpacesWithDashes) {
                        a = tiUtil.replaceSpacesWithDashes(a);
                        b = tiUtil.replaceSpacesWithDashes(b);
                    }
                    return tiUtil.defaultComparer(a, b);
                });
            });
        };

        self.reset = function() {
            lastPromise = null;

            self.items = [];
            self.visible = false;
            self.index = -1;
            self.selected = null;
            self.query = null;
        };
        self.show = function() {
            if (options.selectFirstMatch) {
                self.select(0);
            }
            else {
                self.selected = null;
            }
            self.visible = true;
        };  
        self.load = tiUtil.debounce(function(query, tags) {
            self.query = query;

            var promise = $q.when(loadFn({ $query: query }));
            lastPromise = promise;

            promise.then(function(items) {
                if (promise !== lastPromise) {
                    return;
                }

                items = tiUtil.makeObjectArray(items.data || items, getTagId());
                items = getDifference(items, tags);
                self.items = items.slice(0, options.maxResultsToShow);
                if (self.items.length > 0) {
                    //added for Elements to check if the UI is to be hidden after max tags have been added
                    if(options.tagsInput.maxTagsHidden && tags.length >= options.tagsInput.maxTags)
                        self.reset();
                    else
                        self.show();
                }
                else {
                    self.reset();
                }
            });
        }, options.debounceDelay);

        self.selectNext = function() {
            self.select(++self.index);
        };
        self.selectPrior = function() {
            self.select(--self.index);
        };
        self.select = function(index) {
            if (index < 0) {
                index = self.items.length - 1;
            }
            else if (index >= self.items.length) {
                index = 0;
            }
            self.index = index;
            self.selected = self.items[index];
            events.trigger('suggestion-selected', index);
        };

        self.reset();

        return self;
    }

    function scrollToElement(root, index) {
        var element = root.find('li').eq(index),
            parent = element.parent(),
            elementTop = element.prop('offsetTop'),
            elementHeight = element.prop('offsetHeight'),
            parentHeight = parent.prop('clientHeight'),
            parentScrollTop = parent.prop('scrollTop');

        if (elementTop < parentScrollTop) {
            parent.prop('scrollTop', elementTop);
        }
        else if (elementTop + elementHeight > parentHeight + parentScrollTop) {
            parent.prop('scrollTop', elementTop + elementHeight - parentHeight);
        }
    }

    return {
        restrict: 'E',
        require: '^tagsInput',
        scope: { source: '&' },
        templateUrl: 'ngTagsInput/auto-complete.html',
        controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
            $scope.events = tiUtil.simplePubSub();

            tagsInputConfig.load('autoComplete', $scope, $attrs, {
                template: [String, 'ngTagsInput/auto-complete-match.html'],
                debounceDelay: [Number, 100],
                minLength: [Number, 3],
                highlightMatchedText: [Boolean, true],
                maxResultsToShow: [Number, 10],
                loadOnDownArrow: [Boolean, false],
                loadOnEmpty: [Boolean, false],
                loadOnFocus: [Boolean, false],
                selectFirstMatch: [Boolean, true],
                displayProperty: [String, '']
            });

            $scope.suggestionList = new SuggestionList($scope.source, $scope.options, $scope.events);

            this.registerAutocompleteMatch = function() {
                return {
                    getOptions: function() {
                        return $scope.options;
                    },
                    getQuery: function() {
                        return $scope.suggestionList.query;
                    }
                };
            };
        }],
        link: function(scope, element, attrs, tagsInputCtrl) {
            var hotkeys = [KEYS.enter, KEYS.tab, KEYS.escape, KEYS.up, KEYS.down],
                suggestionList = scope.suggestionList,
                tagsInput = tagsInputCtrl.registerAutocomplete(),
                options = scope.options,
                events = scope.events,
                shouldLoadSuggestions;

            options.tagsInput = tagsInput.getOptions();

            shouldLoadSuggestions = function(value) {
                return value && value.length >= options.minLength || !value && options.loadOnEmpty;
            };

            scope.addSuggestionByIndex = function(index) {
                suggestionList.select(index);
                scope.addSuggestion();
            };

            scope.addSuggestion = function() {
                var added = false;

                if (suggestionList.selected) {
                    tagsInput.addTag(angular.copy(suggestionList.selected));
                    suggestionList.reset();
                    tagsInput.focusInput();

                    added = true;
                }
                return added;
            };

            scope.track = function(item) {
                return item[options.tagsInput.keyProperty || options.tagsInput.displayProperty];
            };

            tagsInput
                .on('tag-added tag-removed invalid-tag input-blur', function() {
                    suggestionList.reset();
                })
                .on('input-change', function(value) {
                    if (shouldLoadSuggestions(value)) {
                        suggestionList.load(value, tagsInput.getTags());
                    }
                    else {
                        suggestionList.reset();
                    }
                })
                .on('input-focus', function() {
                    var value = tagsInput.getCurrentTagText();
                    if (options.loadOnFocus && shouldLoadSuggestions(value)) {
                        suggestionList.load(value, tagsInput.getTags());
                    }
                })
                .on('input-keydown', function(event) {
                    var key = event.keyCode,
                        handled = false;

                    if (tiUtil.isModifierOn(event) || hotkeys.indexOf(key) === -1) {
                        return;
                    }

                    if (suggestionList.visible) {

                        if (key === KEYS.down) {
                            suggestionList.selectNext();
                            handled = true;
                        }
                        else if (key === KEYS.up) {
                            suggestionList.selectPrior();
                            handled = true;
                        }
                        else if (key === KEYS.escape) {
                            suggestionList.reset();
                            handled = true;
                        }
                        else if (key === KEYS.enter || key === KEYS.tab) {
                            handled = scope.addSuggestion();
                        }
                    }
                    else {
                        if (key === KEYS.down && scope.options.loadOnDownArrow) {
                            suggestionList.load(tagsInput.getCurrentTagText(), tagsInput.getTags());
                            handled = true;
                        }
                    }

                    if (handled) {
                        event.preventDefault();
                        event.stopImmediatePropagation();
                        return false;
                    }
                });

            events.on('suggestion-selected', function(index) {
                scrollToElement(element, index);
            });
        }
    };
}]);

tagsInput.directive('tiAutocompleteMatch', ["$sce", "tiUtil", function($sce, tiUtil) {
    return {
        restrict: 'E',
        require: '^autoComplete',
        template: '<ng-include src="$$template"></ng-include>',
        scope: { data: '=' },
        link: function(scope, element, attrs, autoCompleteCtrl) {
            var autoComplete = autoCompleteCtrl.registerAutocompleteMatch(),
                options = autoComplete.getOptions();

            scope.$$template = options.template;
            scope.$index = scope.$parent.$index;

            scope.$highlight = function(text) {
                if (options.highlightMatchedText) {
                    text = tiUtil.safeHighlight(text, autoComplete.getQuery());
                }
                return $sce.trustAsHtml(text);
            };
            scope.$getDisplayText =  function() {
                return tiUtil.safeToString(scope.data[options.displayProperty || options.tagsInput.displayProperty]);
            };
        }
    };
}]);

tagsInput.directive('tiTranscludeAppend', function() {
    return function(scope, element, attrs, ctrl, transcludeFn) {
        transcludeFn(function(clone) {
            element.append(clone);
        });
    };
});

tagsInput.directive('tiAutosize', ["tagsInputConfig", function(tagsInputConfig) {
    return {
        restrict: 'A',
        require: 'ngModel',
        link: function(scope, element, attrs, ctrl) {
            var threshold = tagsInputConfig.getTextAutosizeThreshold(),
                span, resize;

            span = angular.element('<span class="input"></span>');
            span.css('display', 'none')
                .css('visibility', 'hidden')
                .css('width', 'auto')
                .css('white-space', 'pre');

            element.parent().append(span);

            resize = function(originalValue) {
                var value = originalValue, width;

                if (angular.isString(value) && value.length === 0) {
                    value = attrs.placeholder;
                }

                if (value) {
                    span.text(value);
                    span.css('display', '');
                    width = span.prop('offsetWidth');
                    span.css('display', 'none');
                }
                
                if(scope.options.maxTagsHidden && scope.tags.length >= scope.options.maxTags){
                    element.css('width', 0)
                           .css('padding-left', 0)
                           .css('margin', 0);
                }
                else{
                    element.css('width', width ? width + threshold + 'px' : '');
                    if(scope.options.maxTagsHidden){
                           element.css('padding-left', '5px')
                                  .css('margin', '2px');
                    }
                }

                return originalValue;
            };

            ctrl.$parsers.unshift(resize);
            ctrl.$formatters.unshift(resize);

            attrs.$observe('placeholder', function(value) {
                if (!ctrl.$modelValue) {
                    resize(value);
                }
            });
        }
    };
}]);

tagsInput.directive('tiBindAttrs', function() {
    return function(scope, element, attrs) {
        scope.$watch(attrs.tiBindAttrs, function(value) {
            angular.forEach(value, function(value, key) {
                attrs.$set(key, value);
            });
        }, true);
    };
});

tagsInput.provider('tagsInputConfig', function() {
    var globalDefaults = {},
        interpolationStatus = {},
        autosizeThreshold = 3;

    this.setDefaults = function(directive, defaults) {
        globalDefaults[directive] = defaults;
        return this;
    };

    this.setActiveInterpolation = function(directive, options) {
        interpolationStatus[directive] = options;
        return this;
    };

    this.setTextAutosizeThreshold = function(threshold) {
        autosizeThreshold = threshold;
        return this;
    };

    this.$get = ["$interpolate", function($interpolate) {
        var converters = {};
        converters[String] = function(value) { return value; };
        converters[Number] = function(value) { return parseInt(value, 10); };
        converters[Boolean] = function(value) { return value.toLowerCase() === 'true'; };
        converters[RegExp] = function(value) { return new RegExp(value); };

        return {
            load: function(directive, scope, attrs, options) {
                var defaultValidator = function() { return true; };

                scope.options = {};

                angular.forEach(options, function(value, key) {
                    var type, localDefault, validator, converter, getDefault, updateValue;

                    type = value[0];
                    localDefault = value[1];
                    validator = value[2] || defaultValidator;
                    converter = converters[type];

                    getDefault = function() {
                        var globalValue = globalDefaults[directive] && globalDefaults[directive][key];
                        return angular.isDefined(globalValue) ? globalValue : localDefault;
                    };

                    updateValue = function(value) {
                        scope.options[key] = value && validator(value) ? converter(value) : getDefault();
                    };

                    if (interpolationStatus[directive] && interpolationStatus[directive][key]) {
                        attrs.$observe(key, function(value) {
                            updateValue(value);
                            scope.events.trigger('option-change', { name: key, newValue: value });
                        });
                    }
                    else {
                        updateValue(attrs[key] && $interpolate(attrs[key])(scope.$parent));
                    }
                });
            },
            getTextAutosizeThreshold: function() {
                return autosizeThreshold;
            }
        };
    }];
});

tagsInput.factory('tiUtil', ["$timeout", function($timeout) {
    var self = {};

    self.debounce = function(fn, delay) {
        var timeoutId;
        return function() {
            var args = arguments;
            $timeout.cancel(timeoutId);
            timeoutId = $timeout(function() { fn.apply(null, args); }, delay);
        };
    };

    self.makeObjectArray = function(array, key) {
        if (!angular.isArray(array) || array.length === 0 || angular.isObject(array[0])) {
            return array;
        }

        var newArray = [];
        array.forEach(function(item) {
            var obj = {};
            obj[key] = item;
            newArray.push(obj);
        });
        return newArray;
    };

    self.findInObjectArray = function(array, obj, key, comparer) {
        var item = null;
        comparer = comparer || self.defaultComparer;

        array.some(function(element) {
            if (comparer(element[key], obj[key])) {
                item = element;
                return true;
            }
        });

        return item;
    };

    self.defaultComparer = function(a, b) {
        return self.safeToString(a).toLowerCase() === self.safeToString(b).toLowerCase();
    };

    self.safeHighlight = function(str, value) {
        if (!value) {
            return str;
        }

        function escapeRegexChars(str) {
            return str.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
        }

        str = self.encodeHTML(str);
        value = self.encodeHTML(value);

        var expression = new RegExp('&[^;]+;|' + escapeRegexChars(value), 'gi');
        return str.replace(expression, function(match) {
            return match.toLowerCase() === value.toLowerCase() ? '<em>' + match + '</em>' : match;
        });
    };

    self.safeToString = function(value) {
        return angular.isUndefined(value) || value == null ? '' : value.toString().trim();
    };

    self.encodeHTML = function(value) {
        return self.safeToString(value)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
    };

    self.handleUndefinedResult = function(fn, valueIfUndefined) {
        return function() {
            var result = fn.apply(null, arguments);
            return angular.isUndefined(result) ? valueIfUndefined : result;
        };
    };

    self.replaceSpacesWithDashes = function(str) {
        return self.safeToString(str).replace(/\s/g, '-');
    };

    self.isModifierOn = function(event) {
        return event.shiftKey || event.ctrlKey || event.altKey || event.metaKey;
    };

    self.simplePubSub = function() {
        var events = {};
        return {
            on: function(names, handler) {
                names.split(' ').forEach(function(name) {
                    if (!events[name]) {
                        events[name] = [];
                    }
                    events[name].push(handler);
                });
                return this;
            },
            trigger: function(name, args) {
                var handlers = events[name] || [];
                handlers.every(function(handler) {
                    return self.handleUndefinedResult(handler, true)(args);
                });
                return this;
            }
        };
    };

    return self;
}]);

/* HTML templates */
tagsInput.run(["$templateCache", function($templateCache) {
    $templateCache.put('ngTagsInput/tags-input.html',
    "<div class=\"host\" tabindex=\"-1\" ng-click=\"eventHandlers.host.click()\" ti-transclude-append><div class=\"tags\" ng-class=\"{focused: hasFocus}\"><ul class=\"tag-list\"><li class=\"tag-item\" ng-repeat=\"tag in tagList.items track by track(tag)\" ng-class=\"{ selected: tag == tagList.selected }\" ng-click=\"eventHandlers.tag.click(tag)\"><ti-tag-item data=\"::tag\"></ti-tag-item></li></ul><input class=\"input\" autocomplete=\"off\" ng-model=\"newTag.text\" ng-model-options=\"{getterSetter: true}\" ng-keydown=\"eventHandlers.input.keydown($event)\" ng-focus=\"eventHandlers.input.focus($event)\" ng-blur=\"eventHandlers.input.blur($event)\" ng-paste=\"eventHandlers.input.paste($event)\" ng-trim=\"false\" ng-class=\"{'invalid-tag': newTag.invalid}\" ng-disabled=\"disabled\" ti-bind-attrs=\"{type: options.type, placeholder: options.placeholder, tabindex: options.tabindex, spellcheck: options.spellcheck}\" ti-autosize></div></div>"
  );

  $templateCache.put('ngTagsInput/tag-item.html',
    "<span ng-bind=\"$getDisplayText()\"></span> <a class=\"remove-button\" ng-click=\"$removeTag()\" ng-bind=\"::$$removeTagSymbol\"></a>"
  );

  $templateCache.put('ngTagsInput/auto-complete.html',
    "<div class=\"autocomplete\" ng-if=\"suggestionList.visible\"><ul class=\"suggestion-list\"><li class=\"suggestion-item\" ng-repeat=\"item in suggestionList.items track by track(item)\" ng-class=\"{selected: item == suggestionList.selected}\" ng-click=\"addSuggestionByIndex($index)\" ng-mouseenter=\"suggestionList.select($index)\"><ti-autocomplete-match data=\"::item\"></ti-autocomplete-match></li></ul></div>"
  );

  $templateCache.put('ngTagsInput/auto-complete-match.html',
    "<span ng-bind-html=\"$highlight($getDisplayText())\"></span>"
  );
}]);

}());;
(function(){
	angular.module("hpe.elements.sigma",[]);
})();;
(function () {
angular
	.module("hpe.elements.sigma")
	.factory('sigma', ['$window', function($window) {
		if (!$window.sigma.classes.graph.hasMethod('neighbors')){
			$window.sigma.classes.graph.addMethod('neighbors', function(nodeId) {
	          var k,
	              neighbors = {},
	              index = this.allNeighborsIndex[nodeId] || {};

	          for (k in index)
	            neighbors[k] = this.nodesIndex[k];

	          return neighbors;
	        });
		}

		if (!$window.sigma.classes.graph.hasMethod('nodeEdges')){
			$window.sigma.classes.graph.addMethod('nodeEdges', function(nodeId) {
	          var k,j,
	              neighbors = {},
	              edges = {}
	              index = this.allNeighborsIndex[nodeId] || {};

	          for (k in index){
	            neighbors[k] = this.nodesIndex[k];
	          }

	          for(j in neighbors){
	          	edges[j] = this.allNeighborsIndex[nodeId][j];
	          }

	          return edges;

	        });
		}

		return $window.sigma;
	}]);
})();;
//HPE Elements - Modifications
// - close any modals on state change
// - option changeTotalTime in timepicker and addition of logic in addMinutes method
// - In datepicker if backspace is pressed when it is open, do not navigate back
/*!
LICENSE-START
 * angular-ui-bootstrap
 * http://angular-ui.github.io/bootstrap/

 * Version: 0.13.0 - 2015-05-02
 * License: MIT
 The MIT License

Copyright (c) 2012-2015 the AngularUI Team, https://github.com/organizations/angular-ui/teams/291112

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
LICENSE-END
 */
angular.module("ui.bootstrap", ["ui.bootstrap.tpls", "ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.bindHtml","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.dateparser","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdown","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.transition","ui.bootstrap.typeahead"]);
angular.module("ui.bootstrap.tpls", ["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/day.html","template/datepicker/month.html","template/datepicker/popup.html","template/datepicker/year.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-popup.html","template/tooltip/tooltip-html-unsafe-popup.html","template/tooltip/tooltip-popup.html","template/tooltip/tooltip-template-popup.html","template/popover/popover-template.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/progressbar/progressbar.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]);
angular.module('ui.bootstrap.collapse', [])

  .directive('collapse', ['$animate', function ($animate) {

    return {
      link: function (scope, element, attrs) {
        function expand() {
          element.removeClass('collapse').addClass('collapsing');
          $animate.addClass(element, 'in', {
            to: { height: element[0].scrollHeight + 'px' }
          }).then(expandDone);
        }

        function expandDone() {
          element.removeClass('collapsing');
          element.css({height: 'auto'});
        }

        function collapse() {
          element
            // IMPORTANT: The height must be set before adding "collapsing" class.
            // Otherwise, the browser attempts to animate from height 0 (in
            // collapsing class) to the given height here.
            .css({height: element[0].scrollHeight + 'px'})
            // initially all panel collapse have the collapse class, this removal
            // prevents the animation from jumping to collapsed state
            .removeClass('collapse')
            .addClass('collapsing');

          $animate.removeClass(element, 'in', {
            to: {height: '0'}
          }).then(collapseDone);
        }

        function collapseDone() {
          element.css({height: '0'}); // Required so that collapse works when animation is disabled
          element.removeClass('collapsing');
          element.addClass('collapse');
        }

        scope.$watch(attrs.collapse, function (shouldCollapse) {
          if (shouldCollapse) {
            collapse();
          } else {
            expand();
          }
        });
      }
    };
  }]);

angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse'])

.constant('accordionConfig', {
  closeOthers: true
})

.controller('AccordionController', ['$scope', '$attrs', 'accordionConfig', function ($scope, $attrs, accordionConfig) {

  // This array keeps track of the accordion groups
  this.groups = [];

  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
  this.closeOthers = function(openGroup) {
    var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
    if ( closeOthers ) {
      angular.forEach(this.groups, function (group) {
        if ( group !== openGroup ) {
          group.isOpen = false;
        }
      });
    }
  };

  // This is called from the accordion-group directive to add itself to the accordion
  this.addGroup = function(groupScope) {
    var that = this;
    this.groups.push(groupScope);

    groupScope.$on('$destroy', function (event) {
      that.removeGroup(groupScope);
    });
  };

  // This is called from the accordion-group directive when to remove itself
  this.removeGroup = function(group) {
    var index = this.groups.indexOf(group);
    if ( index !== -1 ) {
      this.groups.splice(index, 1);
    }
  };

}])

// The accordion directive simply sets up the directive controller
// and adds an accordion CSS class to itself element.
.directive('accordion', function () {
  return {
    restrict:'EA',
    controller:'AccordionController',
    transclude: true,
    replace: false,
    templateUrl: 'template/accordion/accordion.html'
  };
})

// The accordion-group directive indicates a block of html that will expand and collapse in an accordion
.directive('accordionGroup', function() {
  return {
    require:'^accordion',         // We need this directive to be inside an accordion
    restrict:'EA',
    transclude:true,              // It transcludes the contents of the directive into the template
    replace: true,                // The element containing the directive will be replaced with the template
    templateUrl:'template/accordion/accordion-group.html',
    scope: {
      heading: '@',               // Interpolate the heading attribute onto this scope
      isOpen: '=?',
      isDisabled: '=?'
    },
    controller: function() {
      this.setHeading = function(element) {
        this.heading = element;
      };
    },
    link: function(scope, element, attrs, accordionCtrl) {
      accordionCtrl.addGroup(scope);

      scope.$watch('isOpen', function(value) {
        if ( value ) {
          accordionCtrl.closeOthers(scope);
        }
      });

      scope.toggleOpen = function() {
        if ( !scope.isDisabled ) {
          scope.isOpen = !scope.isOpen;
        }
      };
    }
  };
})

// Use accordion-heading below an accordion-group to provide a heading containing HTML
// <accordion-group>
//   <accordion-heading>Heading containing HTML - <img src="..."></accordion-heading>
// </accordion-group>
.directive('accordionHeading', function() {
  return {
    restrict: 'EA',
    transclude: true,   // Grab the contents to be used as the heading
    template: '',       // In effect remove this element!
    replace: true,
    require: '^accordionGroup',
    link: function(scope, element, attr, accordionGroupCtrl, transclude) {
      // Pass the heading to the accordion-group controller
      // so that it can be transcluded into the right place in the template
      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
    }
  };
})

// Use in the accordion-group template to indicate where you want the heading to be transcluded
// You must provide the property on the accordion-group controller that will hold the transcluded element
// <div class="accordion-group">
//   <div class="accordion-heading" ><a ... accordion-transclude="heading">...</a></div>
//   ...
// </div>
.directive('accordionTransclude', function() {
  return {
    require: '^accordionGroup',
    link: function(scope, element, attr, controller) {
      scope.$watch(function() { return controller[attr.accordionTransclude]; }, function(heading) {
        if ( heading ) {
          element.html('');
          element.append(heading);
        }
      });
    }
  };
})

;

angular.module('ui.bootstrap.alert', [])

.controller('AlertController', ['$scope', '$attrs', function ($scope, $attrs) {
  $scope.closeable = 'close' in $attrs;
  this.close = $scope.close;
}])

.directive('alert', function () {
  return {
    restrict:'EA',
    controller:'AlertController',
    templateUrl:'template/alert/alert.html',
    transclude:true,
    replace:true,
    scope: {
      type: '@',
      close: '&'
    }
  };
})

.directive('dismissOnTimeout', ['$timeout', function($timeout) {
  return {
    require: 'alert',
    link: function(scope, element, attrs, alertCtrl) {
      $timeout(function(){
        alertCtrl.close();
      }, parseInt(attrs.dismissOnTimeout, 10));
    }
  };
}]);

angular.module('ui.bootstrap.bindHtml', [])

  .directive('bindHtmlUnsafe', function () {
    return function (scope, element, attr) {
      element.addClass('ng-binding').data('$binding', attr.bindHtmlUnsafe);
      scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
        element.html(value || '');
      });
    };
  });
angular.module('ui.bootstrap.buttons', [])

.constant('buttonConfig', {
  activeClass: 'active',
  toggleEvent: 'click'
})

.controller('ButtonsController', ['buttonConfig', function(buttonConfig) {
  this.activeClass = buttonConfig.activeClass || 'active';
  this.toggleEvent = buttonConfig.toggleEvent || 'click';
}])

.directive('btnRadio', function () {
  return {
    require: ['btnRadio', 'ngModel'],
    controller: 'ButtonsController',
    link: function (scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
      };

      //ui->model
      element.bind(buttonsCtrl.toggleEvent, function () {
        var isActive = element.hasClass(buttonsCtrl.activeClass);

        if (!isActive || angular.isDefined(attrs.uncheckable)) {
          scope.$apply(function () {
            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.btnRadio));
            ngModelCtrl.$render();
          });
        }
      });
    }
  };
})

.directive('btnCheckbox', function () {
  return {
    require: ['btnCheckbox', 'ngModel'],
    controller: 'ButtonsController',
    link: function (scope, element, attrs, ctrls) {
      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      function getTrueValue() {
        return getCheckboxValue(attrs.btnCheckboxTrue, true);
      }

      function getFalseValue() {
        return getCheckboxValue(attrs.btnCheckboxFalse, false);
      }

      function getCheckboxValue(attributeValue, defaultValue) {
        var val = scope.$eval(attributeValue);
        return angular.isDefined(val) ? val : defaultValue;
      }

      //model -> UI
      ngModelCtrl.$render = function () {
        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
      };

      //ui->model
      element.bind(buttonsCtrl.toggleEvent, function () {
        scope.$apply(function () {
          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
          ngModelCtrl.$render();
        });
      });
    }
  };
});

/**
* @ngdoc overview
* @name ui.bootstrap.carousel
*
* @description
* AngularJS version of an image carousel.
*
*/
angular.module('ui.bootstrap.carousel', [])
.controller('CarouselController', ['$scope', '$interval', '$animate', function ($scope, $interval, $animate) {
  var self = this,
    slides = self.slides = $scope.slides = [],
    currentIndex = -1,
    currentInterval, isPlaying;
  self.currentSlide = null;

  var destroyed = false;
  /* direction: "prev" or "next" */
  self.select = $scope.select = function(nextSlide, direction) {
    var nextIndex = self.indexOfSlide(nextSlide);
    //Decide direction if it's not given
    if (direction === undefined) {
      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
    }
    if (nextSlide && nextSlide !== self.currentSlide) {
      goNext();
    }
    function goNext() {
      // Scope has been destroyed, stop here.
      if (destroyed) { return; }

      angular.extend(nextSlide, {direction: direction, active: true});
      angular.extend(self.currentSlide || {}, {direction: direction, active: false});
      if ($animate.enabled() && !$scope.noTransition && nextSlide.$element) {
        $scope.$currentTransition = true;
        nextSlide.$element.one('$animate:close', function closeFn() {
          $scope.$currentTransition = null;
        });
      }

      self.currentSlide = nextSlide;
      currentIndex = nextIndex;
      //every time you change slides, reset the timer
      restartTimer();
    }
  };
  $scope.$on('$destroy', function () {
    destroyed = true;
  });

  function getSlideByIndex(index) {
    if (angular.isUndefined(slides[index].index)) {
      return slides[index];
    }
    var i, len = slides.length;
    for (i = 0; i < slides.length; ++i) {
      if (slides[i].index == index) {
        return slides[i];
      }
    }
  }

  self.getCurrentIndex = function() {
    if (self.currentSlide && angular.isDefined(self.currentSlide.index)) {
      return +self.currentSlide.index;
    }
    return currentIndex;
  };

  /* Allow outside people to call indexOf on slides array */
  self.indexOfSlide = function(slide) {
    return angular.isDefined(slide.index) ? +slide.index : slides.indexOf(slide);
  };

  $scope.next = function() {
    var newIndex = (self.getCurrentIndex() + 1) % slides.length;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(getSlideByIndex(newIndex), 'next');
    }
  };

  $scope.prev = function() {
    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;

    //Prevent this user-triggered transition from occurring if there is already one in progress
    if (!$scope.$currentTransition) {
      return self.select(getSlideByIndex(newIndex), 'prev');
    }
  };

  $scope.isActive = function(slide) {
     return self.currentSlide === slide;
  };

  $scope.$watch('interval', restartTimer);
  $scope.$on('$destroy', resetTimer);

  function restartTimer() {
    resetTimer();
    var interval = +$scope.interval;
    if (!isNaN(interval) && interval > 0) {
      currentInterval = $interval(timerFn, interval);
    }
  }

  function resetTimer() {
    if (currentInterval) {
      $interval.cancel(currentInterval);
      currentInterval = null;
    }
  }

  function timerFn() {
    var interval = +$scope.interval;
    if (isPlaying && !isNaN(interval) && interval > 0) {
      $scope.next();
    } else {
      $scope.pause();
    }
  }

  $scope.play = function() {
    if (!isPlaying) {
      isPlaying = true;
      restartTimer();
    }
  };
  $scope.pause = function() {
    if (!$scope.noPause) {
      isPlaying = false;
      resetTimer();
    }
  };

  self.addSlide = function(slide, element) {
    slide.$element = element;
    slides.push(slide);
    //if this is the first slide or the slide is set to active, select it
    if(slides.length === 1 || slide.active) {
      self.select(slides[slides.length-1]);
      if (slides.length == 1) {
        $scope.play();
      }
    } else {
      slide.active = false;
    }
  };

  self.removeSlide = function(slide) {
    if (angular.isDefined(slide.index)) {
      slides.sort(function(a, b) {
        return +a.index > +b.index;
      });
    }
    //get the index of the slide inside the carousel
    var index = slides.indexOf(slide);
    slides.splice(index, 1);
    if (slides.length > 0 && slide.active) {
      if (index >= slides.length) {
        self.select(slides[index-1]);
      } else {
        self.select(slides[index]);
      }
    } else if (currentIndex > index) {
      currentIndex--;
    }
  };

}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:carousel
 * @restrict EA
 *
 * @description
 * Carousel is the outer container for a set of image 'slides' to showcase.
 *
 * @param {number=} interval The time, in milliseconds, that it will take the carousel to go to the next slide.
 * @param {boolean=} noTransition Whether to disable transitions on the carousel.
 * @param {boolean=} noPause Whether to disable pausing on the carousel (by default, the carousel interval pauses on hover).
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <carousel>
      <slide>
        <img src="http://placekitten.com/150/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>Beautiful!</p>
        </div>
      </slide>
      <slide>
        <img src="http://placekitten.com/100/150" style="margin:auto;">
        <div class="carousel-caption">
          <p>D'aww!</p>
        </div>
      </slide>
    </carousel>
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
 */
.directive('carousel', [function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    controller: 'CarouselController',
    require: 'carousel',
    templateUrl: 'template/carousel/carousel.html',
    scope: {
      interval: '=',
      noTransition: '=',
      noPause: '='
    }
  };
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.carousel.directive:slide
 * @restrict EA
 *
 * @description
 * Creates a slide inside a {@link ui.bootstrap.carousel.directive:carousel carousel}.  Must be placed as a child of a carousel element.
 *
 * @param {boolean=} active Model binding, whether or not this slide is currently active.
 * @param {number=} index The index of the slide. The slides will be sorted by this parameter.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
<div ng-controller="CarouselDemoCtrl">
  <carousel>
    <slide ng-repeat="slide in slides" active="slide.active" index="$index">
      <img ng-src="{{slide.image}}" style="margin:auto;">
      <div class="carousel-caption">
        <h4>Slide {{$index}}</h4>
        <p>{{slide.text}}</p>
      </div>
    </slide>
  </carousel>
  Interval, in milliseconds: <input type="number" ng-model="myInterval">
  <br />Enter a negative number to stop the interval.
</div>
  </file>
  <file name="script.js">
function CarouselDemoCtrl($scope) {
  $scope.myInterval = 5000;
}
  </file>
  <file name="demo.css">
    .carousel-indicators {
      top: auto;
      bottom: 15px;
    }
  </file>
</example>
*/

.directive('slide', function() {
  return {
    require: '^carousel',
    restrict: 'EA',
    transclude: true,
    replace: true,
    templateUrl: 'template/carousel/slide.html',
    scope: {
      active: '=?',
      index: '=?'
    },
    link: function (scope, element, attrs, carouselCtrl) {
      carouselCtrl.addSlide(scope, element);
      //when the scope is destroyed then remove the slide from the current slides array
      scope.$on('$destroy', function() {
        carouselCtrl.removeSlide(scope);
      });

      scope.$watch('active', function(active) {
        if (active) {
          carouselCtrl.select(scope);
        }
      });
    }
  };
})

.animation('.item', [
         '$animate',
function ($animate) {
  return {
    beforeAddClass: function (element, className, done) {
      // Due to transclusion, noTransition property is on parent's scope
      if (className == 'active' && element.parent() &&
          !element.parent().scope().noTransition) {
        var stopped = false;
        var direction = element.isolateScope().direction;
        var directionClass = direction == 'next' ? 'left' : 'right';
        element.addClass(direction);
        $animate.addClass(element, directionClass).then(function () {
          if (!stopped) {
            element.removeClass(directionClass + ' ' + direction);
          }
          done();
        });

        return function () {
          stopped = true;
        };
      }
      done();
    },
    beforeRemoveClass: function (element, className, done) {
      // Due to transclusion, noTransition property is on parent's scope
      if (className == 'active' && element.parent() &&
          !element.parent().scope().noTransition) {
        var stopped = false;
        var direction = element.isolateScope().direction;
        var directionClass = direction == 'next' ? 'left' : 'right';
        $animate.addClass(element, directionClass).then(function () {
          if (!stopped) {
            element.removeClass(directionClass);
          }
          done();
        });
        return function () {
          stopped = true;
        };
      }
      done();
    }
  };

}])


;

angular.module('ui.bootstrap.dateparser', [])

.service('dateParser', ['$locale', 'orderByFilter', function($locale, orderByFilter) {
  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js
  var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

  this.parsers = {};

  var formatCodeToRegex = {
    'yyyy': {
      regex: '\\d{4}',
      apply: function(value) { this.year = +value; }
    },
    'yy': {
      regex: '\\d{2}',
      apply: function(value) { this.year = +value + 2000; }
    },
    'y': {
      regex: '\\d{1,4}',
      apply: function(value) { this.year = +value; }
    },
    'MMMM': {
      regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); }
    },
    'MMM': {
      regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
      apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); }
    },
    'MM': {
      regex: '0[1-9]|1[0-2]',
      apply: function(value) { this.month = value - 1; }
    },
    'M': {
      regex: '[1-9]|1[0-2]',
      apply: function(value) { this.month = value - 1; }
    },
    'dd': {
      regex: '[0-2][0-9]{1}|3[0-1]{1}',
      apply: function(value) { this.date = +value; }
    },
    'd': {
      regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
      apply: function(value) { this.date = +value; }
    },
    'EEEE': {
      regex: $locale.DATETIME_FORMATS.DAY.join('|')
    },
    'EEE': {
      regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|')
    },
    'HH': {
      regex: '(?:0|1)[0-9]|2[0-3]',
      apply: function(value) { this.hours = +value; }
    },
    'H': {
      regex: '1?[0-9]|2[0-3]',
      apply: function(value) { this.hours = +value; }
    },
    'mm': {
      regex: '[0-5][0-9]',
      apply: function(value) { this.minutes = +value; }
    },
    'm': {
      regex: '[0-9]|[1-5][0-9]',
      apply: function(value) { this.minutes = +value; }
    },
    'sss': {
      regex: '[0-9][0-9][0-9]',
      apply: function(value) { this.milliseconds = +value; }
    },
    'ss': {
      regex: '[0-5][0-9]',
      apply: function(value) { this.seconds = +value; }
    },
    's': {
      regex: '[0-9]|[1-5][0-9]',
      apply: function(value) { this.seconds = +value; }
    }
  };

  function createParser(format) {
    var map = [], regex = format.split('');

    angular.forEach(formatCodeToRegex, function(data, code) {
      var index = format.indexOf(code);

      if (index > -1) {
        format = format.split('');

        regex[index] = '(' + data.regex + ')';
        format[index] = '$'; // Custom symbol to define consumed part of format
        for (var i = index + 1, n = index + code.length; i < n; i++) {
          regex[i] = '';
          format[i] = '$';
        }
        format = format.join('');

        map.push({ index: index, apply: data.apply });
      }
    });

    return {
      regex: new RegExp('^' + regex.join('') + '$'),
      map: orderByFilter(map, 'index')
    };
  }

  this.parse = function(input, format, baseDate) {
    if ( !angular.isString(input) || !format ) {
      return input;
    }

    format = $locale.DATETIME_FORMATS[format] || format;
    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');

    if ( !this.parsers[format] ) {
      this.parsers[format] = createParser(format);
    }

    var parser = this.parsers[format],
        regex = parser.regex,
        map = parser.map,
        results = input.match(regex);

    if ( results && results.length ) {
      var fields, dt;
      if (baseDate) {
        fields = {
          year: baseDate.getFullYear(),
          month: baseDate.getMonth(),
          date: baseDate.getDate(),
          hours: baseDate.getHours(),
          minutes: baseDate.getMinutes(),
          seconds: baseDate.getSeconds(),
          milliseconds: baseDate.getMilliseconds()
        };
      } else {
        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };
      }

      for( var i = 1, n = results.length; i < n; i++ ) {
        var mapper = map[i-1];
        if ( mapper.apply ) {
          mapper.apply.call(fields, results[i]);
        }
      }

      if ( isValid(fields.year, fields.month, fields.date) ) {
        dt = new Date(fields.year, fields.month, fields.date, fields.hours, fields.minutes, fields.seconds,
          fields.milliseconds || 0);
      }

      return dt;
    }
  };

  // Check if date is valid for specific month (and year for February).
  // Month: 0 = Jan, 1 = Feb, etc
  function isValid(year, month, date) {
    if (date < 1) {
      return false;
    }

    if ( month === 1 && date > 28) {
        return date === 29 && ((year % 4 === 0 && year % 100 !== 0) || year % 400 === 0);
    }

    if ( month === 3 || month === 5 || month === 8 || month === 10) {
        return date < 31;
    }

    return true;
  }
}]);

angular.module('ui.bootstrap.position', [])

/**
 * A set of utility methods that can be use to retrieve position of DOM elements.
 * It is meant to be used where we need to absolute-position DOM elements in
 * relation to other, existing elements (this is the case for tooltips, popovers,
 * typeahead suggestions etc.).
 */
  .factory('$position', ['$document', '$window', function ($document, $window) {

    function getStyle(el, cssprop) {
      if (el.currentStyle) { //IE
        return el.currentStyle[cssprop];
      } else if ($window.getComputedStyle) {
        return $window.getComputedStyle(el)[cssprop];
      }
      // finally try and get inline style
      return el.style[cssprop];
    }

    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
      return (getStyle(element, 'position') || 'static' ) === 'static';
    }

    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function (element) {
      var docDomEl = $document[0];
      var offsetParent = element.offsetParent || docDomEl;
      while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent) ) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docDomEl;
    };

    return {
      /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
      position: function (element) {
        var elBCR = this.offset(element);
        var offsetParentBCR = { top: 0, left: 0 };
        var offsetParentEl = parentOffsetEl(element[0]);
        if (offsetParentEl != $document[0]) {
          offsetParentBCR = this.offset(angular.element(offsetParentEl));
          offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
          offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
        }

        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: elBCR.top - offsetParentBCR.top,
          left: elBCR.left - offsetParentBCR.left
        };
      },

      /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
      offset: function (element) {
        var boundingClientRect = element[0].getBoundingClientRect();
        return {
          width: boundingClientRect.width || element.prop('offsetWidth'),
          height: boundingClientRect.height || element.prop('offsetHeight'),
          top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
          left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
        };
      },

      /**
       * Provides coordinates for the targetEl in relation to hostEl
       */
      positionElements: function (hostEl, targetEl, positionStr, appendToBody) {

        var positionStrParts = positionStr.split('-');
        var pos0 = positionStrParts[0], pos1 = positionStrParts[1] || 'center';

        var hostElPos,
          targetElWidth,
          targetElHeight,
          targetElPos;

        hostElPos = appendToBody ? this.offset(hostEl) : this.position(hostEl);

        targetElWidth = targetEl.prop('offsetWidth');
        targetElHeight = targetEl.prop('offsetHeight');

        var shiftWidth = {
          center: function () {
            return hostElPos.left + hostElPos.width / 2 - targetElWidth / 2;
          },
          left: function () {
            return hostElPos.left;
          },
          right: function () {
            return hostElPos.left + hostElPos.width;
          }
        };

        var shiftHeight = {
          center: function () {
            return hostElPos.top + hostElPos.height / 2 - targetElHeight / 2;
          },
          top: function () {
            return hostElPos.top;
          },
          bottom: function () {
            return hostElPos.top + hostElPos.height;
          }
        };

        switch (pos0) {
          case 'right':
            targetElPos = {
              top: shiftHeight[pos1](),
              left: shiftWidth[pos0]()
            };
            break;
          case 'left':
            targetElPos = {
              top: shiftHeight[pos1](),
              left: hostElPos.left - targetElWidth
            };
            break;
          case 'bottom':
            targetElPos = {
              top: shiftHeight[pos0](),
              left: shiftWidth[pos1]()
            };
            break;
          default:
            targetElPos = {
              top: hostElPos.top - targetElHeight,
              left: shiftWidth[pos1]()
            };
            break;
        }

        return targetElPos;
      }
    };
  }]);

angular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.position'])

.constant('datepickerConfig', {
  formatDay: 'dd',
  formatMonth: 'MMMM',
  formatYear: 'yyyy',
  formatDayHeader: 'EEE',
  formatDayTitle: 'MMMM yyyy',
  formatMonthTitle: 'yyyy',
  datepickerMode: 'day',
  minMode: 'day',
  maxMode: 'year',
  showWeeks: true,
  startingDay: 0,
  yearRange: 20,
  minDate: null,
  maxDate: null,
  shortcutPropagation: false
})

.controller('DatepickerController', ['$scope', '$attrs', '$parse', '$interpolate', '$timeout', '$log', 'dateFilter', 'datepickerConfig', function($scope, $attrs, $parse, $interpolate, $timeout, $log, dateFilter, datepickerConfig) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl;

  // Modes chain
  this.modes = ['day', 'month', 'year'];

  // Configuration attributes
  angular.forEach(['formatDay', 'formatMonth', 'formatYear', 'formatDayHeader', 'formatDayTitle', 'formatMonthTitle',
                   'minMode', 'maxMode', 'showWeeks', 'startingDay', 'yearRange', 'shortcutPropagation'], function( key, index ) {
    self[key] = angular.isDefined($attrs[key]) ? (index < 8 ? $interpolate($attrs[key])($scope.$parent) : $scope.$parent.$eval($attrs[key])) : datepickerConfig[key];
  });

  // Watchable date attributes
  angular.forEach(['minDate', 'maxDate'], function( key ) {
    if ( $attrs[key] ) {
      $scope.$parent.$watch($parse($attrs[key]), function(value) {
        self[key] = value ? new Date(value) : null;
        self.refreshView();
      });
    } else {
      self[key] = datepickerConfig[key] ? new Date(datepickerConfig[key]) : null;
    }
  });

  $scope.datepickerMode = $scope.datepickerMode || datepickerConfig.datepickerMode;
  $scope.maxMode = self.maxMode;
  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);

  if(angular.isDefined($attrs.initDate)) {
    this.activeDate = $scope.$parent.$eval($attrs.initDate) || new Date();
    $scope.$parent.$watch($attrs.initDate, function(initDate){
      if(initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)){
        self.activeDate = initDate;
        self.refreshView();
      }
    });
  } else {
    this.activeDate =  new Date();
  }

  $scope.isActive = function(dateObject) {
    if ($scope.$parent.$eval($attrs.hideActive)) return false;
    if (self.compare(dateObject.date, self.activeDate) === 0) {
      $scope.activeDateId = dateObject.uid;
      return true;
    }
    return false;
  };

  this.init = function( ngModelCtrl_ ) {
    ngModelCtrl = ngModelCtrl_;

    ngModelCtrl.$render = function() {
      self.render();
    };
  };

  this.render = function() {
    if ( ngModelCtrl.$viewValue ) {
      var date = new Date( ngModelCtrl.$viewValue ),
          isValid = !isNaN(date);

      if ( isValid ) {
        this.activeDate = date;
      } else {
        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
      }
      ngModelCtrl.$setValidity('date', isValid);
    }
    this.refreshView();
  };

  this.refreshView = function() {
    if ( this.element ) {
      this._refreshView();

      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
      ngModelCtrl.$setValidity('date-disabled', !date || (this.element && !this.isDisabled(date)));
    }
  };

  this.createDateObject = function(date, format) {
    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
    return {
      date: date,
      label: dateFilter(date, format),
      selected: model && this.compare(date, model) === 0,
      disabled: this.isDisabled(date),
      current: this.compare(date, new Date()) === 0,
      customClass: this.customClass(date)
    };
  };

  this.isDisabled = function( date ) {
    return ((this.minDate && this.compare(date, this.minDate) < 0) || (this.maxDate && this.compare(date, this.maxDate) > 0) || ($attrs.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode})));
  };

    this.customClass = function( date ) {
      return $scope.customClass({date: date, mode: $scope.datepickerMode});
    };

  // Split array into smaller arrays
  this.split = function(arr, size) {
    var arrays = [];
    while (arr.length > 0) {
      arrays.push(arr.splice(0, size));
    }
    return arrays;
  };

  $scope.select = function( date ) {
    if ( $scope.datepickerMode === self.minMode ) {
      var dt = ngModelCtrl.$viewValue ? new Date( ngModelCtrl.$viewValue ) : new Date(0, 0, 0, 0, 0, 0, 0);
      dt.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );
      ngModelCtrl.$setViewValue( dt );
      ngModelCtrl.$render();
    } else {
      self.activeDate = date;
      $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) - 1 ];
    }
  };

  $scope.move = function( direction ) {
    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),
        month = self.activeDate.getMonth() + direction * (self.step.months || 0);
    self.activeDate.setFullYear(year, month, 1);
    self.refreshView();
  };

  $scope.toggleMode = function( direction ) {
    direction = direction || 1;

    if (($scope.datepickerMode === self.maxMode && direction === 1) || ($scope.datepickerMode === self.minMode && direction === -1)) {
      return;
    }

    $scope.datepickerMode = self.modes[ self.modes.indexOf( $scope.datepickerMode ) + direction ];
  };

  // Key event mapper
  $scope.keys = { 13:'enter', 32:'space', 33:'pageup', 34:'pagedown', 35:'end', 36:'home', 37:'left', 38:'up', 39:'right', 40:'down' };

  var focusElement = function() {
    $timeout(function() {
      self.element[0].focus();
    }, 0 , false);
  };

  // Listen for focus requests from popup directive
  $scope.$on('datepicker.focus', focusElement);

  $scope.keydown = function( evt ) {
    var key = $scope.keys[evt.which];

    if ( !key || evt.shiftKey || evt.altKey ) {
      return;
    }

    evt.preventDefault();
    if(!self.shortcutPropagation){
        evt.stopPropagation();
    }

    if (key === 'enter' || key === 'space') {
      if ( self.isDisabled(self.activeDate)) {
        return; // do nothing
      }
      $scope.select(self.activeDate);
      focusElement();
    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
      $scope.toggleMode(key === 'up' ? 1 : -1);
      focusElement();
    } else {
      self.handleKeyDown(key, evt);
      self.refreshView();
    }
  };
}])

.directive( 'datepicker', function () {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/datepicker.html',
    scope: {
      datepickerMode: '=?',
      dateDisabled: '&',
      customClass: '&',
      shortcutPropagation: '&?'
    },
    require: ['datepicker', '?^ngModel'],
    controller: 'DatepickerController',
    link: function(scope, element, attrs, ctrls) {
      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if ( ngModelCtrl ) {
        datepickerCtrl.init( ngModelCtrl );
      }
    }
  };
})

.directive('daypicker', ['dateFilter', function (dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/day.html',
    require: '^datepicker',
    link: function(scope, element, attrs, ctrl) {
      scope.showWeeks = ctrl.showWeeks;

      ctrl.step = { months: 1 };
      ctrl.element = element;

      var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
      function getDaysInMonth( year, month ) {
        return ((month === 1) && (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0))) ? 29 : DAYS_IN_MONTH[month];
      }

      function getDates(startDate, n) {
        var dates = new Array(n), current = new Date(startDate), i = 0;
        current.setHours(12); // Prevent repeated dates because of timezone bug
        while ( i < n ) {
          dates[i++] = new Date(current);
          current.setDate( current.getDate() + 1 );
        }
        return dates;
      }

      ctrl._refreshView = function() {
        var year = ctrl.activeDate.getFullYear(),
          month = ctrl.activeDate.getMonth(),
          firstDayOfMonth = new Date(year, month, 1),
          difference = ctrl.startingDay - firstDayOfMonth.getDay(),
          numDisplayedFromPreviousMonth = (difference > 0) ? 7 - difference : - difference,
          firstDate = new Date(firstDayOfMonth);

        if ( numDisplayedFromPreviousMonth > 0 ) {
          firstDate.setDate( - numDisplayedFromPreviousMonth + 1 );
        }

        // 42 is the number of days on a six-month calendar
        var days = getDates(firstDate, 42);
        for (var i = 0; i < 42; i ++) {
          days[i] = angular.extend(ctrl.createDateObject(days[i], ctrl.formatDay), {
            secondary: days[i].getMonth() !== month,
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.labels = new Array(7);
        for (var j = 0; j < 7; j++) {
          scope.labels[j] = {
            abbr: dateFilter(days[j].date, ctrl.formatDayHeader),
            full: dateFilter(days[j].date, 'EEEE')
          };
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatDayTitle);
        scope.rows = ctrl.split(days, 7);

        if ( scope.showWeeks ) {
          scope.weekNumbers = [];
          var thursdayIndex = (4 + 7 - ctrl.startingDay) % 7,
              numWeeks = scope.rows.length;
          for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
            scope.weekNumbers.push(
              getISO8601WeekNumber( scope.rows[curWeek][thursdayIndex].date ));
          }
        }
      };

      ctrl.compare = function(date1, date2) {
        return (new Date( date1.getFullYear(), date1.getMonth(), date1.getDate() ) - new Date( date2.getFullYear(), date2.getMonth(), date2.getDate() ) );
      };

      function getISO8601WeekNumber(date) {
        var checkDate = new Date(date);
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday
        var time = checkDate.getTime();
        checkDate.setMonth(0); // Compare with Jan 1
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      }

      ctrl.handleKeyDown = function( key, evt ) {
        var date = ctrl.activeDate.getDate();

        if (key === 'left') {
          date = date - 1;   // up
        } else if (key === 'up') {
          date = date - 7;   // down
        } else if (key === 'right') {
          date = date + 1;   // down
        } else if (key === 'down') {
          date = date + 7;
        } else if (key === 'pageup' || key === 'pagedown') {
          var month = ctrl.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);
          ctrl.activeDate.setMonth(month, 1);
          date = Math.min(getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth()), date);
        } else if (key === 'home') {
          date = 1;
        } else if (key === 'end') {
          date = getDaysInMonth(ctrl.activeDate.getFullYear(), ctrl.activeDate.getMonth());
        }
        ctrl.activeDate.setDate(date);
      };

      ctrl.refreshView();
    }
  };
}])

.directive('monthpicker', ['dateFilter', function (dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/month.html',
    require: '^datepicker',
    link: function(scope, element, attrs, ctrl) {
      ctrl.step = { years: 1 };
      ctrl.element = element;

      ctrl._refreshView = function() {
        var months = new Array(12),
            year = ctrl.activeDate.getFullYear();

        for ( var i = 0; i < 12; i++ ) {
          months[i] = angular.extend(ctrl.createDateObject(new Date(year, i, 1), ctrl.formatMonth), {
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.title = dateFilter(ctrl.activeDate, ctrl.formatMonthTitle);
        scope.rows = ctrl.split(months, 3);
      };

      ctrl.compare = function(date1, date2) {
        return new Date( date1.getFullYear(), date1.getMonth() ) - new Date( date2.getFullYear(), date2.getMonth() );
      };

      ctrl.handleKeyDown = function( key, evt ) {
        var date = ctrl.activeDate.getMonth();

        if (key === 'left') {
          date = date - 1;   // up
        } else if (key === 'up') {
          date = date - 3;   // down
        } else if (key === 'right') {
          date = date + 1;   // down
        } else if (key === 'down') {
          date = date + 3;
        } else if (key === 'pageup' || key === 'pagedown') {
          var year = ctrl.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);
          ctrl.activeDate.setFullYear(year);
        } else if (key === 'home') {
          date = 0;
        } else if (key === 'end') {
          date = 11;
        }
        ctrl.activeDate.setMonth(date);
      };

      ctrl.refreshView();
    }
  };
}])

.directive('yearpicker', ['dateFilter', function (dateFilter) {
  return {
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/datepicker/year.html',
    require: '^datepicker',
    link: function(scope, element, attrs, ctrl) {
      var range = ctrl.yearRange;

      ctrl.step = { years: range };
      ctrl.element = element;

      function getStartingYear( year ) {
        return parseInt((year - 1) / range, 10) * range + 1;
      }

      ctrl._refreshView = function() {
        var years = new Array(range);

        for ( var i = 0, start = getStartingYear(ctrl.activeDate.getFullYear()); i < range; i++ ) {
          years[i] = angular.extend(ctrl.createDateObject(new Date(start + i, 0, 1), ctrl.formatYear), {
            uid: scope.uniqueId + '-' + i
          });
        }

        scope.title = [years[0].label, years[range - 1].label].join(' - ');
        scope.rows = ctrl.split(years, 5);
      };

      ctrl.compare = function(date1, date2) {
        return date1.getFullYear() - date2.getFullYear();
      };

      ctrl.handleKeyDown = function( key, evt ) {
        var date = ctrl.activeDate.getFullYear();

        if (key === 'left') {
          date = date - 1;   // up
        } else if (key === 'up') {
          date = date - 5;   // down
        } else if (key === 'right') {
          date = date + 1;   // down
        } else if (key === 'down') {
          date = date + 5;
        } else if (key === 'pageup' || key === 'pagedown') {
          date += (key === 'pageup' ? - 1 : 1) * ctrl.step.years;
        } else if (key === 'home') {
          date = getStartingYear( ctrl.activeDate.getFullYear() );
        } else if (key === 'end') {
          date = getStartingYear( ctrl.activeDate.getFullYear() ) + range - 1;
        }
        ctrl.activeDate.setFullYear(date);
      };

      ctrl.refreshView();
    }
  };
}])

.constant('datepickerPopupConfig', {
  datepickerPopup: 'yyyy-MM-dd',
  html5Types: {
    date: 'yyyy-MM-dd',
    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
    'month': 'yyyy-MM'
  },
  currentText: 'Today',
  clearText: 'Clear',
  closeText: 'Done',
  closeOnDateSelection: true,
  appendToBody: false,
  showButtonBar: true
})

.directive('datepickerPopup', ['$compile', '$parse', '$document', '$position', 'dateFilter', 'dateParser', 'datepickerPopupConfig',
function ($compile, $parse, $document, $position, dateFilter, dateParser, datepickerPopupConfig) {
  return {
    restrict: 'EA',
    require: 'ngModel',
    scope: {
      isOpen: '=?',
      currentText: '@',
      clearText: '@',
      closeText: '@',
      dateDisabled: '&',
      customClass: '&'
    },
    link: function(scope, element, attrs, ngModel) {
      var dateFormat,
          closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? scope.$parent.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection,
          appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? scope.$parent.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;

      scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? scope.$parent.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;

      scope.getText = function( key ) {
        return scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
      };

      var isHtml5DateInput = false;
      if (datepickerPopupConfig.html5Types[attrs.type]) {
        dateFormat = datepickerPopupConfig.html5Types[attrs.type];
        isHtml5DateInput = true;
      } else {
        dateFormat = attrs.datepickerPopup || datepickerPopupConfig.datepickerPopup;
        attrs.$observe('datepickerPopup', function(value, oldValue) {
            var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
            // Invalidate the $modelValue to ensure that formatters re-run
            // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764
            if (newDateFormat !== dateFormat) {
              dateFormat = newDateFormat;
              ngModel.$modelValue = null;

              if (!dateFormat) {
                throw new Error('datepickerPopup must have a date format specified.');
              }
            }
        });
      }

      if (!dateFormat) {
        throw new Error('datepickerPopup must have a date format specified.');
      }

      if (isHtml5DateInput && attrs.datepickerPopup) {
        throw new Error('HTML5 date input types do not support custom formats.');
      }

      // popup element used to display calendar
      var popupEl = angular.element('<div datepicker-popup-wrap><div datepicker></div></div>');
      popupEl.attr({
        'ng-model': 'date',
        'ng-change': 'dateSelection()'
      });

      function cameltoDash( string ){
        return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });
      }

      // datepicker element
      var datepickerEl = angular.element(popupEl.children()[0]);
      if (isHtml5DateInput) {
        if (attrs.type == 'month') {
          datepickerEl.attr('datepicker-mode', '"month"');
          datepickerEl.attr('min-mode', 'month');
        }
      }

      if ( attrs.datepickerOptions ) {
        var options = scope.$parent.$eval(attrs.datepickerOptions);
        if(options.initDate) {
          scope.initDate = options.initDate;
          datepickerEl.attr( 'init-date', 'initDate' );
          delete options.initDate;
        }
        angular.forEach(options, function( value, option ) {
          datepickerEl.attr( cameltoDash(option), value );
        });
      }

      scope.watchData = {};
      angular.forEach(['minDate', 'maxDate', 'datepickerMode', 'initDate', 'shortcutPropagation'], function( key ) {
        if ( attrs[key] ) {
          var getAttribute = $parse(attrs[key]);
          scope.$parent.$watch(getAttribute, function(value){
            scope.watchData[key] = value;
          });
          datepickerEl.attr(cameltoDash(key), 'watchData.' + key);

          // Propagate changes from datepicker to outside
          if ( key === 'datepickerMode' ) {
            var setAttribute = getAttribute.assign;
            scope.$watch('watchData.' + key, function(value, oldvalue) {
              if ( value !== oldvalue ) {
                setAttribute(scope.$parent, value);
              }
            });
          }
        }
      });
      if (attrs.dateDisabled) {
        datepickerEl.attr('date-disabled', 'dateDisabled({ date: date, mode: mode })');
      }

      if (attrs.showWeeks) {
        datepickerEl.attr('show-weeks', attrs.showWeeks);
      }

      if (attrs.customClass){
        datepickerEl.attr('custom-class', 'customClass({ date: date, mode: mode })');
      }

      function parseDate(viewValue) {
        if (angular.isNumber(viewValue)) {
          // presumably timestamp to date object
          viewValue = new Date(viewValue);
        }

        if (!viewValue) {
          return null;
        } else if (angular.isDate(viewValue) && !isNaN(viewValue)) {
          return viewValue;
        } else if (angular.isString(viewValue)) {
          var date = dateParser.parse(viewValue, dateFormat, scope.date) || new Date(viewValue);
          if (isNaN(date)) {
            return undefined;
          } else {
            return date;
          }
        } else {
          return undefined;
        }
      }

      function validator(modelValue, viewValue) {
        var value = modelValue || viewValue;
        if (angular.isNumber(value)) {
          value = new Date(value);
        }
        if (!value) {
          return true;
        } else if (angular.isDate(value) && !isNaN(value)) {
          return true;
        } else if (angular.isString(value)) {
          var date = dateParser.parse(value, dateFormat) || new Date(value);
          return !isNaN(date);
        } else {
          return false;
        }
      }

      if (!isHtml5DateInput) {
        // Internal API to maintain the correct ng-invalid-[key] class
        ngModel.$$parserName = 'date';
        ngModel.$validators.date = validator;
        ngModel.$parsers.unshift(parseDate);
        ngModel.$formatters.push(function (value) {
          scope.date = value;
          return ngModel.$isEmpty(value) ? value : dateFilter(value, dateFormat);
        });
      }
      else {
        ngModel.$formatters.push(function (value) {
          scope.date = value;
          return value;
        });
      }

      // Inner change
      scope.dateSelection = function(dt) {
        if (angular.isDefined(dt)) {
          scope.date = dt;
        }
        var date = scope.date ? dateFilter(scope.date, dateFormat) : '';
        element.val(date);
        ngModel.$setViewValue(date);

        if ( closeOnDateSelection ) {
          scope.isOpen = false;
          element[0].focus();
        }
      };

      // Detect changes in the view from the text box
      ngModel.$viewChangeListeners.push(function () {
        scope.date = dateParser.parse(ngModel.$viewValue, dateFormat, scope.date) || new Date(ngModel.$viewValue);
      });

      var documentClickBind = function(event) {
        if (scope.isOpen && event.target !== element[0]) {
          scope.$apply(function() {
            scope.isOpen = false;
          });
        }
      };

      var keydown = function(evt, noApply) {
        scope.keydown(evt);
      };
      element.bind('keydown', keydown);

      scope.keydown = function(evt) {
        if (evt.which === 27) {
          evt.preventDefault();
          if (scope.isOpen) {
            evt.stopPropagation();
          }
          scope.close();
        } else if (evt.which === 40 && !scope.isOpen) {
          scope.isOpen = true;
        }
        //Modified for Elements - if backspace is pressed when datepicker is open, do not navigate back
        else if (evt.which === 8  && popupEl.has(evt.target).length > 0) {
          evt.preventDefault();
        }
      };

      scope.$watch('isOpen', function(value) {
        if (value) {
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top = scope.position.top + element.prop('offsetHeight');
          scope.$broadcast('datepicker.focus');
          $document.bind('click', documentClickBind);
          //Added for elements - to make datepicker responsive to viewport changes
          element.bind('resize', function () {
          scope.position = appendToBody ? $position.offset(element) : $position.position(element);
          scope.position.top = scope.position.top + element.prop('offsetHeight');
          scope.$broadcast('datepicker.focus');
          });
          $document.bind('click', documentClickBind);
        } else {
          $document.unbind('click', documentClickBind);
          //Added for elements - to make datepicker responsive to viewport changes
          element.unbind('resize');
        }
      });

      scope.select = function( date ) {
        if (date === 'today') {
          var today = new Date();
          if (angular.isDate(scope.date)) {
            date = new Date(scope.date);
            date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
          } else {
            date = new Date(today.setHours(0, 0, 0, 0));
          }
        }
        scope.dateSelection( date );
      };

      scope.close = function() {
        scope.isOpen = false;
        element[0].focus();
      };

      var $popup = $compile(popupEl)(scope);
      // Prevent jQuery cache memory leak (template is now redundant after linking)
      popupEl.remove();

      if ( appendToBody ) {
        $document.find('body').append($popup);
      } else {
        element.after($popup);
      }

      scope.$on('$destroy', function() {
        $popup.remove();
        element.unbind('keydown', keydown);
        $document.unbind('click', documentClickBind);
        //Added for elements - to make datepicker responsive to viewport changes
        element.unbind('resize');
      });
    }
  };
}])

.directive('datepickerPopupWrap', function() {
  return {
    restrict:'EA',
    replace: true,
    transclude: true,
    templateUrl: 'template/datepicker/popup.html',
    link:function (scope, element, attrs) {

    var leftWidth,newWidth;
    //Added for elements - to make datepicker responsive to viewport changes
    scope.$on('datepicker.focus',function(){
         leftWidth = scope.position.left + element.outerWidth();
          if(leftWidth >= window.innerWidth-10)
          {
            newWidth = scope.position.left-(leftWidth - window.innerWidth + 20);
            scope.position.left = newWidth;
          }
        });
        element.bind('click', function(event) {
          event.preventDefault();
          event.stopPropagation();
        });
      }
    };
  });

angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position'])

.constant('dropdownConfig', {
  openClass: 'open'
})

.service('dropdownService', ['$document', '$rootScope', function($document, $rootScope) {
  var openScope = null;

  this.open = function( dropdownScope ) {
    if ( !openScope ) {
      $document.bind('click', closeDropdown);
      $document.bind('keydown', escapeKeyBind);
    }

    if ( openScope && openScope !== dropdownScope ) {
        openScope.isOpen = false;
    }

    openScope = dropdownScope;
  };

  this.close = function( dropdownScope ) {
    if ( openScope === dropdownScope ) {
      openScope = null;
      $document.unbind('click', closeDropdown);
      $document.unbind('keydown', escapeKeyBind);
    }
  };

  var closeDropdown = function( evt ) {
    // This method may still be called during the same mouse event that
    // unbound this event handler. So check openScope before proceeding.
    if (!openScope) { return; }

    if( evt && openScope.getAutoClose() === 'disabled' )  { return ; }

    var toggleElement = openScope.getToggleElement();
    if ( evt && toggleElement && toggleElement[0].contains(evt.target) ) {
        return;
    }

    var $element = openScope.getElement();
    if( evt && openScope.getAutoClose() === 'outsideClick' && $element && $element[0].contains(evt.target) ) {
      return;
    }

    openScope.isOpen = false;

    if (!$rootScope.$$phase) {
      openScope.$apply();
    }
  };

  var escapeKeyBind = function( evt ) {
    if ( evt.which === 27 ) {
      openScope.focusToggleElement();
      closeDropdown();
    }
  };
}])

.controller('DropdownController', ['$scope', '$attrs', '$parse', 'dropdownConfig', 'dropdownService', '$animate', '$position', '$document', function($scope, $attrs, $parse, dropdownConfig, dropdownService, $animate, $position, $document) {
  var self = this,
      scope = $scope.$new(), // create a child scope so we are not polluting original one
      openClass = dropdownConfig.openClass,
      getIsOpen,
      setIsOpen = angular.noop,
      toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,
      appendToBody = false;

  this.init = function( element ) {
    self.$element = element;

    if ( $attrs.isOpen ) {
      getIsOpen = $parse($attrs.isOpen);
      setIsOpen = getIsOpen.assign;

      $scope.$watch(getIsOpen, function(value) {
        scope.isOpen = !!value;
      });
    }

    appendToBody = angular.isDefined($attrs.dropdownAppendToBody);

    if ( appendToBody && self.dropdownMenu ) {
      $document.find('body').append( self.dropdownMenu );
      element.on('$destroy', function handleDestroyEvent() {
        self.dropdownMenu.remove();
      });
    }
  };

  this.toggle = function( open ) {
    return scope.isOpen = arguments.length ? !!open : !scope.isOpen;
  };

  // Allow other directives to watch status
  this.isOpen = function() {
    return scope.isOpen;
  };

  scope.getToggleElement = function() {
    return self.toggleElement;
  };

  scope.getAutoClose = function() {
    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'
  };

  scope.getElement = function() {
    return self.$element;
  };

  scope.focusToggleElement = function() {
    if ( self.toggleElement ) {
      self.toggleElement[0].focus();
    }
  };

  scope.$watch('isOpen', function( isOpen, wasOpen ) {
    if ( appendToBody && self.dropdownMenu ) {
      var pos = $position.positionElements(self.$element, self.dropdownMenu, 'bottom-left', true);
      self.dropdownMenu.css({
        top: pos.top + 'px',
        left: pos.left + 'px',
        display: isOpen ? 'block' : 'none'
      });
    }

    $animate[isOpen ? 'addClass' : 'removeClass'](self.$element, openClass);

    if ( isOpen ) {
      scope.focusToggleElement();
      dropdownService.open( scope );
    } else {
      dropdownService.close( scope );
    }

    setIsOpen($scope, isOpen);
    if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
      toggleInvoker($scope, { open: !!isOpen });
    }
  });

  $scope.$on('$locationChangeSuccess', function() {
    scope.isOpen = false;
  });

  $scope.$on('$destroy', function() {
    scope.$destroy();
  });
}])

.directive('dropdown', function() {
  return {
    controller: 'DropdownController',
    link: function(scope, element, attrs, dropdownCtrl) {
      dropdownCtrl.init( element );
    }
  };
})

.directive('dropdownMenu', function() {
  return {
    restrict: 'AC',
    require: '?^dropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if ( !dropdownCtrl ) {
        return;
      }
      dropdownCtrl.dropdownMenu = element;
    }
  };
})

.directive('dropdownToggle', function() {
  return {
    require: '?^dropdown',
    link: function(scope, element, attrs, dropdownCtrl) {
      if ( !dropdownCtrl ) {
        return;
      }

      dropdownCtrl.toggleElement = element;

      var toggleDropdown = function(event) {
        event.preventDefault();

        if ( !element.hasClass('disabled') && !attrs.disabled ) {
          scope.$apply(function() {
            dropdownCtrl.toggle();
          });
        }
      };

      element.bind('click', toggleDropdown);

      // WAI-ARIA
      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });
      scope.$watch(dropdownCtrl.isOpen, function( isOpen ) {
        element.attr('aria-expanded', !!isOpen);
      });

      scope.$on('$destroy', function() {
        element.unbind('click', toggleDropdown);
      });
    }
  };
});

angular.module('ui.bootstrap.modal', [])

/**
 * A helper, internal data structure that acts as a map but also allows getting / removing
 * elements in the LIFO order
 */
  .factory('$$stackedMap', function () {
    return {
      createNew: function () {
        var stack = [];

        return {
          add: function (key, value) {
            stack.push({
              key: key,
              value: value
            });
          },
          get: function (key) {
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                return stack[i];
              }
            }
          },
          keys: function() {
            var keys = [];
            for (var i = 0; i < stack.length; i++) {
              keys.push(stack[i].key);
            }
            return keys;
          },
          top: function () {
            return stack[stack.length - 1];
          },
          remove: function (key) {
            var idx = -1;
            for (var i = 0; i < stack.length; i++) {
              if (key == stack[i].key) {
                idx = i;
                break;
              }
            }
            return stack.splice(idx, 1)[0];
          },
          removeTop: function () {
            return stack.splice(stack.length - 1, 1)[0];
          },
          length: function () {
            return stack.length;
          }
        };
      }
    };
  })

/**
 * A helper directive for the $modal service. It creates a backdrop element.
 */
  .directive('modalBackdrop', ['$timeout', function ($timeout) {
    return {
      restrict: 'EA',
      replace: true,
      templateUrl: 'template/modal/backdrop.html',
      compile: function (tElement, tAttrs) {
        tElement.addClass(tAttrs.backdropClass);
        return linkFn;
      }
    };

    function linkFn(scope, element, attrs) {
      scope.animate = false;

      //trigger CSS transitions
      $timeout(function () {
        scope.animate = true;
      });
    }
  }])

  .directive('modalWindow', ['$modalStack', '$window', '$q', '$timeout', function ($modalStack,$window, $q, $timeout) {
    return {
      restrict: 'EA',
      scope: {
        index: '@',
        animate: '='
      },
      replace: true,
      transclude: true,
      templateUrl: function(tElement, tAttrs) {
        return tAttrs.templateUrl || 'template/modal/window.html';
      },
      link: function (scope, element, attrs) {
        element.addClass(attrs.windowClass || '');
        scope.size = attrs.size;

        //hpe elements change - adding class here rather than using ng-class as it can cause some shifting in IE by the time the digest happens
        if(scope.size) {
          element.find('.modal-dialog').addClass('modal-' + scope.size);
        }

        if (element.find('#sigma-container').length > 0) {
          element.find('.modal-content')[0].style.overflowY = 'visible';
        }

        scope.close = function (evt) {
          var modal = $modalStack.getTop();
          if (modal && modal.value.backdrop && modal.value.backdrop != 'static' && (evt.target === evt.currentTarget)) {
            evt.preventDefault();
            evt.stopPropagation();
            $modalStack.dismiss(modal.key, 'backdrop click');
          }
        };

        // This property is only added to the scope for the purpose of detecting when this directive is rendered.
        // We can detect that by using this property in the template associated with this directive and then use
        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.
        scope.$isRendered = true;

        // Deferred object that will be resolved when this modal is render.
        var modalRenderDeferObj = $q.defer();
        // Observe function will be called on next digest cycle after compilation, ensuring that the DOM is ready.
        // In order to use this way of finding whether DOM is ready, we need to observe a scope property used in modal's template.
        attrs.$observe('modalRender', function (value) {
          if (value == 'true') {
            modalRenderDeferObj.resolve();
          }
        });

        modalRenderDeferObj.promise.then(function () {
          // trigger CSS transitions
          scope.animate = true;

          var inputsWithAutofocus = element[0].querySelectorAll('[autofocus]');
          /**
           * Auto-focusing of a freshly-opened modal element causes any child elements
           * with the autofocus attribute to lose focus. This is an issue on touch
           * based devices which will show and then hide the onscreen keyboard.
           * Attempts to refocus the autofocus element via JavaScript will not reopen
           * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus
           * the modal element if the modal does not contain an autofocus element.
           */
          if (inputsWithAutofocus.length) {
            inputsWithAutofocus[0].focus();
          } else {
            element[0].focus();
          }

          // Notify {@link $modalStack} that modal is rendered.
          var modal = $modalStack.getTop();
          if (modal) {
            $modalStack.modalRendered(modal.key);
          }
        });
        //Code for centering modals removed as modals are centered with CSS now

      }
    };
  }])

  .directive('modalAnimationClass', [
    function () {
      return {
        compile: function (tElement, tAttrs) {
          if (tAttrs.modalAnimation) {
            tElement.addClass(tAttrs.modalAnimationClass);
          }
        }
      };
    }])

  .directive('modalTransclude', function () {
    return {
      link: function($scope, $element, $attrs, controller, $transclude) {
        $transclude($scope.$parent, function(clone) {
          $element.empty();
          $element.append(clone);
        });
      }
    };
  })

  .factory('$modalStack', ['$animate', '$timeout', '$document', '$compile', '$rootScope', '$$stackedMap',
    function ($animate, $timeout, $document, $compile, $rootScope, $$stackedMap) {

      var OPENED_MODAL_CLASS = 'modal-open';

      var backdropDomEl, backdropScope;
      var openedWindows = $$stackedMap.createNew();
      var $modalStack = {};

      function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
          if (openedWindows.get(opened[i]).value.backdrop) {
            topBackdropIndex = i;
          }
        }
        return topBackdropIndex;
      }

      $rootScope.$watch(backdropIndex, function(newBackdropIndex){
        if (backdropScope) {
          backdropScope.index = newBackdropIndex;
        }
      });

      function removeModalWindow(modalInstance) {

        var body = $document.find('body').eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;

        //clean up the stack
        openedWindows.remove(modalInstance);

        //remove window DOM element
        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {
          body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);
          checkRemoveBackdrop();
        });
      }

      function checkRemoveBackdrop() {
          //remove backdrop if no longer needed
          if (backdropDomEl && backdropIndex() == -1) {
            var backdropScopeRef = backdropScope;
            removeAfterAnimate(backdropDomEl, backdropScope, function () {
              backdropScopeRef = null;
            });
            backdropDomEl = undefined;
            backdropScope = undefined;
          }
      }

      function removeAfterAnimate(domEl, scope, done) {
        // Closing animation
        scope.animate = false;

        if (domEl.attr('modal-animation') && $animate.enabled()) {
          // transition out
          domEl.one('$animate:close', function closeFn() {
            $rootScope.$evalAsync(afterAnimating);
          });
        } else {
          // Ensure this call is async
          $timeout(afterAnimating);
        }

        function afterAnimating() {
          if (afterAnimating.done) {
            return;
          }
          afterAnimating.done = true;

          domEl.remove();
          scope.$destroy();
          if (done) {
            done();
          }
        }
      }

      $document.bind('keydown', function (evt) {
        var modal;

        if (evt.which === 27) {
          modal = openedWindows.top();
          if (modal && modal.value.keyboard) {
            evt.preventDefault();
            $rootScope.$apply(function () {
              $modalStack.dismiss(modal.key, 'escape key press');
            });
          }
        }
      });

      $modalStack.open = function (modalInstance, modal) {

        var modalOpener = $document[0].activeElement;

        openedWindows.add(modalInstance, {
          deferred: modal.deferred,
          renderDeferred: modal.renderDeferred,
          modalScope: modal.scope,
          backdrop: modal.backdrop,
          keyboard: modal.keyboard
        });

        var body = $document.find('body').eq(0),
            currBackdropIndex = backdropIndex();

        if (currBackdropIndex >= 0 && !backdropDomEl) {
          backdropScope = $rootScope.$new(true);
          backdropScope.index = currBackdropIndex;
          var angularBackgroundDomEl = angular.element('<div modal-backdrop="modal-backdrop"></div>');
          angularBackgroundDomEl.attr('backdrop-class', modal.backdropClass);
          if (modal.animation) {
            angularBackgroundDomEl.attr('modal-animation', 'true');
          }
          backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope);
          body.append(backdropDomEl);
        }

        var angularDomEl = angular.element('<div modal-window="modal-window"></div>');
        angularDomEl.attr({
          'template-url': modal.windowTemplateUrl,
          'window-class': modal.windowClass,
          'size': modal.size,
          'index': openedWindows.length() - 1,
          'animate': 'animate'
        }).html(modal.content);
        if (modal.animation) {
          angularDomEl.attr('modal-animation', 'true');
        }

        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        openedWindows.top().value.modalOpener = modalOpener;
        body.append(modalDomEl);
        body.addClass(OPENED_MODAL_CLASS);
      };

      function broadcastClosing(modalWindow, resultOrReason, closing) {
          return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
      }

      $modalStack.close = function (modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, result, true)) {
          modalWindow.value.deferred.resolve(result);
          removeModalWindow(modalInstance);
          modalWindow.value.modalOpener.focus();
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismiss = function (modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
          modalWindow.value.deferred.reject(reason);
          removeModalWindow(modalInstance);
          modalWindow.value.modalOpener.focus();
          return true;
        }
        return !modalWindow;
      };

      $modalStack.dismissAll = function (reason) {
        var topModal = this.getTop();
        while (topModal && this.dismiss(topModal.key, reason)) {
          topModal = this.getTop();
        }
      };

      $modalStack.getTop = function () {
        return openedWindows.top();
      };

      $modalStack.modalRendered = function (modalInstance) {
        var modalWindow = openedWindows.get(modalInstance);
        if (modalWindow) {
          modalWindow.value.renderDeferred.resolve();
        }
      };

      return $modalStack;
    }])

  .provider('$modal', function () {

    var $modalProvider = {
      options: {
        animation: true,
        backdrop: true, //can also be false or 'static'
        keyboard: true
      },
      $get: ['$injector', '$rootScope', '$q', '$templateRequest', '$controller', '$modalStack',
        function ($injector, $rootScope, $q, $templateRequest, $controller, $modalStack) {

          var $modal = {};

          function getTemplatePromise(options) {
            return options.template ? $q.when(options.template) :
              $templateRequest(angular.isFunction(options.templateUrl) ? (options.templateUrl)() : options.templateUrl);
          }

          function getResolvePromises(resolves) {
            var promisesArr = [];
            angular.forEach(resolves, function (value) {
              if (angular.isFunction(value) || angular.isArray(value)) {
                promisesArr.push($q.when($injector.invoke(value)));
              }
            });
            return promisesArr;
          }

          $modal.open = function (modalOptions) {

            var modalResultDeferred = $q.defer();
            var modalOpenedDeferred = $q.defer();
            var modalRenderDeferred = $q.defer();

            //prepare an instance of a modal to be injected into controllers and returned to a caller
            var modalInstance = {
              result: modalResultDeferred.promise,
              opened: modalOpenedDeferred.promise,
              rendered: modalRenderDeferred.promise,
              close: function (result) {
                return $modalStack.close(modalInstance, result);
              },
              dismiss: function (reason) {
                return $modalStack.dismiss(modalInstance, reason);
              }
            };

            //merge and clean up options
            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
            modalOptions.resolve = modalOptions.resolve || {};

            //verify options
            if (!modalOptions.template && !modalOptions.templateUrl) {
              throw new Error('One of template or templateUrl options is required.');
            }

            var templateAndResolvePromise =
              $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));


            templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {

              var modalScope = (modalOptions.scope || $rootScope).$new();
              modalScope.$close = modalInstance.close;
              modalScope.$dismiss = modalInstance.dismiss;

              var ctrlInstance, ctrlLocals = {};
              var resolveIter = 1;

              //controllers
              if (modalOptions.controller) {
                ctrlLocals.$scope = modalScope;
                ctrlLocals.$modalInstance = modalInstance;
                angular.forEach(modalOptions.resolve, function (value, key) {
                  ctrlLocals[key] = tplAndVars[resolveIter++];
                });

                ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                if (modalOptions.controllerAs) {
                  modalScope[modalOptions.controllerAs] = ctrlInstance;
                }
              }

              $modalStack.open(modalInstance, {
                scope: modalScope,
                deferred: modalResultDeferred,
                renderDeferred: modalRenderDeferred,
                content: tplAndVars[0],
                animation: modalOptions.animation,
                backdrop: modalOptions.backdrop,
                keyboard: modalOptions.keyboard,
                backdropClass: modalOptions.backdropClass,
                windowClass: modalOptions.windowClass,
                windowTemplateUrl: modalOptions.windowTemplateUrl,
                size: modalOptions.size
              });

              //HPE Elements Modification - destroy modal on state change
              $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams) {
                if(modalInstance && modalInstance.close) modalInstance.close();
              });

            }, function resolveError(reason) {
              modalResultDeferred.reject(reason);
            });

            templateAndResolvePromise.then(function () {
              modalOpenedDeferred.resolve(true);
            }, function (reason) {
              modalOpenedDeferred.reject(reason);
            });

            return modalInstance;
          };

          return $modal;
        }]
    };

    return $modalProvider;
  });

angular.module('ui.bootstrap.pagination', [])

.controller('PaginationController', ['$scope', '$attrs', '$parse', function ($scope, $attrs, $parse) {
  var self = this,
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;

  this.init = function(ngModelCtrl_, config) {
    ngModelCtrl = ngModelCtrl_;
    this.config = config;

    ngModelCtrl.$render = function() {
      self.render();
    };

    if ($attrs.itemsPerPage) {
      $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
        self.itemsPerPage = parseInt(value, 10);
        $scope.totalPages = self.calculateTotalPages();
      });
    } else {
      this.itemsPerPage = config.itemsPerPage;
    }

    $scope.$watch('totalItems', function() {
      $scope.totalPages = self.calculateTotalPages();
    });

    $scope.$watch('totalPages', function(value) {
      setNumPages($scope.$parent, value); // Readonly variable

      if ( $scope.page > value ) {
        $scope.selectPage(value);
      } else {
        ngModelCtrl.$render();
      }
    });
  };

  this.calculateTotalPages = function() {
    var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
    return Math.max(totalPages || 0, 1);
  };

  this.render = function() {
    $scope.page = parseInt(ngModelCtrl.$viewValue, 10) || 1;
  };

  $scope.selectPage = function(page, evt) {
    if ( $scope.page !== page && page > 0 && page <= $scope.totalPages) {
      if (evt && evt.target) {
        evt.target.blur();
      }
      ngModelCtrl.$setViewValue(page);
      ngModelCtrl.$render();
    }
  };

  $scope.getText = function( key ) {
    return $scope[key + 'Text'] || self.config[key + 'Text'];
  };
  $scope.noPrevious = function() {
    return $scope.page === 1;
  };
  $scope.noNext = function() {
    return $scope.page === $scope.totalPages;
  };
}])

.constant('paginationConfig', {
  itemsPerPage: 10,
  boundaryLinks: false,
  directionLinks: true,
  firstText: 'First',
  previousText: 'Previous',
  nextText: 'Next',
  lastText: 'Last',
  rotate: true
})

.directive('pagination', ['$parse', 'paginationConfig', function($parse, paginationConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      firstText: '@',
      previousText: '@',
      nextText: '@',
      lastText: '@',
      tabIndex: '=?'
    },
    require: ['pagination', '?ngModel'],
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pagination.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      // Setup configuration parameters
      var maxSize = angular.isDefined(attrs.maxSize) ? scope.$parent.$eval(attrs.maxSize) : paginationConfig.maxSize,
          rotate = angular.isDefined(attrs.rotate) ? scope.$parent.$eval(attrs.rotate) : paginationConfig.rotate;
      scope.boundaryLinks = angular.isDefined(attrs.boundaryLinks) ? scope.$parent.$eval(attrs.boundaryLinks) : paginationConfig.boundaryLinks;
      scope.directionLinks = angular.isDefined(attrs.directionLinks) ? scope.$parent.$eval(attrs.directionLinks) : paginationConfig.directionLinks;

      paginationCtrl.init(ngModelCtrl, paginationConfig);

      if (attrs.maxSize) {
        scope.$parent.$watch($parse(attrs.maxSize), function(value) {
          maxSize = parseInt(value, 10);
          paginationCtrl.render();
        });
      }

      // Create page object used in template
      function makePage(number, text, isActive) {
        return {
          number: number,
          text: text,
          active: isActive
        };
      }

      function getPages(currentPage, totalPages) {
        var pages = [];

        // Default page limits
        var startPage = 1, endPage = totalPages;
        var isMaxSized = ( angular.isDefined(maxSize) && maxSize < totalPages );

        // recompute if maxSize
        if ( isMaxSized ) {
          if ( rotate ) {
            // Current page is displayed in the middle of the visible ones
            startPage = Math.max(currentPage - Math.floor(maxSize/2), 1);
            endPage   = startPage + maxSize - 1;

            // Adjust if limit is exceeded
            if (endPage > totalPages) {
              endPage   = totalPages;
              startPage = endPage - maxSize + 1;
            }
          } else {
            // Visible pages are paginated with maxSize
            startPage = ((Math.ceil(currentPage / maxSize) - 1) * maxSize) + 1;

            // Adjust last page if limit is exceeded
            endPage = Math.min(startPage + maxSize - 1, totalPages);
          }
        }

        // Add page number links
        for (var number = startPage; number <= endPage; number++) {
          var page = makePage(number, number, number === currentPage);
          pages.push(page);
        }

        // Add links to move between page sets
        if ( isMaxSized && ! rotate ) {
          if ( startPage > 1 ) {
            var previousPageSet = makePage(startPage - 1, '...', false);
            pages.unshift(previousPageSet);
          }

          if ( endPage < totalPages ) {
            var nextPageSet = makePage(endPage + 1, '...', false);
            pages.push(nextPageSet);
          }
        }

        return pages;
      }

      var originalRender = paginationCtrl.render;
      paginationCtrl.render = function() {
        originalRender();
        if (scope.page > 0 && scope.page <= scope.totalPages) {
          scope.pages = getPages(scope.page, scope.totalPages);
        }
      };
    }
  };
}])

.constant('pagerConfig', {
  itemsPerPage: 10,
  previousText: 'Â« Previous',
  nextText: 'Next Â»',
  align: true
})

.directive('pager', ['pagerConfig', function(pagerConfig) {
  return {
    restrict: 'EA',
    scope: {
      totalItems: '=',
      previousText: '@',
      nextText: '@'
    },
    require: ['pager', '?ngModel'],
    controller: 'PaginationController',
    templateUrl: 'template/pagination/pager.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if (!ngModelCtrl) {
         return; // do nothing if no ng-model
      }

      scope.align = angular.isDefined(attrs.align) ? scope.$parent.$eval(attrs.align) : pagerConfig.align;
      paginationCtrl.init(ngModelCtrl, pagerConfig);
    }
  };
}]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module( 'ui.bootstrap.tooltip', [ 'ui.bootstrap.position', 'ui.bootstrap.bindHtml' ] )

/**
 * The $tooltip service creates tooltip- and popover-like directives as well as
 * houses global options for them.
 */
.provider( '$tooltip', function () {
  // The default options tooltip and popover.
  var defaultOptions = {
    placement: 'top',
    animation: true,
    popupDelay: 0,
    useContentExp: false
  };

  // Default hide triggers for each show trigger
  var triggerMap = {
    'mouseenter': 'mouseleave',
    'click': 'click',
    'focus': 'blur'
  };

  // The options specified to the provider globally.
  var globalOptions = {};

  /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
	this.options = function( value ) {
		angular.extend( globalOptions, value );
	};

  /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
   */
  this.setTriggers = function setTriggers ( triggers ) {
    angular.extend( triggerMap, triggers );
  };

  /**
   * This is a helper function for translating camel-case to snake-case.
   */
  function snake_case(name){
    var regexp = /[A-Z]/g;
    var separator = '-';
    return name.replace(regexp, function(letter, pos) {
      return (pos ? separator : '') + letter.toLowerCase();
    });
  }

  /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */

  //HPE Modification to make sure the popover does not get cut off when the viewport is reduced - Added Elements safeTimeout  service.
  this.$get = [ '$window', '$compile', '$timeout', '$document', '$position', '$interpolate','safeTimeout', function ( $window, $compile, $timeout, $document, $position, $interpolate, safeTimeout ) {
    return function $tooltip ( type, prefix, defaultTriggerShow, options ) {
      options = angular.extend( {}, defaultOptions, globalOptions, options );

      /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
      function getTriggers ( trigger ) {
        var show = trigger || options.trigger || defaultTriggerShow;
        var hide = triggerMap[show] || show;
        return {
          show: show,
          hide: hide
        };
      }

      var directiveName = snake_case( type );

      var startSym = $interpolate.startSymbol();
      var endSym = $interpolate.endSymbol();
      var template =
        '<div '+ directiveName +'-popup '+
          'title="'+startSym+'title'+endSym+'" '+
          (options.useContentExp ?
            'content-exp="contentExp()" ' :
            'content="'+startSym+'content'+endSym+'" ') +
          'placement="'+startSym+'placement'+endSym+'" '+
          'popup-class="'+startSym+'popupClass'+endSym+'" '+
          'animation="animation" '+
          'is-open="isOpen"'+
          'origin-scope="origScope" '+
          '>'+
        '</div>';

      return {
        restrict: 'EA',
        compile: function (tElem, tAttrs) {
          var tooltipLinker = $compile( template );

          return function link ( scope, element, attrs, tooltipCtrl ) {
            var tooltip;
            var tooltipLinkedScope;
            var transitionTimeout;
            var popupTimeout;
            var appendToBody = angular.isDefined( options.appendToBody ) ? options.appendToBody : false;
            var triggers = getTriggers( undefined );
            var hasEnableExp = angular.isDefined(attrs[prefix+'Enable']);
            var ttScope = scope.$new(true);

             //HPE Modification to make sure the popover does not get cut off when the viewport is reduced.
            var popoverSafeTimeout = safeTimeout.create(ttScope);
             //HPE Modification to make sure the popover does not get cut off when the viewport is reduced.


            var positionTooltip = function () {
              if (!tooltip) { return; }

              var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
              ttPosition.top += 'px';
              ttPosition.left += 'px';

              // Now set the calculated positioning.
              tooltip.css( ttPosition );
            };

            // Set up the correct scope to allow transclusion later
            ttScope.origScope = scope;

            // By default, the tooltip is not open.
            // TODO add ability to start tooltip opened
            ttScope.isOpen = false;

            function toggleTooltipBind () {
              if ( ! ttScope.isOpen ) {
                showTooltipBind();
              } else {
                hideTooltipBind();
              }
            }

            // Show the tooltip with delay if specified, otherwise show it immediately
            function showTooltipBind() {
              if(hasEnableExp && !scope.$eval(attrs[prefix+'Enable'])) {
                return;
              }

              prepareTooltip();

              if ( ttScope.popupDelay ) {
                // Do nothing if the tooltip was already scheduled to pop-up.
                // This happens if show is triggered multiple times before any hide is triggered.
                if (!popupTimeout) {
                  popupTimeout = $timeout( show, ttScope.popupDelay, false );
                  popupTimeout.then(function(reposition){reposition();});
                }
              } else {
                show()();
              }
            }

            function hideTooltipBind () {
              scope.$apply(function () {
                hide();
              });
            }

            // Show the tooltip popup element.
            function show() {

              popupTimeout = null;

              // If there is a pending remove transition, we must cancel it, lest the
              // tooltip be mysteriously removed.
              if ( transitionTimeout ) {
                $timeout.cancel( transitionTimeout );
                transitionTimeout = null;
              }

              // Don't show empty tooltips.
              if ( !(options.useContentExp ? ttScope.contentExp() : ttScope.content) ) {
                return angular.noop;
              }

              createTooltip();

              // Set the initial positioning.
              tooltip.css({ top: 0, left: 0, display: 'block' });
              ttScope.$digest();

              positionTooltip();

              // And show the tooltip.
              ttScope.isOpen = true;
              ttScope.$apply(); // digest required as $apply is not called

              // Return positioning function as promise callback for correct
              // positioning after draw.
              return positionTooltip;
            }

            // Hide the tooltip popup element.
            function hide() {

              // HPE Elements Modification

              // ensure scope exists before doing anything
              if (!ttScope) {
                return;
              }
              // End HPE Elements Modification

              // First things first: we don't show it anymore.
              ttScope.isOpen = false;

              //if tooltip is going to be shown after delay, we must cancel this
              $timeout.cancel( popupTimeout );
              popupTimeout = null;

              // And now we remove it from the DOM. However, if we have animation, we
              // need to wait for it to expire beforehand.
              // FIXME: this is a placeholder for a port of the transitions library.
              if ( ttScope.animation ) {
                if (!transitionTimeout) {
                  transitionTimeout = $timeout(removeTooltip, 500);
                }
              } else {
                removeTooltip();
              }
            }

            function createTooltip() {
              // There can only be one tooltip element per directive shown at once.
              if (tooltip) {
                removeTooltip();
              }
              tooltipLinkedScope = ttScope.$new();
              tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
                if ( appendToBody ) {
                  $document.find( 'body' ).append( tooltip );
                } else {
                  element.after( tooltip );
                }
              });

              tooltipLinkedScope.$watch(function () {
                $timeout(positionTooltip, 0, false);
              });

              if (options.useContentExp) {
                tooltipLinkedScope.$watch('contentExp()', function (val) {
                  if (!val && ttScope.isOpen ) {
                    hide();
                  }
                });
              }
            }

            function removeTooltip() {
              transitionTimeout = null;
              if (tooltip) {
                tooltip.remove();
                tooltip = null;
              }
              if (tooltipLinkedScope) {
                tooltipLinkedScope.$destroy();
                tooltipLinkedScope = null;
              }
            }

            function prepareTooltip() {
              prepPopupClass();
              prepPlacement();
              prepPopupDelay();
            }

            ttScope.contentExp = function () {
              return scope.$eval(attrs[type]);
            };

            /**
             * Observe the relevant attributes.
             */
            if (!options.useContentExp) {
              attrs.$observe( type, function ( val ) {
                ttScope.content = val;

                if (!val && ttScope.isOpen ) {
                  hide();
                }
              });
            }

            attrs.$observe( 'disabled', function ( val ) {
              if (val && ttScope.isOpen ) {
                hide();
              }
            });

            attrs.$observe( prefix+'Title', function ( val ) {
              ttScope.title = val;
            });

            function prepPopupClass() {
              ttScope.popupClass = attrs[prefix + 'Class'];
            }

            function prepPlacement() {
              var val = attrs[ prefix + 'Placement' ];
              ttScope.placement = angular.isDefined( val ) ? val : options.placement;

              var popoverCreated = ttScope.popoverCreated;

              //HPE Modification to make sure the popover does not get cut off when the viewport is reduced.
              if (popoverCreated === undefined && (ttScope.placement.indexOf("top") !== -1 || ttScope.placement.indexOf("bottom") !== -1)) {
                // Watch for popover added to the DOM
                scope.$watch(function () {
                 return element.siblings(".popover").length;
                }, function (nv, ov) {
                 if (!angular.equals(nv, ov) && nv > 0) {
                     // Added timeout to make sure the popover is available.
                     popoverSafeTimeout.timeout(function() {
                        // Call the adjustment method.
                        calculateLeftOffSet();
                     });
                   }
                });

                // remember this popover has been created and additional watches are not needed
                ttScope.popoverCreated = true;
              }
              //HPE Modification to make sure the popover does not get cut off when the viewport is reduced.
            }

            //HPE Modification to make sure the popover does not get cut off when the viewport is reduced.
            $window.addEventListener('resize', function() {
              if(element.siblings(".popover").length > 0)
                 hideTooltipBind();
            });


            function calculateLeftOffSet() {
               var popover = angular.element(element[0].nextSibling);
               // Make sure that the clicked item is not a text.
               if(popover[0].nodeType != 3) {
                 var clientRect = popover[0].getBoundingClientRect();
                 var offsetLeft = clientRect.left + $window.pageXOffset;
                 var arrow = angular.element(popover[0].getElementsByClassName("arrow"));
                 if (offsetLeft < 0) {
                   // It's off the left side of the window, so add a margin to render it flush with the window.
                   //Adding a random number 10 to adjust the pixels to the left.
                   popover.css("margin-left", (-offsetLeft + 10) + "px");
                   // Move the arrow back left so it's in the original position relative to the control
                   arrow.css("margin-left", (offsetLeft - 10) + "px");
                 }
               }
            }
             //HPE Modification to make sure the popover does not get cut off when the viewport is reduced.

            function prepPopupDelay() {
              var val = attrs[ prefix + 'PopupDelay' ];
              var delay = parseInt( val, 10 );
              ttScope.popupDelay = ! isNaN(delay) ? delay : options.popupDelay;
            }

            var unregisterTriggers = function () {
              element.unbind(triggers.show, showTooltipBind);
              element.unbind(triggers.hide, hideTooltipBind);
            };

            function prepTriggers() {
              var val = attrs[ prefix + 'Trigger' ];
              unregisterTriggers();

              triggers = getTriggers( val );

              if ( triggers.show === triggers.hide ) {
                element.bind( triggers.show, toggleTooltipBind );
              } else {
                element.bind( triggers.show, showTooltipBind );
                element.bind( triggers.hide, hideTooltipBind );
              }
            }
            prepTriggers();

            var animation = scope.$eval(attrs[prefix + 'Animation']);
            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;

            var appendToBodyVal = scope.$eval(attrs[prefix + 'AppendToBody']);
            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;

            // if a tooltip is attached to <body> we need to remove it on
            // location change as its parent scope will probably not be destroyed
            // by the change.
            if ( appendToBody ) {
              scope.$on('$locationChangeSuccess', function closeTooltipOnLocationChangeSuccess () {
              if ( ttScope.isOpen ) {
                hide();
              }
            });
            }

            // Make sure tooltip is destroyed and removed.
            scope.$on('$destroy', function onDestroyTooltip() {
              $timeout.cancel( transitionTimeout );
              $timeout.cancel( popupTimeout );
              unregisterTriggers();
              removeTooltip();
              ttScope = null;
            });
          };
        }
      };
    };
  }];
})

// This is mostly ngInclude code but with a custom scope
.directive( 'tooltipTemplateTransclude', [
         '$animate', '$sce', '$compile', '$templateRequest',
function ($animate ,  $sce ,  $compile ,  $templateRequest) {
  return {
    link: function ( scope, elem, attrs ) {
      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);

      var changeCounter = 0,
        currentScope,
        previousElement,
        currentElement;

      var cleanupLastIncludeContent = function() {
        if (previousElement) {
          previousElement.remove();
          previousElement = null;
        }
        if (currentScope) {
          currentScope.$destroy();
          currentScope = null;
        }
        if (currentElement) {
          $animate.leave(currentElement).then(function() {
            previousElement = null;
          });
          previousElement = currentElement;
          currentElement = null;
        }
      };

      scope.$watch($sce.parseAsResourceUrl(attrs.tooltipTemplateTransclude), function (src) {
        var thisChangeId = ++changeCounter;

        if (src) {
          //set the 2nd param to true to ignore the template request error so that the inner
          //contents and scope can be cleaned up.
          $templateRequest(src, true).then(function(response) {
            if (thisChangeId !== changeCounter) { return; }
            var newScope = origScope.$new();
            var template = response;

            var clone = $compile(template)(newScope, function(clone) {
              cleanupLastIncludeContent();
              $animate.enter(clone, elem);
            });

            currentScope = newScope;
            currentElement = clone;

            currentScope.$emit('$includeContentLoaded', src);
          }, function() {
            if (thisChangeId === changeCounter) {
              cleanupLastIncludeContent();
              scope.$emit('$includeContentError', src);
            }
          });
          scope.$emit('$includeContentRequested', src);
        } else {
          cleanupLastIncludeContent();
        }
      });

      scope.$on('$destroy', cleanupLastIncludeContent);
    }
  };
}])

/**
 * Note that it's intentional that these classes are *not* applied through $animate.
 * They must not be animated as they're expected to be present on the tooltip on
 * initialization.
 */
.directive('tooltipClasses', function () {
  return {
    restrict: 'A',
    link: function (scope, element, attrs) {
      if (scope.placement) {
        element.addClass(scope.placement);
      }
      if (scope.popupClass) {
        element.addClass(scope.popupClass);
      }
      if (scope.animation()) {
        element.addClass(attrs.tooltipAnimationClass);
      }
    }
  };
})

.directive( 'tooltipPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-popup.html'
  };
})

.directive( 'tooltip', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'tooltip', 'tooltip', 'mouseenter' );
}])

.directive( 'tooltipTemplatePopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'template/tooltip/tooltip-template-popup.html'
  };
})

.directive( 'tooltipTemplate', [ '$tooltip', function ( $tooltip ) {
  return $tooltip('tooltipTemplate', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}])

.directive( 'tooltipHtmlPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-popup.html'
  };
})

.directive( 'tooltipHtml', [ '$tooltip', function ( $tooltip ) {
  return $tooltip('tooltipHtml', 'tooltip', 'mouseenter', {
    useContentExp: true
  });
}])

/*
Deprecated
*/
.directive( 'tooltipHtmlUnsafePopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/tooltip/tooltip-html-unsafe-popup.html'
  };
})

.value('tooltipHtmlUnsafeSuppressDeprecated', false)
.directive( 'tooltipHtmlUnsafe', [
          '$tooltip', 'tooltipHtmlUnsafeSuppressDeprecated', '$log',
function ( $tooltip ,  tooltipHtmlUnsafeSuppressDeprecated ,  $log) {
  if (!tooltipHtmlUnsafeSuppressDeprecated) {
    $log.warn('tooltip-html-unsafe is now deprecated. Use tooltip-html or tooltip-template instead.');
  }
  return $tooltip( 'tooltipHtmlUnsafe', 'tooltip', 'mouseenter' );
}]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html popovers, and selector delegatation.
 */
angular.module( 'ui.bootstrap.popover', [ 'ui.bootstrap.tooltip' ] )

.directive( 'popoverTemplatePopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { title: '@', contentExp: '&', placement: '@', popupClass: '@', animation: '&', isOpen: '&',
      originScope: '&' },
    templateUrl: 'template/popover/popover-template.html'
  };
})

.directive( 'popoverTemplate', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'popoverTemplate', 'popover', 'click', {
    useContentExp: true
  } );
}])

.directive( 'popoverPopup', function () {
  return {
    restrict: 'EA',
    replace: true,
    scope: { title: '@', content: '@', placement: '@', popupClass: '@', animation: '&', isOpen: '&' },
    templateUrl: 'template/popover/popover.html'
  };
})

.directive( 'popover', [ '$tooltip', function ( $tooltip ) {
  return $tooltip( 'popover', 'popover', 'click' );
}]);

angular.module('ui.bootstrap.progressbar', [])

.constant('progressConfig', {
  animate: true,
  max: 100
})

.controller('ProgressController', ['$scope', '$attrs', 'progressConfig', function($scope, $attrs, progressConfig) {
    var self = this,
        animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;

    this.bars = [];
    $scope.max = angular.isDefined($scope.max) ? $scope.max : progressConfig.max;

    this.addBar = function(bar, element) {
        if ( !animate ) {
            element.css({'transition': 'none'});
        }

        this.bars.push(bar);

        bar.$watch('value', function( value ) {
            bar.percent = +(100 * value / $scope.max).toFixed(2);
        });

        bar.$on('$destroy', function() {
            element = null;
            self.removeBar(bar);
        });
    };

    this.removeBar = function(bar) {
        this.bars.splice(this.bars.indexOf(bar), 1);
    };
}])

.directive('progress', function() {
    return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        require: 'progress',
        scope: {},
        templateUrl: 'template/progressbar/progress.html'
    };
})

.directive('bar', function() {
    return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        require: '^progress',
        scope: {
            value: '=',
            max: '=?',
            type: '@'
        },
        templateUrl: 'template/progressbar/bar.html',
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element);
        }
    };
})

.directive('progressbar', function() {
    return {
        restrict: 'EA',
        replace: true,
        transclude: true,
        controller: 'ProgressController',
        scope: {
            value: '=',
            max: '=?',
            type: '@'
        },
        templateUrl: 'template/progressbar/progressbar.html',
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
    };
});

angular.module('ui.bootstrap.rating', [])

.constant('ratingConfig', {
  max: 5,
  stateOn: null,
  stateOff: null
})

.controller('RatingController', ['$scope', '$attrs', 'ratingConfig', function($scope, $attrs, ratingConfig) {
  var ngModelCtrl  = { $setViewValue: angular.noop };

  this.init = function(ngModelCtrl_) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.push(function(value) {
      if (angular.isNumber(value) && value << 0 !== value) {
        value = Math.round(value);
      }
      return value;
    });

    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;

    var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) :
                        new Array( angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max );
    $scope.range = this.buildTemplateObjects(ratingStates);
  };

  this.buildTemplateObjects = function(states) {
    for (var i = 0, n = states.length; i < n; i++) {
      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff }, states[i]);
    }
    return states;
  };

  $scope.rate = function(value) {
    if ( !$scope.readonly && value >= 0 && value <= $scope.range.length ) {
      ngModelCtrl.$setViewValue(value);
      ngModelCtrl.$render();
    }
  };

  $scope.enter = function(value) {
    if ( !$scope.readonly ) {
      $scope.value = value;
    }
    $scope.onHover({value: value});
  };

  $scope.reset = function() {
    $scope.value = ngModelCtrl.$viewValue;
    $scope.onLeave();
  };

  $scope.onKeydown = function(evt) {
    if (/(37|38|39|40)/.test(evt.which)) {
      evt.preventDefault();
      evt.stopPropagation();
      $scope.rate( $scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1) );
    }
  };

  this.render = function() {
    $scope.value = ngModelCtrl.$viewValue;
  };
}])

.directive('rating', function() {
  return {
    restrict: 'EA',
    require: ['rating', 'ngModel'],
    scope: {
      readonly: '=?',
      onHover: '&',
      onLeave: '&'
    },
    controller: 'RatingController',
    templateUrl: 'template/rating/rating.html',
    replace: true,
    link: function(scope, element, attrs, ctrls) {
      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
      ratingCtrl.init( ngModelCtrl );
    }
  };
});

/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */

angular.module('ui.bootstrap.tabs', [])

.controller('TabsetController', ['$scope', function TabsetCtrl($scope) {
  var ctrl = this,
      tabs = ctrl.tabs = $scope.tabs = [];

  ctrl.select = function(selectedTab) {
    angular.forEach(tabs, function(tab) {
      if (tab.active && tab !== selectedTab) {
        tab.active = false;
        tab.onDeselect();
      }
    });
    selectedTab.active = true;
    selectedTab.onSelect();
  };

  ctrl.addTab = function addTab(tab) {
    tabs.push(tab);
    // we can't run the select function on the first tab
    // since that would select it twice
    if (tabs.length === 1 && tab.active !== false) {
      tab.active = true;
    } else if (tab.active) {
      ctrl.select(tab);
    }
    else {
      tab.active = false;
    }
  };

  ctrl.removeTab = function removeTab(tab) {
    var index = tabs.indexOf(tab);
    //Select a new tab if the tab to be removed is selected and not destroyed
    if (tab.active && tabs.length > 1 && !destroyed) {
      //If this is the last tab, select the previous tab. else, the next tab.
      var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
      ctrl.select(tabs[newActiveIndex]);
    }
    tabs.splice(index, 1);
  };

  var destroyed;
  $scope.$on('$destroy', function() {
    destroyed = true;
  });
}])

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabset
 * @restrict EA
 *
 * @description
 * Tabset is the outer container for the tabs directive
 *
 * @param {boolean=} vertical Whether or not to use vertical styling for the tabs.
 * @param {boolean=} justified Whether or not to use justified styling for the tabs.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab heading="Tab 1"><b>First</b> Content!</tab>
      <tab heading="Tab 2"><i>Second</i> Content!</tab>
    </tabset>
    <hr />
    <tabset vertical="true">
      <tab heading="Vertical Tab 1"><b>First</b> Vertical Content!</tab>
      <tab heading="Vertical Tab 2"><i>Second</i> Vertical Content!</tab>
    </tabset>
    <tabset justified="true">
      <tab heading="Justified Tab 1"><b>First</b> Justified Content!</tab>
      <tab heading="Justified Tab 2"><i>Second</i> Justified Content!</tab>
    </tabset>
  </file>
</example>
 */
.directive('tabset', function() {
  return {
    restrict: 'EA',
    transclude: true,
    replace: true,
    scope: {
      type: '@'
    },
    controller: 'TabsetController',
    templateUrl: 'template/tabs/tabset.html',
    link: function(scope, element, attrs) {
      scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
      scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
    }
  };
})

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tab
 * @restrict EA
 *
 * @param {string=} heading The visible heading, or title, of the tab. Set HTML headings with {@link ui.bootstrap.tabs.directive:tabHeading tabHeading}.
 * @param {string=} select An expression to evaluate when the tab is selected.
 * @param {boolean=} active A binding, telling whether or not this tab is selected.
 * @param {boolean=} disabled A binding, telling whether or not this tab is disabled.
 *
 * @description
 * Creates a tab with a heading and content. Must be placed within a {@link ui.bootstrap.tabs.directive:tabset tabset}.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <div ng-controller="TabsDemoCtrl">
      <button class="btn btn-small" ng-click="items[0].active = true">
        Select item 1, using active binding
      </button>
      <button class="btn btn-small" ng-click="items[1].disabled = !items[1].disabled">
        Enable/disable item 2, using disabled binding
      </button>
      <br />
      <tabset>
        <tab heading="Tab 1">First Tab</tab>
        <tab select="alertMe()">
          <tab-heading><i class="icon-bell"></i> Alert me!</tab-heading>
          Second Tab, with alert callback and html heading!
        </tab>
        <tab ng-repeat="item in items"
          heading="{{item.title}}"
          disabled="item.disabled"
          active="item.active">
          {{item.content}}
        </tab>
      </tabset>
    </div>
  </file>
  <file name="script.js">
    function TabsDemoCtrl($scope) {
      $scope.items = [
        { title:"Dynamic Title 1", content:"Dynamic Item 0" },
        { title:"Dynamic Title 2", content:"Dynamic Item 1", disabled: true }
      ];

      $scope.alertMe = function() {
        setTimeout(function() {
          alert("You've selected the alert tab!");
        });
      };
    };
  </file>
</example>
 */

/**
 * @ngdoc directive
 * @name ui.bootstrap.tabs.directive:tabHeading
 * @restrict EA
 *
 * @description
 * Creates an HTML heading for a {@link ui.bootstrap.tabs.directive:tab tab}. Must be placed as a child of a tab element.
 *
 * @example
<example module="ui.bootstrap">
  <file name="index.html">
    <tabset>
      <tab>
        <tab-heading><b>HTML</b> in my titles?!</tab-heading>
        And some content, too!
      </tab>
      <tab>
        <tab-heading><i class="icon-heart"></i> Icon heading?!?</tab-heading>
        That's right.
      </tab>
    </tabset>
  </file>
</example>
 */
.directive('tab', ['$parse', '$log', function($parse, $log) {
  return {
    require: '^tabset',
    restrict: 'EA',
    replace: true,
    templateUrl: 'template/tabs/tab.html',
    transclude: true,
    scope: {
      active: '=?',
      heading: '@',
      align: '@',           //Added this to determine alignment as text-right,text-center or text-left
      onSelect: '&select', //This callback is called in contentHeadingTransclude
                          //once it inserts the tab's content into the dom
      onDeselect: '&deselect'
    },
    controller: function() {
      //Empty controller so other directives can require being 'under' a tab
    },
    compile: function(elm, attrs, transclude) {
      return function postLink(scope, elm, attrs, tabsetCtrl) {

        scope.$watch('active', function(active) {
          if (active) {
            tabsetCtrl.select(scope);
          }
        });

        scope.disabled = false;
        if ( attrs.disable ) {
          scope.$parent.$watch($parse(attrs.disable), function(value) {
            scope.disabled = !! value;
          });
        }

        // Deprecation support of "disabled" parameter
        // fix(tab): IE9 disabled attr renders grey text on enabled tab #2677
        // This code is duplicated from the lines above to make it easy to remove once
        // the feature has been completely deprecated
        if ( attrs.disabled ) {
          $log.warn('Use of "disabled" attribute has been deprecated, please use "disable"');
          scope.$parent.$watch($parse(attrs.disabled), function(value) {
            scope.disabled = !! value;
          });
        }

        scope.select = function() {
          if ( !scope.disabled ) {
            scope.active = true;
          }
        };

        tabsetCtrl.addTab(scope);
        scope.$on('$destroy', function() {
          tabsetCtrl.removeTab(scope);
        });

        //We need to transclude later, once the content container is ready.
        //when this link happens, we're inside a tab heading.
        scope.$transcludeFn = transclude;
      };
    }
  };
}])

.directive('tabHeadingTransclude', [function() {
  return {
    restrict: 'A',
    require: '^tab',
    link: function(scope, elm, attrs, tabCtrl) {
      scope.$watch('headingElement', function updateHeadingElement(heading) {
        if (heading) {
          elm.html('');
          elm.append(heading);
        }
      });
    }
  };
}])

.directive('tabContentTransclude', function() {
  return {
    restrict: 'A',
    require: '^tabset',
    link: function(scope, elm, attrs) {
      var tab = scope.$eval(attrs.tabContentTransclude);

      //Now our tab is ready to be transcluded: both the tab heading area
      //and the tab content area are loaded.  Transclude 'em both.
      tab.$transcludeFn(tab.$parent, function(contents) {
        angular.forEach(contents, function(node) {
          if (isTabHeading(node)) {
            //Let tabHeadingTransclude know.
            tab.headingElement = node;
          } else {
            elm.append(node);
          }
        });
      });
    }
  };
  function isTabHeading(node) {
    return node.tagName &&  (
      node.hasAttribute('tab-heading') ||
      node.hasAttribute('data-tab-heading') ||
      node.tagName.toLowerCase() === 'tab-heading' ||
      node.tagName.toLowerCase() === 'data-tab-heading'
    );
  }
})

;

angular.module('ui.bootstrap.timepicker', [])

.constant('timepickerConfig', {
  hourStep: 1,
  minuteStep: 1,
  showMeridian: true,
  meridians: null,
  readonlyInput: false,
  changeTotalTime: true,
  mousewheel: true,
  arrowkeys: true
})

.controller('TimepickerController', ['$scope', '$attrs', '$parse', '$log', '$locale', 'timepickerConfig', function($scope, $attrs, $parse, $log, $locale, timepickerConfig) {
  var selected = new Date(),
      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl
      meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;

  this.init = function( ngModelCtrl_, inputs ) {
    ngModelCtrl = ngModelCtrl_;
    ngModelCtrl.$render = this.render;

    ngModelCtrl.$formatters.unshift(function (modelValue) {
      return modelValue ? new Date( modelValue ) : null;
    });

    var hoursInputEl = inputs.eq(0),
        minutesInputEl = inputs.eq(1);

    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
    if ( mousewheel ) {
      this.setupMousewheelEvents( hoursInputEl, minutesInputEl );
    }

    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
    if (arrowkeys) {
      this.setupArrowkeyEvents( hoursInputEl, minutesInputEl );
    }

    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
    this.setupInputEvents( hoursInputEl, minutesInputEl );
  };

  var hourStep = timepickerConfig.hourStep;
  if ($attrs.hourStep) {
    $scope.$parent.$watch($parse($attrs.hourStep), function(value) {
      hourStep = parseInt(value, 10);
    });
  }

  var minuteStep = timepickerConfig.minuteStep;
  if ($attrs.minuteStep) {
    $scope.$parent.$watch($parse($attrs.minuteStep), function(value) {
      minuteStep = parseInt(value, 10);
    });
  }

  var changeTotalTime = timepickerConfig.changeTotalTime;
  if ($attrs.changeTotalTime) {
    $scope.$parent.$watch($parse($attrs.changeTotalTime), function(value) {
      changeTotalTime = value;
    });
  }

  // 12H / 24H mode
  $scope.showMeridian = timepickerConfig.showMeridian;
  if ($attrs.showMeridian) {
    $scope.$parent.$watch($parse($attrs.showMeridian), function(value) {
      $scope.showMeridian = !!value;

      if ( ngModelCtrl.$error.time ) {
        // Evaluate from template
        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
        if (angular.isDefined( hours ) && angular.isDefined( minutes )) {
          selected.setHours( hours );
          refresh();
        }
      } else {
        updateTemplate();
      }
    });
  }

  // Get $scope.hours in 24H mode if valid
  function getHoursFromTemplate ( ) {
    var hours = parseInt( $scope.hours, 10 );
    var valid = ( $scope.showMeridian ) ? (hours > 0 && hours < 13) : (hours >= 0 && hours < 24);
    if ( !valid ) {
      return undefined;
    }

    if ( $scope.showMeridian ) {
      if ( hours === 12 ) {
        hours = 0;
      }
      if ( $scope.meridian === meridians[1] ) {
        hours = hours + 12;
      }
    }
    return hours;
  }

  function getMinutesFromTemplate() {
    var minutes = parseInt($scope.minutes, 10);
    return ( minutes >= 0 && minutes < 60 ) ? minutes : undefined;
  }

  function pad( value ) {
    return ( angular.isDefined(value) && value.toString().length < 2 ) ? '0' + value : value.toString();
  }

  // Respond on mousewheel spin
  this.setupMousewheelEvents = function( hoursInputEl, minutesInputEl ) {
    var isScrollingUp = function(e) {
      if (e.originalEvent) {
        e = e.originalEvent;
      }
      //pick correct delta variable depending on event
      var delta = (e.wheelDelta) ? e.wheelDelta : -e.deltaY;
      return (e.detail || delta > 0);
    };

    hoursInputEl.bind('mousewheel wheel', function(e) {
      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementHours() : $scope.decrementHours() );
      e.preventDefault();
    });

    minutesInputEl.bind('mousewheel wheel', function(e) {
      $scope.$apply( (isScrollingUp(e)) ? $scope.incrementMinutes() : $scope.decrementMinutes() );
      e.preventDefault();
    });

  };

  // Respond on up/down arrowkeys
  this.setupArrowkeyEvents = function( hoursInputEl, minutesInputEl ) {
    hoursInputEl.bind('keydown', function(e) {
      if ( e.which === 38 ) { // up
        e.preventDefault();
        $scope.incrementHours();
        $scope.$apply();
      }
      else if ( e.which === 40 ) { // down
        e.preventDefault();
        $scope.decrementHours();
        $scope.$apply();
      }
    });

    minutesInputEl.bind('keydown', function(e) {
      if ( e.which === 38 ) { // up
        e.preventDefault();
        $scope.incrementMinutes();
        $scope.$apply();
      }
      else if ( e.which === 40 ) { // down
        e.preventDefault();
        $scope.decrementMinutes();
        $scope.$apply();
      }
    });
  };

  this.setupInputEvents = function( hoursInputEl, minutesInputEl ) {
    if ( $scope.readonlyInput ) {
      $scope.updateHours = angular.noop;
      $scope.updateMinutes = angular.noop;
      return;
    }

    var invalidate = function(invalidHours, invalidMinutes) {
      ngModelCtrl.$setViewValue( null );
      ngModelCtrl.$setValidity('time', false);
      if (angular.isDefined(invalidHours)) {
        $scope.invalidHours = invalidHours;
      }
      if (angular.isDefined(invalidMinutes)) {
        $scope.invalidMinutes = invalidMinutes;
      }
    };

    $scope.updateHours = function() {
      var hours = getHoursFromTemplate();

      if ( angular.isDefined(hours) ) {
        selected.setHours( hours );
        refresh( 'h' );
      } else {
        invalidate(true);
      }
    };

    hoursInputEl.bind('blur', function(e) {
      if ( !$scope.invalidHours && $scope.hours < 10) {
        $scope.$apply( function() {
          $scope.hours = pad( $scope.hours );
        });
      }
    });

    $scope.updateMinutes = function() {
      var minutes = getMinutesFromTemplate();

      if ( angular.isDefined(minutes) ) {
        selected.setMinutes( minutes );
        refresh( 'm' );
      } else {
        invalidate(undefined, true);
      }
    };

    minutesInputEl.bind('blur', function(e) {
      if ( !$scope.invalidMinutes && $scope.minutes < 10 ) {
        $scope.$apply( function() {
          $scope.minutes = pad( $scope.minutes );
        });
      }
    });

  };

  this.render = function() {
    var date = ngModelCtrl.$viewValue;

    if ( isNaN(date) ) {
      ngModelCtrl.$setValidity('time', false);
      $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
    } else {
      if ( date ) {
        selected = date;
      }
      makeValid();
      updateTemplate();
    }
  };

  // Call internally when we know that model is valid.
  function refresh( keyboardChange ) {
    makeValid();
    ngModelCtrl.$setViewValue( new Date(selected) );
    updateTemplate( keyboardChange );
  }

  function makeValid() {
    ngModelCtrl.$setValidity('time', true);
    $scope.invalidHours = false;
    $scope.invalidMinutes = false;
  }

  function updateTemplate( keyboardChange ) {
    var hours = selected.getHours(), minutes = selected.getMinutes();

    if ( $scope.showMeridian ) {
      hours = ( hours === 0 || hours === 12 ) ? 12 : hours % 12; // Convert 24 to 12 hour system
    }

    $scope.hours = keyboardChange === 'h' ? hours : pad(hours);
    if (keyboardChange !== 'm') {
      $scope.minutes = pad(minutes);
    }
    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
  }
  //Added for HPE-ELEMENTS
function mod(n, m) {
    return ((n % m) + m) % m;
}
//function modified for HPE-ELEMENTS to add option of not changing the total time
function addMinutes(minutes, type, changeTotTime) {

    if (changeTotTime === false) {
        if (type === 'H') {
            var newHour = (selected.getHours() + (minutes / 60)) % 24;
            if ($scope.showMeridian === true) {
               
                if ($scope.meridian === meridians[0]) {

                    newHour = mod(newHour, 12);

                } else if ($scope.meridian === meridians[1]) {

                    newHour = (newHour % 12) + 12;
                }
            }
            selected.setHours(newHour);

        } else if (type === 'M') {
            var newMin = mod((selected.getMinutes() + minutes), 60);
            selected.setMinutes(newMin);
        }
    } else {
        var dt = new Date(selected.getTime() + minutes * 60000);
        selected.setHours(dt.getHours(), dt.getMinutes());
    }

    refresh();

}
  //functions modified for HPE-ELEMENTS to pass type and chageTotalTime option
  $scope.incrementHours = function() {
    addMinutes( hourStep * 60 ,'H' , changeTotalTime);
  };
  $scope.decrementHours = function() {
    addMinutes( - hourStep * 60 ,'H', changeTotalTime);
  };
  $scope.incrementMinutes = function() {
    addMinutes( minuteStep ,'M', changeTotalTime);
  };
  $scope.decrementMinutes = function() {
    addMinutes( - minuteStep ,'M', changeTotalTime);
  };
  $scope.toggleMeridian = function() {
    addMinutes( 12 * 60 * (( selected.getHours() < 12 ) ? 1 : -1) );
  };
}])

.directive('timepicker', function () {
  return {
    restrict: 'EA',
    require: ['timepicker', '?^ngModel'],
    controller:'TimepickerController',
    replace: true,
    scope: {},
    templateUrl: 'template/timepicker/timepicker.html',
    link: function(scope, element, attrs, ctrls) {
      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];

      if ( ngModelCtrl ) {
        timepickerCtrl.init( ngModelCtrl, element.find('input') );
      }
    }
  };
});

angular.module('ui.bootstrap.transition', [])

.value('$transitionSuppressDeprecated', false)
/**
 * $transition service provides a consistent interface to trigger CSS 3 transitions and to be informed when they complete.
 * @param  {DOMElement} element  The DOMElement that will be animated.
 * @param  {string|object|function} trigger  The thing that will cause the transition to start:
 *   - As a string, it represents the css class to be added to the element.
 *   - As an object, it represents a hash of style attributes to be applied to the element.
 *   - As a function, it represents a function to be called that will cause the transition to occur.
 * @return {Promise}  A promise that is resolved when the transition finishes.
 */
.factory('$transition', [
        '$q', '$timeout', '$rootScope', '$log', '$transitionSuppressDeprecated',
function($q ,  $timeout ,  $rootScope ,  $log ,  $transitionSuppressDeprecated) {

  if (!$transitionSuppressDeprecated) {
    $log.warn('$transition is now deprecated. Use $animate from ngAnimate instead.');
  }

  var $transition = function(element, trigger, options) {
    options = options || {};
    var deferred = $q.defer();
    var endEventName = $transition[options.animation ? 'animationEndEventName' : 'transitionEndEventName'];

    var transitionEndHandler = function(event) {
      $rootScope.$apply(function() {
        element.unbind(endEventName, transitionEndHandler);
        deferred.resolve(element);
      });
    };

    if (endEventName) {
      element.bind(endEventName, transitionEndHandler);
    }

    // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
    $timeout(function() {
      if ( angular.isString(trigger) ) {
        element.addClass(trigger);
      } else if ( angular.isFunction(trigger) ) {
        trigger(element);
      } else if ( angular.isObject(trigger) ) {
        element.css(trigger);
      }
      //If browser does not support transitions, instantly resolve
      if ( !endEventName ) {
        deferred.resolve(element);
      }
    });

    // Add our custom cancel function to the promise that is returned
    // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
    // i.e. it will therefore never raise a transitionEnd event for that transition
    deferred.promise.cancel = function() {
      if ( endEventName ) {
        element.unbind(endEventName, transitionEndHandler);
      }
      deferred.reject('Transition cancelled');
    };

    return deferred.promise;
  };

  // Work out the name of the transitionEnd event
  var transElement = document.createElement('trans');
  var transitionEndEventNames = {
    'WebkitTransition': 'webkitTransitionEnd',
    'MozTransition': 'transitionend',
    'OTransition': 'oTransitionEnd',
    'transition': 'transitionend'
  };
  var animationEndEventNames = {
    'WebkitTransition': 'webkitAnimationEnd',
    'MozTransition': 'animationend',
    'OTransition': 'oAnimationEnd',
    'transition': 'animationend'
  };
  function findEndEventName(endEventNames) {
    for (var name in endEventNames){
      if (transElement.style[name] !== undefined) {
        return endEventNames[name];
      }
    }
  }
  $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
  $transition.animationEndEventName = findEndEventName(animationEndEventNames);
  return $transition;
}]);

angular.module('ui.bootstrap.typeahead', ['ui.bootstrap.position', 'ui.bootstrap.bindHtml'])

/**
 * A helper service that can parse typeahead's syntax (string provided by users)
 * Extracted to a separate service for ease of unit testing
 */
  .factory('typeaheadParser', ['$parse', function ($parse) {

  //                      00000111000000000000022200000000000000003333333333333330000000000044000
  var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;

  return {
    parse:function (input) {

      var match = input.match(TYPEAHEAD_REGEXP);
      if (!match) {
        throw new Error(
          'Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' +
            ' but got "' + input + '".');
      }

      return {
        itemName:match[3],
        source:$parse(match[4]),
        viewMapper:$parse(match[2] || match[1]),
        modelMapper:$parse(match[1])
      };
    }
  };
}])

  .directive('typeahead', ['$compile', '$parse', '$q', '$timeout', '$document', '$position', 'typeaheadParser',
    function ($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {

  var HOT_KEYS = [9, 13, 27, 38, 40];

  return {
    require:'ngModel',
    link:function (originalScope, element, attrs, modelCtrl) {

      //SUPPORTED ATTRIBUTES (OPTIONS)

      //minimal no of characters that needs to be entered before typeahead kicks-in
      var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;

      //minimal wait time after last character typed before typeahead kicks-in
      var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;

      //should it restrict model values to the ones selected from the popup only?
      var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;

      //binding to a variable that indicates if matches are being retrieved asynchronously
      var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;

     //added for elements to apply regex and class(now used in dynamic facets)
      var regex = originalScope.$eval(attrs.regex) || false;
      var applyClass = originalScope.$eval(attrs.applyClass) || false;

      //a callback executed when a match is selected
      var onSelectCallback = $parse(attrs.typeaheadOnSelect);

      var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;

      var appendToBody =  attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;

      var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;

      //INTERNAL VARIABLES

      //model setter executed upon match selection
      var $setModelValue = $parse(attrs.ngModel).assign;

      //expressions used by typeahead
      var parserResult = typeaheadParser.parse(attrs.typeahead);

      var hasFocus;

      //create a child scope for the typeahead directive so we are not polluting original scope
      //with typeahead-specific data (matches, query etc.)
      var scope = originalScope.$new();
      originalScope.$on('$destroy', function(){
        scope.$destroy();
      });

      // WAI-ARIA
      var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
      element.attr({
        'aria-autocomplete': 'list',
        'aria-expanded': false,
        'aria-owns': popupId
      });

      //pop-up element used to display matches
      var popUpEl = angular.element('<div typeahead-popup></div>');
      popUpEl.attr({
        id: popupId,
        matches: 'matches',
        active: 'activeIdx',
        select: 'select(activeIdx)',
        query: 'query',
        position: 'position',
        regex: regex,
        "apply\-class": applyClass
      });
      //custom item template
      if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
        popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
      }

      var resetMatches = function() {
        scope.matches = [];
        scope.activeIdx = -1;
        element.attr('aria-expanded', false);
      };

      var getMatchId = function(index) {
        return popupId + '-option-' + index;
      };

      // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.
      // This attribute is added or removed automatically when the `activeIdx` changes.
      scope.$watch('activeIdx', function(index) {
        if (index < 0) {
          element.removeAttr('aria-activedescendant');
        } else {
          element.attr('aria-activedescendant', getMatchId(index));
        }
      });

      var getMatchesAsync = function(inputValue) {

        var locals = {$viewValue: inputValue};
        isLoadingSetter(originalScope, true);
        $q.when(parserResult.source(originalScope, locals)).then(function(matches) {

          //it might happen that several async queries were in progress if a user were typing fast
          //but we are interested only in responses that correspond to the current view value
          var onCurrentRequest = (inputValue === modelCtrl.$viewValue);
          if (onCurrentRequest && hasFocus) {
            if (matches && matches.length > 0) {

              scope.activeIdx = focusFirst ? 0 : -1;
              scope.matches.length = 0;

              //transform labels
              for(var i=0; i<matches.length; i++) {
                locals[parserResult.itemName] = matches[i];
                scope.matches.push({
                  id: getMatchId(i),
                  label: parserResult.viewMapper(scope, locals),
                  model: matches[i]
                });
              }

              scope.query = inputValue;
              //position pop-up with matches - we need to re-calculate its position each time we are opening a window
              //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
              //due to other elements being rendered
              scope.position = appendToBody ? $position.offset(element) : $position.position(element);
              scope.position.top = scope.position.top + element.prop('offsetHeight');
              element.attr('aria-expanded', true);
            } else {
              resetMatches();
            }
          }
          if (onCurrentRequest) {
            isLoadingSetter(originalScope, false);
          }
        }, function(){
          resetMatches();
          isLoadingSetter(originalScope, false);
        });
      };

      resetMatches();

      //we need to propagate user's query so we can higlight matches
      scope.query = undefined;
      //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later
      var timeoutPromise;

      var scheduleSearchWithTimeout = function(inputValue) {
        timeoutPromise = $timeout(function () {
          getMatchesAsync(inputValue);
        }, waitTime);
      };

      var cancelPreviousTimeout = function() {
        if (timeoutPromise) {
          $timeout.cancel(timeoutPromise);
        }
      };

      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
      modelCtrl.$parsers.unshift(function (inputValue) {

        hasFocus = true;

        if (inputValue && inputValue.length >= minSearch) {
          if (waitTime > 0) {
            cancelPreviousTimeout();
            scheduleSearchWithTimeout(inputValue);
          } else {
            getMatchesAsync(inputValue);
          }
        } else {
          isLoadingSetter(originalScope, false);
          cancelPreviousTimeout();
          resetMatches();
        }

        if (isEditable) {
          return inputValue;
        } else {
          if (!inputValue) {
            // Reset in case user had typed something previously.
            modelCtrl.$setValidity('editable', true);
            return inputValue;
          } else {
            modelCtrl.$setValidity('editable', false);
            return undefined;
          }
        }
      });

      modelCtrl.$formatters.push(function (modelValue) {

        var candidateViewValue, emptyViewValue;
        var locals = {};

        // The validity may be set to false via $parsers (see above) if
        // the model is restricted to selected values. If the model
        // is set manually it is considered to be valid.
        if (!isEditable) {
          modelCtrl.$setValidity('editable', true);
        }

        if (inputFormatter) {

          locals.$model = modelValue;
          return inputFormatter(originalScope, locals);

        } else {

          //it might happen that we don't have enough info to properly render input value
          //we need to check for this situation and simply return model value if we can't apply custom formatting
          locals[parserResult.itemName] = modelValue;
          candidateViewValue = parserResult.viewMapper(originalScope, locals);
          locals[parserResult.itemName] = undefined;
          emptyViewValue = parserResult.viewMapper(originalScope, locals);

          return candidateViewValue!== emptyViewValue ? candidateViewValue : modelValue;
        }
      });

      scope.select = function (activeIdx) {
        //called from within the $digest() cycle
        var locals = {};
        var model, item;

        locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
        model = parserResult.modelMapper(originalScope, locals);
        $setModelValue(originalScope, model);
        modelCtrl.$setValidity('editable', true);
        modelCtrl.$setValidity('parse', true);

        onSelectCallback(originalScope, {
          $item: item,
          $model: model,
          $label: parserResult.viewMapper(originalScope, locals)
        });

        resetMatches();

        //return focus to the input element if a match was selected via a mouse click event
        // use timeout to avoid $rootScope:inprog error
        $timeout(function() { element[0].focus(); }, 0, false);
      };

      //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
      element.bind('keydown', function (evt) {

        //typeahead is open and an "interesting" key was pressed
        if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
          return;
        }

        // if there's nothing selected (i.e. focusFirst) and enter is hit, don't do anything
        if (scope.activeIdx == -1 && (evt.which === 13 || evt.which === 9)) {
          return;
        }

        evt.preventDefault();

        if (evt.which === 40) {
          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
          scope.$digest();

        } else if (evt.which === 38) {
          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
          scope.$digest();

        } else if (evt.which === 13 || evt.which === 9) {
          scope.$apply(function () {
            scope.select(scope.activeIdx);
          });

        } else if (evt.which === 27) {
          evt.stopPropagation();

          resetMatches();
          scope.$digest();
        }
      });

      element.bind('blur', function (evt) {
        hasFocus = false;

        //HPE Elements
        scope.activeIdx = -1;
        //End HPE Elements
      });

      // Keep reference to click handler to unbind it.
      var dismissClickHandler = function (evt) {
        if (element[0] !== evt.target) {
          resetMatches();
          scope.$digest();
        }
      };

      $document.bind('click', dismissClickHandler);

      originalScope.$on('$destroy', function(){
        $document.unbind('click', dismissClickHandler);
        if (appendToBody) {
          $popup.remove();
        }
        // Prevent jQuery cache memory leak
        popUpEl.remove();
      });

      var $popup = $compile(popUpEl)(scope);

      if (appendToBody) {
        $document.find('body').append($popup);
      } else {
        element.after($popup);
      }
    }
  };

}])

  .directive('typeaheadPopup', function () {
    return {
      restrict:'EA',
      scope:{
        matches:'=',
        query:'=',
        regex: '=?',
        applyClass: '=?',
        active:'=',
        position:'=',
        select:'&'
      },
      replace:true,
      templateUrl:'template/typeahead/typeahead-popup.html',
      link:function (scope, element, attrs) {

        scope.templateUrl = attrs.templateUrl;

        scope.isOpen = function () {
          return scope.matches.length > 0;
        };

        scope.isActive = function (matchIdx) {
          return scope.active == matchIdx;
        };

        scope.selectActive = function (matchIdx) {
          scope.active = matchIdx;
        };

        //HPE Elements
        scope.deselectActive = function (matchIdx) {
          if(scope.active === matchIdx) scope.active = -1;
        };
        //End HPE Elements

        scope.selectMatch = function (activeIdx) {
          scope.select({activeIdx:activeIdx});
        };
      }
    };
  })

  .directive('typeaheadMatch', ['$templateRequest', '$compile', '$parse', function ($templateRequest, $compile, $parse) {
    return {
      restrict:'EA',
      scope:{
        index:'=',
        match:'=',
        query:'=',
        regex: '=?',
        applyClass: '=?'
      },
      link:function (scope, element, attrs) {
        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'template/typeahead/typeahead-match.html';
        $templateRequest(tplUrl).then(function(tplContent) {
          $compile(tplContent.trim())(scope, function(clonedElement){
            element.replaceWith(clonedElement);
          });
        });
      }
    };
  }])

  .filter('typeaheadHighlight', function() {

    function escapeRegexp(queryToEscape) {
      return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
    }

    return function(matchItem, query,regex,applyClass) {

var finalStr = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
if(regex!=undefined && regex !=false)
{
 var countRegexp = new RegExp(regex);
 var match = countRegexp.exec(finalStr);
  if(match != null)
  {
  var finalStr = match[1] ? ('' + finalStr).replace(new RegExp(escapeRegexp(match[1]), 'gi'), '<span class="'+applyClass+'">$&</span>') : finalStr;
  }
}
 return finalStr;
   };
  });

angular.module("template/accordion/accordion-group.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion-group.html",
    "<div class=\"panel panel-default\">\n" +
    "  <div tabindex=\"0\" ng-click=\"toggleOpen()\" ng-keypress=\"($event.keyCode =='13' || $event.keyCode =='32') ? toggleOpen() : null \" class=\"accordion-toggle panel-heading \"  accordion-transclude=\"heading\" >\n" +
    "  <i ng-show=\"isOpen\"\" class=\"hpe-icon hpe-up hp-rotate-180 pull-right\"></i>" +
    "  <i ng-show=\"!isOpen\"\" class=\"hpe-icon hpe-up hp-rotate-270 pull-right\"></i>" +
    "  <h4 class=\"panel-title\">\n" +
    "<span ng-class=\"{'text-muted': isDisabled}\">{{heading}}</span>\n" +
    "    </h4>\n" +
    "  </div>\n" +
    "  <div class=\"panel-collapse collapse\" collapse=\"!isOpen\">\n" +
    "	  <div class=\"panel-body\" ng-transclude></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/accordion/accordion.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/accordion/accordion.html",
    "<div class=\"panel-group\" ng-transclude></div>");
}]);

angular.module("template/alert/alert.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/alert/alert.html",
    "<div class=\"alert\" ng-class=\"['alert-' + (type || 'warning'), closeable ? 'alert-dismissable' : null]\" role=\"alert\">\n" +
    "    <button ng-show=\"closeable\" type=\"button\" class=\"close\" ng-click=\"close()\">\n" +
    "        <span aria-hidden=\"true\" class=\"hpe-icon hpe-close\"></span>\n" +
    "        <span class=\"sr-only\">Close</span>\n" +
    "    </button>\n" +
    "    <div ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/carousel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/carousel.html",
    "<div ng-mouseenter=\"pause()\" ng-mouseleave=\"play()\" class=\"carousel\" ng-swipe-right=\"prev()\" ng-swipe-left=\"next()\">\n" +
    "    <ol class=\"carousel-indicators\" ng-show=\"slides.length > 1\">\n" +
    "        <li ng-repeat=\"slide in slides | orderBy:'index' track by $index\" ng-class=\"{active: isActive(slide)}\" ng-click=\"select(slide)\"></li>\n" +
    "    </ol>\n" +
    "    <div class=\"carousel-inner\" ng-transclude></div>\n" +
    "    <a class=\"left carousel-control\" ng-click=\"prev()\" ng-show=\"slides.length > 1\"><span class=\"glyphicon glyphicon-chevron-left\"></span></a>\n" +
    "    <a class=\"right carousel-control\" ng-click=\"next()\" ng-show=\"slides.length > 1\"><span class=\"glyphicon glyphicon-chevron-right\"></span></a>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/carousel/slide.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/carousel/slide.html",
    "<div ng-class=\"{\n" +
    "    'active': active\n" +
    "  }\" class=\"item text-center\" ng-transclude></div>\n" +
    "");
}]);

angular.module("template/datepicker/datepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/datepicker.html",
    "<div ng-switch=\"datepickerMode\" role=\"application\" ng-keydown=\"keydown($event)\">\n" +
    "  <daypicker ng-switch-when=\"day\" tabindex=\"0\"></daypicker>\n" +
    "  <monthpicker ng-switch-when=\"month\" tabindex=\"0\"></monthpicker>\n" +
    "  <yearpicker ng-switch-when=\"year\" tabindex=\"0\"></yearpicker>\n" +
    "</div>");
}]);

angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/day.html",
    "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"{{5 + showWeeks}}\"><button id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <th ng-show=\"showWeeks\" class=\"text-center\"></th>\n" +
    "      <th ng-repeat=\"label in labels track by $index\" class=\"text-center\"><small aria-label=\"{{label.full}}\">{{label.abbr}}</small></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-show=\"showWeeks\" class=\"text-center h6\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\" ng-class=\"dt.customClass\">\n" +
    "        <button type=\"button\" style=\"width:100%;\" class=\"btn btn-default btn-sm\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"{'text-muted': dt.secondary, 'text-info': dt.current}\">{{dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/month.html",
    "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th><button id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\">\n" +
    "        <button type=\"button\" style=\"width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"{'text-info': dt.current}\">{{dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/popup.html",
    "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\">\n" +
    "	<li ng-transclude></li>\n" +
    "	<li ng-if=\"showButtonBar\" style=\"padding:10px 9px 2px\">\n" +
    "		<span class=\"btn-group pull-left\">\n" +
    "			<button type=\"button\" class=\"btn btn-sm btn-info\" ng-click=\"select('today')\">{{ getText('current') }}</button>\n" +
    "			<button type=\"button\" class=\"btn btn-sm btn-danger\" ng-click=\"select(null)\">{{ getText('clear') }}</button>\n" +
    "		</span>\n" +
    "		<button type=\"button\" class=\"btn btn-sm btn-success pull-right\" ng-click=\"close()\">{{ getText('close') }}</button>\n" +
    "	</li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/year.html",
    "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-left\" ng-click=\"move(-1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-left\"></i></button></th>\n" +
    "      <th colspan=\"3\"><button id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" type=\"button\" class=\"btn btn-default btn-sm\" ng-click=\"toggleMode()\" ng-disabled=\"datepickerMode === maxMode\" tabindex=\"-1\" style=\"width:100%;\"><strong>{{title}}</strong></button></th>\n" +
    "      <th><button type=\"button\" class=\"btn btn-default btn-sm pull-right\" ng-click=\"move(1)\" tabindex=\"-1\"><i class=\"glyphicon glyphicon-chevron-right\"></i></button></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\">\n" +
    "        <button type=\"button\" style=\"width:100%;\" class=\"btn btn-default\" ng-class=\"{'btn-info': dt.selected, active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\"><span ng-class=\"{'text-info': dt.current}\">{{dt.label}}</span></button>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/modal/backdrop.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/backdrop.html",
    "<div class=\"modal-backdrop\"\n" +
    "     modal-animation-class=\"fade\"\n" +
    "     ng-class=\"{in: animate}\"\n" +
    "     ng-style=\"{'z-index': 10010 + (index && 1 || 0) + index*10}\"\n" +
    "></div>\n" +
    "");
}]);

angular.module("template/modal/window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/modal/window.html",
    "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\"\n" +
    "    modal-animation-class=\"fade\"\n" +
    "	ng-class=\"{in: animate}\" ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\" ng-click=\"close($event)\">\n" +
    "    <div class=\"modal-dialog\"><div class=\"modal-content clearfix\" modal-transclude></div></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/pagination/pager.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pager.html",
    "<ul class=\"pager\">\n" +
    "  <li ng-class=\"{disabled: noPrevious(), previous: align}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{getText('previous')}}</a></li>\n" +
    "  <li ng-class=\"{disabled: noNext(), next: align}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{getText('next')}}</a></li>\n" +
    "</ul>");
}]);

angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pagination.html",
    "<ul class=\"pagination\">\n" +
    "  <li ng-if=\"boundaryLinks\" ng-class=\"{disabled: noPrevious()}\"><a href ng-click=\"selectPage(1, $event)\">{{getText('first')}}</a></li>\n" +
    "  <li ng-if=\"directionLinks\" ng-class=\"{disabled: noPrevious()}\"><a href ng-click=\"selectPage(page - 1, $event)\">{{getText('previous')}}</a></li>\n" +
    "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active}\"><a href ng-click=\"selectPage(page.number, $event)\">{{page.text}}</a></li>\n" +
    "  <li ng-if=\"directionLinks\" ng-class=\"{disabled: noNext()}\"><a href ng-click=\"selectPage(page + 1, $event)\">{{getText('next')}}</a></li>\n" +
    "  <li ng-if=\"boundaryLinks\" ng-class=\"{disabled: noNext()}\"><a href ng-click=\"selectPage(totalPages, $event)\">{{getText('last')}}</a></li>\n" +
    "</ul>");
}]);

angular.module("template/tooltip/tooltip-html-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-html-popup.html",
    "<div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind-html=\"contentExp()\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html",
    "<div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" bind-html-unsafe=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-popup.html",
    "<div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\" ng-bind=\"content\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/tooltip/tooltip-template-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tooltip/tooltip-template-popup.html",
    "<div class=\"tooltip\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"tooltip-arrow\"></div>\n" +
    "  <div class=\"tooltip-inner\"\n" +
    "    tooltip-template-transclude=\"contentExp()\"\n" +
    "    tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/popover/popover-template.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/popover/popover-template.html",
    "<div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
    "      <div class=\"popover-content\"\n" +
    "        tooltip-template-transclude=\"contentExp()\"\n" +
    "        tooltip-template-transclude-scope=\"originScope()\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/popover/popover-window.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/popover/popover-window.html",
    "<div class=\"popover {{placement}}\" ng-class=\"{ in: isOpen, fade: animation }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-show=\"title\"></h3>\n" +
    "      <div class=\"popover-content\" tooltip-template-transclude></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/popover/popover.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/popover/popover.html",
    "<div class=\"popover\"\n" +
    "  tooltip-animation-class=\"fade\"\n" +
    "  tooltip-classes\n" +
    "  ng-class=\"{ in: isOpen() }\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "\n" +
    "  <div class=\"popover-inner\">\n" +
    "      <h3 class=\"popover-title\" ng-bind=\"title\" ng-if=\"title\"></h3>\n" +
    "      <div class=\"popover-content\" ng-bind=\"content\"></div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/progressbar/bar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/bar.html",
    "<div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" ng-transclude></div>\n" +
    "");
}]);

angular.module("template/progressbar/progress.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/progress.html",
    "<div class=\"progress\" ng-transclude></div>");
}]);

angular.module("template/progressbar/progressbar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/progressbar/progressbar.html",
    "<div class=\"progress\">\n" +
    "  <div class=\"progress-bar\" ng-class=\"type && 'progress-bar-' + type\" role=\"progressbar\" aria-valuenow=\"{{value}}\" aria-valuemin=\"0\" aria-valuemax=\"{{max}}\" ng-style=\"{width: (percent < 100 ? percent : 100) + '%'}\" aria-valuetext=\"{{percent | number:0}}%\" ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/rating/rating.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/rating/rating.html",
    "<span ng-mouseleave=\"reset()\" ng-keydown=\"onKeydown($event)\" tabindex=\"0\" role=\"slider\" aria-valuemin=\"0\" aria-valuemax=\"{{range.length}}\" aria-valuenow=\"{{value}}\">\n" +
    "    <i ng-repeat=\"r in range track by $index\" ng-mouseenter=\"enter($index + 1)\" ng-click=\"rate($index + 1)\" class=\"glyphicon\" ng-class=\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\">\n" +
    "        <span class=\"sr-only\">({{ $index < value ? '*' : ' ' }})</span>\n" +
    "    </i>\n" +
    "</span>");
}]);
//Adding 'align' to the class of hyperlink in tab.html
angular.module("template/tabs/tab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tab.html",
    "<li ng-class=\"{active: active, disabled: disabled} \">\n" +
    "  <a href class=\"{{align || ''}}\" ng-click=\"select()\" tab-heading-transclude>{{heading}}</a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("template/tabs/tabset.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/tabs/tabset.html",
    "<div>\n" +
    "  <ul class=\"nav nav-{{type || 'tabs'}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" +
    "  <div class=\"tab-content\">\n" +
    "    <div class=\"tab-pane\" \n" +
    "         ng-repeat=\"tab in tabs\" \n" +
    "         ng-class=\"{active: tab.active}\"\n" +
    "         tab-content-transclude=\"tab\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("template/timepicker/timepicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/timepicker/timepicker.html",
    "<table>\n" +
    "	<tbody>\n" +
    "   <tr class=\"text-center\">\n" +
    "     <td><a class=\"timepicker-arrow\" ng-click=\"incrementHours()\"><span class=\"hpe-icon hpe-up\"></span></a></td>\n" +
    "<td>&nbsp;</td>\n"+
    "     <td><a class=\"timepicker-arrow\" ng-click=\"incrementMinutes()\"><span class=\"hpe-icon hpe-up\"></span></a></td>\n" +
    "     <td ng-show=\"showMeridian\"></td>\n" +
    "   </tr>\n" +
    "   <tr>\n" +
    "     <td class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n" +
    "       <input style=\"width:50px;\" type=\"text\" ng-model=\"hours\" ng-change=\"updateHours()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\">\n" +
    "     </td>\n" +
    "<td>&nbsp;</td>\n"+
    "     <td class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
    "       <input style=\"width:50px;\" type=\"text\" ng-model=\"minutes\" ng-change=\"updateMinutes()\" class=\"form-control text-center\" ng-readonly=\"readonlyInput\" maxlength=\"2\">\n" +
    "     </td>\n" +
    "<td>&nbsp;</td>\n"+
    "         <td ng-show=\"showMeridian\"><button type=\"button\" class=\"btn btn-secondary text-center\" ng-click=\"toggleMeridian()\">{{meridian}}</button></td>\n" +
    "   </tr>\n" +
    "   <tr class=\"text-center\">\n" +
    "     <td><a class=\"timepicker-arrow\" ng-click=\"decrementHours()\"><span class=\"hpe-icon hpe-down\"></span></a></td>\n" +
        "<td>&nbsp;</td>\n"+
    "     <td><a class=\"timepicker-arrow\" ng-click=\"decrementMinutes()\"><span class=\"hpe-icon hpe-down\"></span></a></td>\n" +
    "     <td ng-show=\"showMeridian\"></td>\n" +
    "   </tr>\n" +
    "	</tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/typeahead/typeahead-match.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-match.html",
    "<a tabindex=\"-1\" bind-html-unsafe=\"match.label | typeaheadHighlight:query:regex:applyClass\"></a>");
}]);

angular.module("template/typeahead/typeahead-popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/typeahead/typeahead-popup.html",
    "<ul class=\"dropdown-menu\" ng-show=\"isOpen()\" ng-style=\"{top: position.top+'px', left: position.left+'px'}\" style=\"display: block;\" role=\"listbox\" aria-hidden=\"{{!isOpen()}}\">\n" +
    "    <li ng-repeat=\"match in matches track by $index\" ng-class=\"{active: isActive($index) }\" ng-mouseenter=\"selectActive($index)\" ng-mouseleave=\"deselectActive($index)\" ng-click=\"selectMatch($index)\" role=\"option\" id=\"{{match.id}}\">\n" +
    "        <div typeahead-match index=\"$index\" match=\"match\" regex=\"regex\" apply-class=\"applyClass\" query=\"query\" template-url=\"templateUrl\"></div>\n" +
    "    </li>\n" +
    "</ul>\n" +
    "");
}]);
!angular.$$csp() && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');
;
(function () {
    "use strict";

    angular.module('hpe.elements', [
            'ui.router',
            'ui.bootstrap',
            'NgSwitchery',
            'ngSanitize',
            'angular-timeline',
            'ngJScrollPane',
            'angular-peity',
            'angular-flot',
            'angularFileUpload',
            'localytics.directives',
            'scrollable-table',
            'ncy-angular-breadcrumb',
            'hpe.elements.templates',
            'hpe.elements.updatingLinechart',
            'hpe.elements.pagetitle',
            'hpe.elements.sideNavigation',
            'hpe.elements.minimizeMenu',
            'hpe.elements.cardTabs',
            'hpe.elements.dateTimePicker',
            'hpe.elements.forceFocus',
            'hpe.elements.floatLabel',
            'hpe.elements.icheck',
            'hpe.elements.wizard',
            'hpe.elements.groupedPrevious',
            'hpe.elements.groupedNext',
            'hpe.elements.groupedClear',
            'hpe.elements.groupedSelected',
            'hpe.elements.affixElement',
            'hpe.elements.expandSearch',
            'hpe.elements.expandingTextarea',
            'hpe.elements.facets',
            'hpe.elements.filters',
            'hpe.elements.helpCenter',
            'hpe.elements.sorters',
            'hpe.elements.scrollTop',
            'hpe.elements.condensedHeader',
            'hpe.elements.listHoverActions',
            'hpe.elements.lineDataService',
            'hpe.elements.menuTab',
            'hpe.elements.multipleSelect',
            'hpe.elements.multipleListSelect',
            'hpe.elements.multipleRowSelect',
            'hpe.elements.expandInput',
            'hpe.elements.dropZone',
            'hpe.elements.previewPanes',
            'hpe.elements.backButton',
            'hpe.elements.extendedCheckboxHit',
            'hpe.elements.elementReady',
            'hpe.elements.applicationSwitcher',
            'hpe.elements.sideModal',
            'hpe.elements.layoutSwitcher',
            'hpe.elements.nestedDonut',
            'ui.tree',
            'hpe.elements.treeview',
            'hpe.elements.focusOnShow',
            'hpe.elements.backButtonHeader',
            'hpe.elements.displayPanels',
            'hpe.elements.spark',
            'hpe.elements.d3',
            'hpe.elements.sigma',
            'hpe.elements.socialChart',
            'hpe.elements.sankey',
            'hpe.elements.partitionMap',
            'hpe.elements.overflowTooltip',
            'hpe.elements.floatingActionButton',
            'hpe.elements.sideInset',
            'hpe.elements.safeTimeout',
            'hpe.elements.inputMask',
            'hpe.elements.keyboardNavigableTable',
            'hpe.elements.safeInterval',
            'hpe.elements.safeEventListener',
            'hpe.elements.safeAnimationFrame',
            'hpe.elements.selectTable',
            'hpe.elements.tagInput',
            'hpe.elements.flotDataService',
            'hpe.elements.draggableCards',
            'hpe.elements.splitter',
            'hpe.elements.draggablePanels',
            'hpe.elements.staticTooltip',
            'hpe.elements.searchToolbar',
            'hpe.elements.searchBuilder',
            'hpe.elements.modalInsetPanel',
            'hpe.elements.listItemFilter',
            'hpe.elements.marqueeWizard',
            'hpe.elements.notificationService',
            'hpe.elements.infiniteScroll',
            'hpe.elements.timeAgoService',
            'hpe.elements.timeAgo',
            'hpe.elements.hoverActions',
            'hpe.elements.flippableCard',
            'hpe.elements.contacts',
            'hpe.elements.reorderableTable',
            'hpe.elements.hotkey',
            'hpe.elements.windowCommunicationService',
            'hpe.elements.index',
            'hpe.elements.numberPicker',
            'hpe.elements.resizeService',
            'hpe.elements.slider',
            'hpe.elements.checkbox',
            'hpe.elements.radiobutton',
            'hpe.elements.keyboardNavigationService'
        ])
        .config(["datepickerPopupConfig",
            "datepickerConfig",
            "paginationConfig",
            "$tooltipProvider",
            "$breadcrumbProvider",
            function (datepickerPopupConfig, datepickerConfig, paginationConfig, $tooltipProvider, $breadcrumbProvider) {
                datepickerPopupConfig.showButtonBar = true;
                datepickerPopupConfig.appendToBody = true;
                datepickerConfig.showWeeks = false;
                datepickerConfig.formatMonth = "MMM";
                datepickerConfig.yearRange = 10;

                paginationConfig.maxSize = 5;

                var tooltipOptions = {
                    popupDelay: 300,
                    appendToBody: true
                };

                $tooltipProvider.options(tooltipOptions);

                $breadcrumbProvider.setOptions({
                    templateUrl: 'template/angular-breadcrumb.html'
                });
            }
        ]).run(["$rootScope", function ($rootScope) {
            $rootScope.$on('$stateChangeStart',
                function () {
                    if (angular.element('.customTooltip').length > 0)
                        angular.element('.customTooltip').remove();
                    if (angular.element('.tooltip').length > 0)
                        angular.element('.tooltip').remove();
                });
        }]);
})();;
(function () {

	angular.module('hpe.elements.flotDataService', []).factory("flotDataService", flotDataService);

	function flotDataService() {

		return {

			getOilPrices: function () {

				var oilprices = [
					[1167692400000, 61.05],
					[1167778800000, 58.32],
					[1167865200000, 57.35],
					[1167951600000, 56.31],
					[1168210800000, 55.55],
					[1168297200000, 55.64],
					[1168383600000, 54.02],
					[1168470000000, 51.88],
					[1168556400000, 52.99],
					[1168815600000, 52.99],
					[1168902000000, 51.21],
					[1168988400000, 52.24],
					[1169074800000, 50.48],
					[1169161200000, 51.99],
					[1169420400000, 51.13],
					[1169506800000, 55.04],
					[1169593200000, 55.37],
					[1169679600000, 54.23],
					[1169766000000, 55.42],
					[1170025200000, 54.01],
					[1170111600000, 56.97],
					[1170198000000, 58.14],
					[1170284400000, 58.14],
					[1170370800000, 59.02],
					[1170630000000, 58.74],
					[1170716400000, 58.88],
					[1170802800000, 57.71],
					[1170889200000, 59.71],
					[1170975600000, 59.89],
					[1171234800000, 57.81],
					[1171321200000, 59.06],
					[1171407600000, 58.00],
					[1171494000000, 57.99],
					[1171580400000, 59.39],
					[1171839600000, 59.39],
					[1171926000000, 58.07],
					[1172012400000, 60.07],
					[1172098800000, 61.14],
					[1172444400000, 61.39],
					[1172530800000, 61.46],
					[1172617200000, 61.79],
					[1172703600000, 62.00],
					[1172790000000, 60.07],
					[1173135600000, 60.69],
					[1173222000000, 61.82],
					[1173308400000, 60.05],
					[1173654000000, 58.91],
					[1173740400000, 57.93],
					[1173826800000, 58.16],
					[1173913200000, 57.55],
					[1173999600000, 57.11],
					[1174258800000, 56.59],
					[1174345200000, 59.61],
					[1174518000000, 61.69],
					[1174604400000, 62.28],
					[1174860000000, 62.91],
					[1174946400000, 62.93],
					[1175032800000, 64.03],
					[1175119200000, 66.03],
					[1175205600000, 65.87],
					[1175464800000, 64.64],
					[1175637600000, 64.38],
					[1175724000000, 64.28],
					[1175810400000, 64.28],
					[1176069600000, 61.51],
					[1176156000000, 61.89],
					[1176242400000, 62.01],
					[1176328800000, 63.85],
					[1176415200000, 63.63],
					[1176674400000, 63.61],
					[1176760800000, 63.10],
					[1176847200000, 63.13],
					[1176933600000, 61.83],
					[1177020000000, 63.38],
					[1177279200000, 64.58],
					[1177452000000, 65.84],
					[1177538400000, 65.06],
					[1177624800000, 66.46],
					[1177884000000, 64.40],
					[1178056800000, 63.68],
					[1178143200000, 63.19],
					[1178229600000, 61.93],
					[1178488800000, 61.47],
					[1178575200000, 61.55],
					[1178748000000, 61.81],
					[1178834400000, 62.37],
					[1179093600000, 62.46],
					[1179180000000, 63.17],
					[1179266400000, 62.55],
					[1179352800000, 64.94],
					[1179698400000, 66.27],
					[1179784800000, 65.50],
					[1179871200000, 65.77],
					[1179957600000, 64.18],
					[1180044000000, 65.20],
					[1180389600000, 63.15],
					[1180476000000, 63.49],
					[1180562400000, 65.08],
					[1180908000000, 66.30],
					[1180994400000, 65.96],
					[1181167200000, 66.93],
					[1181253600000, 65.98],
					[1181599200000, 65.35],
					[1181685600000, 66.26],
					[1181858400000, 68.00],
					[1182117600000, 69.09],
					[1182204000000, 69.10],
					[1182290400000, 68.19],
					[1182376800000, 68.19],
					[1182463200000, 69.14],
					[1182722400000, 68.19],
					[1182808800000, 67.77],
					[1182895200000, 68.97],
					[1182981600000, 69.57],
					[1183068000000, 70.68],
					[1183327200000, 71.09],
					[1183413600000, 70.92],
					[1183586400000, 71.81],
					[1183672800000, 72.81],
					[1183932000000, 72.19],
					[1184018400000, 72.56],
					[1184191200000, 72.50],
					[1184277600000, 74.15],
					[1184623200000, 75.05],
					[1184796000000, 75.92],
					[1184882400000, 75.57],
					[1185141600000, 74.89],
					[1185228000000, 73.56],
					[1185314400000, 75.57],
					[1185400800000, 74.95],
					[1185487200000, 76.83],
					[1185832800000, 78.21],
					[1185919200000, 76.53],
					[1186005600000, 76.86],
					[1186092000000, 76.00],
					[1186437600000, 71.59],
					[1186696800000, 71.47],
					[1186956000000, 71.62],
					[1187042400000, 71.00],
					[1187301600000, 71.98],
					[1187560800000, 71.12],
					[1187647200000, 69.47],
					[1187733600000, 69.26],
					[1187820000000, 69.83],
					[1187906400000, 71.09],
					[1188165600000, 71.73],
					[1188338400000, 73.36],
					[1188511200000, 74.04],
					[1188856800000, 76.30],
					[1189116000000, 77.49],
					[1189461600000, 78.23],
					[1189548000000, 79.91],
					[1189634400000, 80.09],
					[1189720800000, 79.10],
					[1189980000000, 80.57],
					[1190066400000, 81.93],
					[1190239200000, 83.32],
					[1190325600000, 81.62],
					[1190584800000, 80.95],
					[1190671200000, 79.53],
					[1190757600000, 80.30],
					[1190844000000, 82.88],
					[1190930400000, 81.66],
					[1191189600000, 80.24],
					[1191276000000, 80.05],
					[1191362400000, 79.94],
					[1191448800000, 81.44],
					[1191535200000, 81.22],
					[1191794400000, 79.02],
					[1191880800000, 80.26],
					[1191967200000, 80.30],
					[1192053600000, 83.08],
					[1192140000000, 83.69],
					[1192399200000, 86.13],
					[1192485600000, 87.61],
					[1192572000000, 87.40],
					[1192658400000, 89.47],
					[1192744800000, 88.60],
					[1193004000000, 87.56],
					[1193090400000, 87.56],
					[1193176800000, 87.10],
					[1193263200000, 91.86],
					[1193612400000, 93.53],
					[1193698800000, 94.53],
					[1193871600000, 95.93],
					[1194217200000, 93.98],
					[1194303600000, 96.37],
					[1194476400000, 95.46],
					[1194562800000, 96.32],
					[1195081200000, 93.43],
					[1195167600000, 95.10],
					[1195426800000, 94.64],
					[1195513200000, 95.10],
					[1196031600000, 97.70],
					[1196118000000, 94.42],
					[1196204400000, 90.62],
					[1196290800000, 91.01],
					[1196377200000, 88.71],
					[1196636400000, 88.32],
					[1196809200000, 90.23],
					[1196982000000, 88.28],
					[1197241200000, 87.86],
					[1197327600000, 90.02],
					[1197414000000, 92.25],
					[1197586800000, 90.63],
					[1197846000000, 90.63],
					[1197932400000, 90.49],
					[1198018800000, 91.24],
					[1198105200000, 91.06],
					[1198191600000, 90.49],
					[1198710000000, 96.62],
					[1198796400000, 96.00],
					[1199142000000, 99.62],
					[1199314800000, 99.18],
					[1199401200000, 95.09],
					[1199660400000, 96.33],
					[1199833200000, 95.67],
					[1200351600000, 91.90],
					[1200438000000, 90.84],
					[1200524400000, 90.13],
					[1200610800000, 90.57],
					[1200956400000, 89.21],
					[1201042800000, 86.99],
					[1201129200000, 89.85],
					[1201474800000, 90.99],
					[1201561200000, 91.64],
					[1201647600000, 92.33],
					[1201734000000, 91.75],
					[1202079600000, 90.02],
					[1202166000000, 88.41],
					[1202252400000, 87.14],
					[1202338800000, 88.11],
					[1202425200000, 91.77],
					[1202770800000, 92.78],
					[1202857200000, 93.27],
					[1202943600000, 95.46],
					[1203030000000, 95.46],
					[1203289200000, 101.74],
					[1203462000000, 98.81],
					[1203894000000, 100.88],
					[1204066800000, 99.64],
					[1204153200000, 102.59],
					[1204239600000, 101.84],
					[1204498800000, 99.52],
					[1204585200000, 99.52],
					[1204671600000, 104.52],
					[1204758000000, 105.47],
					[1204844400000, 105.15],
					[1205103600000, 108.75],
					[1205276400000, 109.92],
					[1205362800000, 110.33],
					[1205449200000, 110.21],
					[1205708400000, 105.68],
					[1205967600000, 101.84],
					[1206313200000, 100.86],
					[1206399600000, 101.22],
					[1206486000000, 105.90],
					[1206572400000, 107.58],
					[1206658800000, 105.62],
					[1206914400000, 101.58],
					[1207000800000, 100.98],
					[1207173600000, 103.83],
					[1207260000000, 106.23],
					[1207605600000, 108.50],
					[1207778400000, 110.11],
					[1207864800000, 110.14],
					[1208210400000, 113.79],
					[1208296800000, 114.93],
					[1208383200000, 114.86],
					[1208728800000, 117.48],
					[1208815200000, 118.30],
					[1208988000000, 116.06],
					[1209074400000, 118.52],
					[1209333600000, 118.75],
					[1209420000000, 113.46],
					[1209592800000, 112.52],
					[1210024800000, 121.84],
					[1210111200000, 123.53],
					[1210197600000, 123.69],
					[1210543200000, 124.23],
					[1210629600000, 125.80],
					[1210716000000, 126.29],
					[1211148000000, 127.05],
					[1211320800000, 129.07],
					[1211493600000, 132.19],
					[1211839200000, 128.85],
					[1212357600000, 127.76],
					[1212703200000, 138.54],
					[1212962400000, 136.80],
					[1213135200000, 136.38],
					[1213308000000, 134.86],
					[1213653600000, 134.01],
					[1213740000000, 136.68],
					[1213912800000, 135.65],
					[1214172000000, 134.62],
					[1214258400000, 134.62],
					[1214344800000, 134.62],
					[1214431200000, 139.64],
					[1214517600000, 140.21],
					[1214776800000, 140.00],
					[1214863200000, 140.97],
					[1214949600000, 143.57],
					[1215036000000, 145.29],
					[1215381600000, 141.37],
					[1215468000000, 136.04],
					[1215727200000, 146.40],
					[1215986400000, 145.18],
					[1216072800000, 138.74],
					[1216159200000, 134.60],
					[1216245600000, 129.29],
					[1216332000000, 130.65],
					[1216677600000, 127.95],
					[1216850400000, 127.95],
					[1217282400000, 122.19],
					[1217455200000, 124.08],
					[1217541600000, 125.10],
					[1217800800000, 121.41],
					[1217887200000, 119.17],
					[1217973600000, 118.58],
					[1218060000000, 120.02],
					[1218405600000, 114.45],
					[1218492000000, 113.01],
					[1218578400000, 116.00],
					[1218751200000, 113.77],
					[1219010400000, 112.87],
					[1219096800000, 114.53],
					[1219269600000, 114.98],
					[1219356000000, 114.98],
					[1219701600000, 116.27],
					[1219788000000, 118.15],
					[1219874400000, 115.59],
					[1219960800000, 115.46],
					[1220306400000, 109.71],
					[1220392800000, 109.35],
					[1220565600000, 106.23],
					[1220824800000, 106.34]
				];

				return oilprices;
			},

			getExchangeRates: function () {

				var exchangerates = [
					[1167606000000, 0.7580],
					[1167692400000, 0.7580],
					[1167778800000, 0.75470],
					[1167865200000, 0.75490],
					[1167951600000, 0.76130],
					[1168038000000, 0.76550],
					[1168124400000, 0.76930],
					[1168210800000, 0.76940],
					[1168297200000, 0.76880],
					[1168383600000, 0.76780],
					[1168470000000, 0.77080],
					[1168556400000, 0.77270],
					[1168642800000, 0.77490],
					[1168729200000, 0.77410],
					[1168815600000, 0.77410],
					[1168902000000, 0.77320],
					[1168988400000, 0.77270],
					[1169074800000, 0.77370],
					[1169161200000, 0.77240],
					[1169247600000, 0.77120],
					[1169334000000, 0.7720],
					[1169420400000, 0.77210],
					[1169506800000, 0.77170],
					[1169593200000, 0.77040],
					[1169679600000, 0.7690],
					[1169766000000, 0.77110],
					[1169852400000, 0.7740],
					[1169938800000, 0.77450],
					[1170025200000, 0.77450],
					[1170111600000, 0.7740],
					[1170198000000, 0.77160],
					[1170284400000, 0.77130],
					[1170370800000, 0.76780],
					[1170457200000, 0.76880],
					[1170543600000, 0.77180],
					[1170630000000, 0.77180],
					[1170716400000, 0.77280],
					[1170802800000, 0.77290],
					[1170889200000, 0.76980],
					[1170975600000, 0.76850],
					[1171062000000, 0.76810],
					[1171148400000, 0.7690],
					[1171234800000, 0.7690],
					[1171321200000, 0.76980],
					[1171407600000, 0.76990],
					[1171494000000, 0.76510],
					[1171580400000, 0.76130],
					[1171666800000, 0.76160],
					[1171753200000, 0.76140],
					[1171839600000, 0.76140],
					[1171926000000, 0.76070],
					[1172012400000, 0.76020],
					[1172098800000, 0.76110],
					[1172185200000, 0.76220],
					[1172271600000, 0.76150],
					[1172358000000, 0.75980],
					[1172444400000, 0.75980],
					[1172530800000, 0.75920],
					[1172617200000, 0.75730],
					[1172703600000, 0.75660],
					[1172790000000, 0.75670],
					[1172876400000, 0.75910],
					[1172962800000, 0.75820],
					[1173049200000, 0.75850],
					[1173135600000, 0.76130],
					[1173222000000, 0.76310],
					[1173308400000, 0.76150],
					[1173394800000, 0.760],
					[1173481200000, 0.76130],
					[1173567600000, 0.76270],
					[1173654000000, 0.76270],
					[1173740400000, 0.76080],
					[1173826800000, 0.75830],
					[1173913200000, 0.75750],
					[1173999600000, 0.75620],
					[1174086000000, 0.7520],
					[1174172400000, 0.75120],
					[1174258800000, 0.75120],
					[1174345200000, 0.75170],
					[1174431600000, 0.7520],
					[1174518000000, 0.75110],
					[1174604400000, 0.7480],
					[1174690800000, 0.75090],
					[1174777200000, 0.75310],
					[1174860000000, 0.75310],
					[1174946400000, 0.75270],
					[1175032800000, 0.74980],
					[1175119200000, 0.74930],
					[1175205600000, 0.75040],
					[1175292000000, 0.750],
					[1175378400000, 0.74910],
					[1175464800000, 0.74910],
					[1175551200000, 0.74850],
					[1175637600000, 0.74840],
					[1175724000000, 0.74920],
					[1175810400000, 0.74710],
					[1175896800000, 0.74590],
					[1175983200000, 0.74770],
					[1176069600000, 0.74770],
					[1176156000000, 0.74830],
					[1176242400000, 0.74580],
					[1176328800000, 0.74480],
					[1176415200000, 0.7430],
					[1176501600000, 0.73990],
					[1176588000000, 0.73950],
					[1176674400000, 0.73950],
					[1176760800000, 0.73780],
					[1176847200000, 0.73820],
					[1176933600000, 0.73620],
					[1177020000000, 0.73550],
					[1177106400000, 0.73480],
					[1177192800000, 0.73610],
					[1177279200000, 0.73610],
					[1177365600000, 0.73650],
					[1177452000000, 0.73620],
					[1177538400000, 0.73310],
					[1177624800000, 0.73390],
					[1177711200000, 0.73440],
					[1177797600000, 0.73270],
					[1177884000000, 0.73270],
					[1177970400000, 0.73360],
					[1178056800000, 0.73330],
					[1178143200000, 0.73590],
					[1178229600000, 0.73590],
					[1178316000000, 0.73720],
					[1178402400000, 0.7360],
					[1178488800000, 0.7360],
					[1178575200000, 0.7350],
					[1178661600000, 0.73650],
					[1178748000000, 0.73840],
					[1178834400000, 0.73950],
					[1178920800000, 0.74130],
					[1179007200000, 0.73970],
					[1179093600000, 0.73960],
					[1179180000000, 0.73850],
					[1179266400000, 0.73780],
					[1179352800000, 0.73660],
					[1179439200000, 0.740],
					[1179525600000, 0.74110],
					[1179612000000, 0.74060],
					[1179698400000, 0.74050],
					[1179784800000, 0.74140],
					[1179871200000, 0.74310],
					[1179957600000, 0.74310],
					[1180044000000, 0.74380],
					[1180130400000, 0.74430],
					[1180216800000, 0.74430],
					[1180303200000, 0.74430],
					[1180389600000, 0.74340],
					[1180476000000, 0.74290],
					[1180562400000, 0.74420],
					[1180648800000, 0.7440],
					[1180735200000, 0.74390],
					[1180821600000, 0.74370],
					[1180908000000, 0.74370],
					[1180994400000, 0.74290],
					[1181080800000, 0.74030],
					[1181167200000, 0.73990],
					[1181253600000, 0.74180],
					[1181340000000, 0.74680],
					[1181426400000, 0.7480],
					[1181512800000, 0.7480],
					[1181599200000, 0.7490],
					[1181685600000, 0.74940],
					[1181772000000, 0.75220],
					[1181858400000, 0.75150],
					[1181944800000, 0.75020],
					[1182031200000, 0.74720],
					[1182117600000, 0.74720],
					[1182204000000, 0.74620],
					[1182290400000, 0.74550],
					[1182376800000, 0.74490],
					[1182463200000, 0.74670],
					[1182549600000, 0.74580],
					[1182636000000, 0.74270],
					[1182722400000, 0.74270],
					[1182808800000, 0.7430],
					[1182895200000, 0.74290],
					[1182981600000, 0.7440],
					[1183068000000, 0.7430],
					[1183154400000, 0.74220],
					[1183240800000, 0.73880],
					[1183327200000, 0.73880],
					[1183413600000, 0.73690],
					[1183500000000, 0.73450],
					[1183586400000, 0.73450],
					[1183672800000, 0.73450],
					[1183759200000, 0.73520],
					[1183845600000, 0.73410],
					[1183932000000, 0.73410],
					[1184018400000, 0.7340],
					[1184104800000, 0.73240],
					[1184191200000, 0.72720],
					[1184277600000, 0.72640],
					[1184364000000, 0.72550],
					[1184450400000, 0.72580],
					[1184536800000, 0.72580],
					[1184623200000, 0.72560],
					[1184709600000, 0.72570],
					[1184796000000, 0.72470],
					[1184882400000, 0.72430],
					[1184968800000, 0.72440],
					[1185055200000, 0.72350],
					[1185141600000, 0.72350],
					[1185228000000, 0.72350],
					[1185314400000, 0.72350],
					[1185400800000, 0.72620],
					[1185487200000, 0.72880],
					[1185573600000, 0.73010],
					[1185660000000, 0.73370],
					[1185746400000, 0.73370],
					[1185832800000, 0.73240],
					[1185919200000, 0.72970],
					[1186005600000, 0.73170],
					[1186092000000, 0.73150],
					[1186178400000, 0.72880],
					[1186264800000, 0.72630],
					[1186351200000, 0.72630],
					[1186437600000, 0.72420],
					[1186524000000, 0.72530],
					[1186610400000, 0.72640],
					[1186696800000, 0.7270],
					[1186783200000, 0.73120],
					[1186869600000, 0.73050],
					[1186956000000, 0.73050],
					[1187042400000, 0.73180],
					[1187128800000, 0.73580],
					[1187215200000, 0.74090],
					[1187301600000, 0.74540],
					[1187388000000, 0.74370],
					[1187474400000, 0.74240],
					[1187560800000, 0.74240],
					[1187647200000, 0.74150],
					[1187733600000, 0.74190],
					[1187820000000, 0.74140],
					[1187906400000, 0.73770],
					[1187992800000, 0.73550],
					[1188079200000, 0.73150],
					[1188165600000, 0.73150],
					[1188252000000, 0.7320],
					[1188338400000, 0.73320],
					[1188424800000, 0.73460],
					[1188511200000, 0.73280],
					[1188597600000, 0.73230],
					[1188684000000, 0.7340],
					[1188770400000, 0.7340],
					[1188856800000, 0.73360],
					[1188943200000, 0.73510],
					[1189029600000, 0.73460],
					[1189116000000, 0.73210],
					[1189202400000, 0.72940],
					[1189288800000, 0.72660],
					[1189375200000, 0.72660],
					[1189461600000, 0.72540],
					[1189548000000, 0.72420],
					[1189634400000, 0.72130],
					[1189720800000, 0.71970],
					[1189807200000, 0.72090],
					[1189893600000, 0.7210],
					[1189980000000, 0.7210],
					[1190066400000, 0.7210],
					[1190152800000, 0.72090],
					[1190239200000, 0.71590],
					[1190325600000, 0.71330],
					[1190412000000, 0.71050],
					[1190498400000, 0.70990],
					[1190584800000, 0.70990],
					[1190671200000, 0.70930],
					[1190757600000, 0.70930],
					[1190844000000, 0.70760],
					[1190930400000, 0.7070],
					[1191016800000, 0.70490],
					[1191103200000, 0.70120],
					[1191189600000, 0.70110],
					[1191276000000, 0.70190],
					[1191362400000, 0.70460],
					[1191448800000, 0.70630],
					[1191535200000, 0.70890],
					[1191621600000, 0.70770],
					[1191708000000, 0.70770],
					[1191794400000, 0.70770],
					[1191880800000, 0.70910],
					[1191967200000, 0.71180],
					[1192053600000, 0.70790],
					[1192140000000, 0.70530],
					[1192226400000, 0.7050],
					[1192312800000, 0.70550],
					[1192399200000, 0.70550],
					[1192485600000, 0.70450],
					[1192572000000, 0.70510],
					[1192658400000, 0.70510],
					[1192744800000, 0.70170],
					[1192831200000, 0.70],
					[1192917600000, 0.69950],
					[1193004000000, 0.69940],
					[1193090400000, 0.70140],
					[1193176800000, 0.70360],
					[1193263200000, 0.70210],
					[1193349600000, 0.70020],
					[1193436000000, 0.69670],
					[1193522400000, 0.6950],
					[1193612400000, 0.6950],
					[1193698800000, 0.69390],
					[1193785200000, 0.6940],
					[1193871600000, 0.69220],
					[1193958000000, 0.69190],
					[1194044400000, 0.69140],
					[1194130800000, 0.68940],
					[1194217200000, 0.68910],
					[1194303600000, 0.69040],
					[1194390000000, 0.6890],
					[1194476400000, 0.68340],
					[1194562800000, 0.68230],
					[1194649200000, 0.68070],
					[1194735600000, 0.68150],
					[1194822000000, 0.68150],
					[1194908400000, 0.68470],
					[1194994800000, 0.68590],
					[1195081200000, 0.68220],
					[1195167600000, 0.68270],
					[1195254000000, 0.68370],
					[1195340400000, 0.68230],
					[1195426800000, 0.68220],
					[1195513200000, 0.68220],
					[1195599600000, 0.67920],
					[1195686000000, 0.67460],
					[1195772400000, 0.67350],
					[1195858800000, 0.67310],
					[1195945200000, 0.67420],
					[1196031600000, 0.67440],
					[1196118000000, 0.67390],
					[1196204400000, 0.67310],
					[1196290800000, 0.67610],
					[1196377200000, 0.67610],
					[1196463600000, 0.67850],
					[1196550000000, 0.68180],
					[1196636400000, 0.68360],
					[1196722800000, 0.68230],
					[1196809200000, 0.68050],
					[1196895600000, 0.67930],
					[1196982000000, 0.68490],
					[1197068400000, 0.68330],
					[1197154800000, 0.68250],
					[1197241200000, 0.68250],
					[1197327600000, 0.68160],
					[1197414000000, 0.67990],
					[1197500400000, 0.68130],
					[1197586800000, 0.68090],
					[1197673200000, 0.68680],
					[1197759600000, 0.69330],
					[1197846000000, 0.69330],
					[1197932400000, 0.69450],
					[1198018800000, 0.69440],
					[1198105200000, 0.69460],
					[1198191600000, 0.69640],
					[1198278000000, 0.69650],
					[1198364400000, 0.69560],
					[1198450800000, 0.69560],
					[1198537200000, 0.6950],
					[1198623600000, 0.69480],
					[1198710000000, 0.69280],
					[1198796400000, 0.68870],
					[1198882800000, 0.68240],
					[1198969200000, 0.67940],
					[1199055600000, 0.67940],
					[1199142000000, 0.68030],
					[1199228400000, 0.68550],
					[1199314800000, 0.68240],
					[1199401200000, 0.67910],
					[1199487600000, 0.67830],
					[1199574000000, 0.67850],
					[1199660400000, 0.67850],
					[1199746800000, 0.67970],
					[1199833200000, 0.680],
					[1199919600000, 0.68030],
					[1200006000000, 0.68050],
					[1200092400000, 0.6760],
					[1200178800000, 0.6770],
					[1200265200000, 0.6770],
					[1200351600000, 0.67360],
					[1200438000000, 0.67260],
					[1200524400000, 0.67640],
					[1200610800000, 0.68210],
					[1200697200000, 0.68310],
					[1200783600000, 0.68420],
					[1200870000000, 0.68420],
					[1200956400000, 0.68870],
					[1201042800000, 0.69030],
					[1201129200000, 0.68480],
					[1201215600000, 0.68240],
					[1201302000000, 0.67880],
					[1201388400000, 0.68140],
					[1201474800000, 0.68140],
					[1201561200000, 0.67970],
					[1201647600000, 0.67690],
					[1201734000000, 0.67650],
					[1201820400000, 0.67330],
					[1201906800000, 0.67290],
					[1201993200000, 0.67580],
					[1202079600000, 0.67580],
					[1202166000000, 0.6750],
					[1202252400000, 0.6780],
					[1202338800000, 0.68330],
					[1202425200000, 0.68560],
					[1202511600000, 0.69030],
					[1202598000000, 0.68960],
					[1202684400000, 0.68960],
					[1202770800000, 0.68820],
					[1202857200000, 0.68790],
					[1202943600000, 0.68620],
					[1203030000000, 0.68520],
					[1203116400000, 0.68230],
					[1203202800000, 0.68130],
					[1203289200000, 0.68130],
					[1203375600000, 0.68220],
					[1203462000000, 0.68020],
					[1203548400000, 0.68020],
					[1203634800000, 0.67840],
					[1203721200000, 0.67480],
					[1203807600000, 0.67470],
					[1203894000000, 0.67470],
					[1203980400000, 0.67480],
					[1204066800000, 0.67330],
					[1204153200000, 0.6650],
					[1204239600000, 0.66110],
					[1204326000000, 0.65830],
					[1204412400000, 0.6590],
					[1204498800000, 0.6590],
					[1204585200000, 0.65810],
					[1204671600000, 0.65780],
					[1204758000000, 0.65740],
					[1204844400000, 0.65320],
					[1204930800000, 0.65020],
					[1205017200000, 0.65140],
					[1205103600000, 0.65140],
					[1205190000000, 0.65070],
					[1205276400000, 0.6510],
					[1205362800000, 0.64890],
					[1205449200000, 0.64240],
					[1205535600000, 0.64060],
					[1205622000000, 0.63820],
					[1205708400000, 0.63820],
					[1205794800000, 0.63410],
					[1205881200000, 0.63440],
					[1205967600000, 0.63780],
					[1206054000000, 0.64390],
					[1206140400000, 0.64780],
					[1206226800000, 0.64810],
					[1206313200000, 0.64810],
					[1206399600000, 0.64940],
					[1206486000000, 0.64380],
					[1206572400000, 0.63770],
					[1206658800000, 0.63290],
					[1206745200000, 0.63360],
					[1206831600000, 0.63330],
					[1206914400000, 0.63330],
					[1207000800000, 0.6330],
					[1207087200000, 0.63710],
					[1207173600000, 0.64030],
					[1207260000000, 0.63960],
					[1207346400000, 0.63640],
					[1207432800000, 0.63560],
					[1207519200000, 0.63560],
					[1207605600000, 0.63680],
					[1207692000000, 0.63570],
					[1207778400000, 0.63540],
					[1207864800000, 0.6320],
					[1207951200000, 0.63320],
					[1208037600000, 0.63280],
					[1208124000000, 0.63310],
					[1208210400000, 0.63420],
					[1208296800000, 0.63210],
					[1208383200000, 0.63020],
					[1208469600000, 0.62780],
					[1208556000000, 0.63080],
					[1208642400000, 0.63240],
					[1208728800000, 0.63240],
					[1208815200000, 0.63070],
					[1208901600000, 0.62770],
					[1208988000000, 0.62690],
					[1209074400000, 0.63350],
					[1209160800000, 0.63920],
					[1209247200000, 0.640],
					[1209333600000, 0.64010],
					[1209420000000, 0.63960],
					[1209506400000, 0.64070],
					[1209592800000, 0.64230],
					[1209679200000, 0.64290],
					[1209765600000, 0.64720],
					[1209852000000, 0.64850],
					[1209938400000, 0.64860],
					[1210024800000, 0.64670],
					[1210111200000, 0.64440],
					[1210197600000, 0.64670],
					[1210284000000, 0.65090],
					[1210370400000, 0.64780],
					[1210456800000, 0.64610],
					[1210543200000, 0.64610],
					[1210629600000, 0.64680],
					[1210716000000, 0.64490],
					[1210802400000, 0.6470],
					[1210888800000, 0.64610],
					[1210975200000, 0.64520],
					[1211061600000, 0.64220],
					[1211148000000, 0.64220],
					[1211234400000, 0.64250],
					[1211320800000, 0.64140],
					[1211407200000, 0.63660],
					[1211493600000, 0.63460],
					[1211580000000, 0.6350],
					[1211666400000, 0.63460],
					[1211752800000, 0.63460],
					[1211839200000, 0.63430],
					[1211925600000, 0.63460],
					[1212012000000, 0.63790],
					[1212098400000, 0.64160],
					[1212184800000, 0.64420],
					[1212271200000, 0.64310],
					[1212357600000, 0.64310],
					[1212444000000, 0.64350],
					[1212530400000, 0.6440],
					[1212616800000, 0.64730],
					[1212703200000, 0.64690],
					[1212789600000, 0.63860],
					[1212876000000, 0.63560],
					[1212962400000, 0.6340],
					[1213048800000, 0.63460],
					[1213135200000, 0.6430],
					[1213221600000, 0.64520],
					[1213308000000, 0.64670],
					[1213394400000, 0.65060],
					[1213480800000, 0.65040],
					[1213567200000, 0.65030],
					[1213653600000, 0.64810],
					[1213740000000, 0.64510],
					[1213826400000, 0.6450],
					[1213912800000, 0.64410],
					[1213999200000, 0.64140],
					[1214085600000, 0.64090],
					[1214172000000, 0.64090],
					[1214258400000, 0.64280],
					[1214344800000, 0.64310],
					[1214431200000, 0.64180],
					[1214517600000, 0.63710],
					[1214604000000, 0.63490],
					[1214690400000, 0.63330],
					[1214776800000, 0.63340],
					[1214863200000, 0.63380],
					[1214949600000, 0.63420],
					[1215036000000, 0.6320],
					[1215122400000, 0.63180],
					[1215208800000, 0.6370],
					[1215295200000, 0.63680],
					[1215381600000, 0.63680],
					[1215468000000, 0.63830],
					[1215554400000, 0.63710],
					[1215640800000, 0.63710],
					[1215727200000, 0.63550],
					[1215813600000, 0.6320],
					[1215900000000, 0.62770],
					[1215986400000, 0.62760],
					[1216072800000, 0.62910],
					[1216159200000, 0.62740],
					[1216245600000, 0.62930],
					[1216332000000, 0.63110],
					[1216418400000, 0.6310],
					[1216504800000, 0.63120],
					[1216591200000, 0.63120],
					[1216677600000, 0.63040],
					[1216764000000, 0.62940],
					[1216850400000, 0.63480],
					[1216936800000, 0.63780],
					[1217023200000, 0.63680],
					[1217109600000, 0.63680],
					[1217196000000, 0.63680],
					[1217282400000, 0.6360],
					[1217368800000, 0.6370],
					[1217455200000, 0.64180],
					[1217541600000, 0.64110],
					[1217628000000, 0.64350],
					[1217714400000, 0.64270],
					[1217800800000, 0.64270],
					[1217887200000, 0.64190],
					[1217973600000, 0.64460],
					[1218060000000, 0.64680],
					[1218146400000, 0.64870],
					[1218232800000, 0.65940],
					[1218319200000, 0.66660],
					[1218405600000, 0.66660],
					[1218492000000, 0.66780],
					[1218578400000, 0.67120],
					[1218664800000, 0.67050],
					[1218751200000, 0.67180],
					[1218837600000, 0.67840],
					[1218924000000, 0.68110],
					[1219010400000, 0.68110],
					[1219096800000, 0.67940],
					[1219183200000, 0.68040],
					[1219269600000, 0.67810],
					[1219356000000, 0.67560],
					[1219442400000, 0.67350],
					[1219528800000, 0.67630],
					[1219615200000, 0.67620],
					[1219701600000, 0.67770],
					[1219788000000, 0.68150],
					[1219874400000, 0.68020],
					[1219960800000, 0.6780],
					[1220047200000, 0.67960],
					[1220133600000, 0.68170],
					[1220220000000, 0.68170],
					[1220306400000, 0.68320],
					[1220392800000, 0.68770],
					[1220479200000, 0.69120],
					[1220565600000, 0.69140],
					[1220652000000, 0.70090],
					[1220738400000, 0.70120],
					[1220824800000, 0.7010],
					[1220911200000, 0.70050]
				];

				return exchangerates;

			},

		};

	}


})();;
(function () {

  angular.module('hpe.elements.hotkey').service("hotkeyService", hotkeyService);

  hotkeyService.$inject = ["$document"];

  function hotkeyService($document) {

    var keyMap, nonViableNodeList, nonViableAttributeList, hotkeys;

    init();

    return {
      getCharCode: getCharCode,
      viableHotKeyTarget: viableHotKeyTarget,
      bindKey: bindKey,
      unbindKey: unbindKey,
      createHotkeyHint: createHotkeyHint
    };

    function createHotkeyHint(element, hotkeyText) {
      var hotkeyHint = angular.element("<div class='elements-hotkey-group-hint'>" + hotkeyText + "</div>");
      var wrapper = angular.element("<div></div");

      var hintStyle = {
        position: 'absolute',
        top: '0',
        left: '0'
      };

      var wrapperStyle = {
        position: 'relative',
        width: 0,
        height: 0
      };

      angular.extend(hotkeyHint[0].style, hintStyle);

      angular.extend(wrapper[0].style, wrapperStyle);

      wrapper.prepend(hotkeyHint);

      element.prepend(wrapper);
    }

    function bindKey(keyCode, callback, boundElement, keyTarget) {
      //Use the document by default
      if (!keyTarget) {
        keyTarget = $document;
      }

      //Wrap the callback in some keybind logic
      var keyFn = function (event) {
        if (viableHotKeyTarget(event.target)) {
          if (event.which === keyCode) {
            event.preventDefault();
            callback();
          }
        }
      };

      //In the event of a collision, new setting takes precedence
      if (angular.isDefined(hotkeys[keyCode])) {
        unbindKey(keyCode, keyTarget);
      }
      //Store the function for easy deletion later
      hotkeys[keyCode] = keyFn;

      //Bind the key to the function
      keyTarget.on('keydown', keyFn);

      //If this was invokved from a directive, unbind it when that element is cleaned up
      if (boundElement) {
        boundElement.scope().$on('$destroy', function () {
          unbindKey(keyCode, keyTarget);
        });
      }
    }

    function unbindKey(keyCode, keyTarget) {
      //Use the $document by default
      if (!keyTarget) {
        keyTarget = $document;
      }
      if (hotkeys[keyCode]) {
        keyTarget.off('keydown', hotkeys[keyCode]);
      }
    }

    function getCharCode(inputStr) {
      if (keyMap[inputStr]) {
        return keyMap[inputStr];
      }
      if (inputStr.length && inputStr.length === 1) {
        return inputStr.toUpperCase().charCodeAt();
      }
      return 0;
    }

    function viableHotKeyTarget(domElem) {
      var nodeName = domElem.nodeName;
      if (!nodeName) {
        return false;
      }
      nodeName = nodeName.toLowerCase();
      if (!!~nonViableNodeList.indexOf(nodeName)) {
        return false;
      }
      for (var i in nonViableAttributeList) {
        if (domElem.attributes.getNamedItem(nonViableAttributeList[i])) {
          return false;
        }
      }

      return true;
    }

    function init() {
      keyMap = {
        'backspace': 8,
        'tab': 9,
        'clear': 12,
        'enter': 13,
        'return': 13,
        'esc': 27,
        'escape': 27,
        'space': 32,
        'left': 37,
        'up': 38,
        'right': 39,
        'down': 40,
        'del': 46,
        'delete': 46,
        'home': 36,
        'end': 35,
        'pageup': 33,
        'pagedown': 34,
        ',': 188,
        '.': 190,
        '/': 191,
        '`': 192,
        '-': 189,
        '=': 187,
        ';': 186,
        '\'': 222,
        '[': 219,
        ']': 221,
        '\\': 220,
      };

      nonViableNodeList = ["input", "textarea", "select", "option"];

      nonViableAttributeList = ["contenteditable", "elements-hotkey-ignore"];

      hotkeys = [];
    }

  }

})();;
(function() {  
  angular.module('hpe.elements.keyboardNavigationService', []);
})();;
(function() {
	angular.module('hpe.elements.keyboardNavigationService').service('keyboardNavigationService', keyboardNavigationService);

	function keyboardNavigationService() {
		var vm = this;

		vm.events = [];

		vm.keydown = function(element, keyCode, callback, priority, stopPropagation) {

			var event = {
				element: element,
				keyCode: keyCode,
				callback: callback,
				priority: priority ? priority : 1,
				stopPropagation: stopPropagation ? stopPropagation : false
			};

			// check if the element already has a keydown event listener
			// only add another if it doesnt
			var eventAttached = vm.events.filter(function(event) {
				return (event.element === element);
			}).length > 0;

			// if events array empty then add event to array
			// if non-empty check if event already exists in array and if not add it
			vm.events.push(event);
			

			// sort events by priority
			vm.events.sort(function(a, b) {
				if(a.priority > b.priority) {
					return 1;
				}
				if(a.priority < b.priority) {
					return -1;
				}
				return 0;
			});

			// if element has event attached to it, create keydown for it 
			// and call each event on keydown if the keyCode matches
			if(!eventAttached) {

				element.on('keydown', function(keyEvent) {

					var matchingEvents = vm.events.filter(function(event) {
						return event.keyCode === keyEvent.keyCode && event.element === element;
					});

					for (var i = 0; i < matchingEvents.length; i++) {
						
						var event = matchingEvents[i];

						event.callback.call(this, keyEvent);

						if(event.stopPropagation) {
							break;
						}
					}


				});
			}

		};

	}

})();;
(function () {

  angular.module('hpe.elements.lineDataService', []).factory("lineDataService", lineDataService);

  function lineDataService() {

    return {
      addZeroPoints: function (passedDatapoints, dataOffset) {

        var currentX, nextX, offset;
        var newpoints = [],
          datapoints = [];

        if (dataOffset !== undefined && dataOffset !== 0)
          offset = dataOffset;
        else
          offset = 1; // default

        //if data points are passed as pairs, make them linear
        if (passedDatapoints[0].length === 2) {

          for (i = 0; i < passedDatapoints.length; i++) {
            for (j = 0; j < passedDatapoints[0].length; j++) {
              datapoints.push(passedDatapoints[i][j]);
            }
          }
        } else {
          datapoints = passedDatapoints;
        }
        //insert zero point at the beginning
        var firstPoint = parseInt(datapoints[0]);

        //Add a point before the actual first point and put zero
        newpoints.push(firstPoint - offset);
        newpoints.push(0);



        for (var i = 0; i < datapoints.length; i += 2) {

          //Push the actual points
          newpoints.push(datapoints[i]);
          newpoints.push(datapoints[i + 1]);

          //Donot process last point or go beyond last point
          if (i < datapoints.length - 2) {
            currentX = parseInt(datapoints[i]);
            nextX = parseInt(datapoints[i + 2]);

            //if distance between current and next points
            // is equal to twice the offset, put a point between them
            if (nextX - currentX === 2 * offset) {
              newpoints.push(currentX + offset);
              newpoints.push(0);
            }

            //if distance between current and next points is greater than twice the offset,
            //put one zero point each after current point and before next point
            else if (nextX - currentX > 2 * offset) {
              newpoints.push(currentX + offset);
              newpoints.push(0);
              newpoints.push(nextX - offset);
              newpoints.push(0);
            }
          }

        }
        var lastpoint = datapoints[datapoints.length - 2];

        //Put a zero point after the last point
        newpoints.push(lastpoint + offset);
        newpoints.push(0);

        //now pass this as pair of elements like coordinates
        var pairedpoints = [];

        for (var j = 0; j < newpoints.length; j += 2) {
          pairedpoints.push([newpoints[j], newpoints[j + 1]]);
        }

        datapoints = pairedpoints;

        return datapoints;

      }

    };
  }
})();;
(function() {  
  angular.module('hpe.elements.notificationService', []);
})();
;
(function () {

    angular.module('hpe.elements.notificationService').service('notificationService', notificationService);

    function notificationService() {
        var vm = this;

        vm.notifications = [];
        vm.notificationsVisible = true;

        /*
          Public Functions
        */
        vm.showNotification = function (options) {

            var defaultOptions = {
                icon: '',
                title: '',
                text: '',
                duration: 4000,
                backgroundColor: '#60798D',
                subtitle: '',
                date: new Date()
            };

            //generate complete list of options from user defined options
            options = angular.extend(defaultOptions, options);

            //store the notification details
            vm.notifications.push(options);

            //if notifications should not be visibly shown - stop here
            if (vm.notificationsVisible === false) return;

            //this is a wrapper function used to maintain correct scope
            return showNotification.apply(vm, [options]);
        };

        vm.setNotificationVisibility = function (value) {
            vm.notificationsVisible = value;
        };

        vm.dismissNotification = function (notification) {
            dismissNotification.apply(vm, [notification]);
        };

        vm.dismissAllNotifications = function () {
            var container = getContainer();

            //get any notifications
            var notifications = container.getElementsByClassName('notification');

            //iterate and dismiss each notification
            for (var i = 0; i < notifications.length; i++) {

                //get the appropriate notification
                var notification = notifications[i];

                //ensure it is not currently being dismissed
                if (notification.className.indexOf('fadeOutNotification'))
                    dismissNotification.apply(vm, [notification]);
            }
        };

        vm.getNotifications = function () {
            return vm.notifications;
        };

        /*
          Private Function
        */

        function createContainer() {
            /*
              This function will create a container in the top right corner of the browser window,
              if one does not already exist, to correctly position any notifications
            */
            var container = document.getElementsByClassName('notification-container');

            //if container exists - no need to proceed
            if (container && container.length === 1) return;

            //otherwise create the container
            container = document.createElement('div');

            //give the container the correct id
            container.className = 'notification-container';

            //add the container to the page
            document.body.appendChild(container);

            //return the newly created container element
            return container;
        }

        function getContainer() {
            /*
              This function will get the container if one exists,
              if one does not exist then create one
            */

            var container = document.getElementsByClassName('notification-container');

            //if container exists then return the element
            if (container && container.length === 1) return container[0];

            //if no container exists create and return the element
            return createContainer();
        }

        function showNotification(options) {
            /*
              This will allow adding of a new notification to the container,
              It should set the icon, the text, the duration and the color
            */

            var notification = document.createElement('div');
            notification.className = 'notification';

            //create close button
            var closeBtn = document.createElement('div');
            closeBtn.className = 'dismiss';

            //add close event handler
            closeBtn.addEventListener('click', function (event) {
                dismissNotification.apply(vm, [event.currentTarget.parentElement]);
            });

            //close icon
            var closeIcon = document.createElement('div');
            closeIcon.className = 'hpe-icon hpe-close';

            //add close icon to button and button to notification
            closeBtn.appendChild(closeIcon);
            notification.appendChild(closeBtn);

            //create container for icon and text
            var contentContainer = document.createElement('div');
            contentContainer.className = 'notification-content';

            //create icon container
            var iconContainer = document.createElement('div');
            iconContainer.className = 'notification-icon';

            //add icon to icon container
            var iconElement = document.createElement('span');
            iconElement.className = 'hpe-icon ' + options.icon;
            iconContainer.appendChild(iconElement);

            //create text container
            var textContainer = document.createElement('div');
            textContainer.className = 'notification-text';

            //add title to container if specified
            if (options.title && options.title !== '') {
                var titleElement = document.createElement('p');
                titleElement.className = 'notification-title';
                titleElement.innerHTML = options.title;
                textContainer.appendChild(titleElement);
            }

            //add text to text container
            var textElement = document.createElement('p');
            textElement.className = 'notification-label';
            textElement.innerHTML = options.text;
            textContainer.appendChild(textElement);

            //if a date string was specified then show it
            if (options.subtitle && options.subtitle !== '') {
                var subtitleElement = document.createElement('small');
                subtitleElement.className = 'notification-subtitle';
                subtitleElement.innerHTML = options.subtitle;
                textContainer.appendChild(subtitleElement);
            }

            //add containers to correct parent
            if (options.icon !== '') contentContainer.appendChild(iconContainer);
            else textContainer.style.paddingLeft = '15px';

            contentContainer.appendChild(textContainer);
            notification.appendChild(contentContainer);

            //find or create the container
            var container = getContainer();

            //add the element to the container
            container.appendChild(notification);

            //once the element has been added - add the animation class
            notification.className = 'notification fadeInNotification';

            //set the background color of the notification
            notification.style.backgroundColor = options.backgroundColor;

            //if a duration was set then automatically dismiss after that time
            if (options.duration && options.duration > 0) {
                setTimeout(function () {

                    //ensure the element still exists
                    if (notification) dismissNotification.apply(vm, [notification]);

                }, options.duration);
            }

            return notification;
        }

        function dismissNotification(notification) {

            //apply fade out animation
            notification.className = 'notification fadeOutNotification';

            //delay for 700ms (animation length) - then remove dom element
            setTimeout(function () {
                //ensure element still exists before trying to remove
                if (notification && notification.parentElement) notification.parentElement.removeChild(notification);
            }, 700);
        }

        return vm;
    }

})();;
(function () {
    angular.module('hpe.elements.resizeService', []);
})();;
(function () {

    angular.module('hpe.elements.resizeService').service('$resize', resizeService);

    function resizeService() {

        var listeners = [];

        return {
            bind: bind,
            unbind: unbind
        };

        function bind(element, callback) {

            // if no sensors added to element then attach some
            if (sensorsAttached(element) === false) {
                attachSensors(element);
            }

            // if listener no already attached
            if (listenerAttached(element, callback) === false) {

                // store the element and callback
                listeners.push({
                    element: element,
                    callback: callback
                });
            }
        }

        function unbind(element, callback) {

            // find any matching listeners
            var matches = listeners.filter(function (listener) {
                return listener.element === element && listener.callback === callback;
            });

            // iterate each match and remove
            matches.forEach(function (listener) {

                // find index of the listener
                var idx = listeners.indexOf(listener);

                // remove the item from the array
                listeners.splice(idx, 1);
            });
        }

        function attachSensors(element) {

            // create all elements
            var resizeWidth, resizeHeight;
            var resizeElement = document.createElement('div');
            var resizeGrowElement = document.createElement('div');
            var resizeGrowChildElement = document.createElement('div');
            var resizeShrinkElement = document.createElement('div');
            var resizeShrinkChildElement = document.createElement('div');

            // add necessary styling
            resizeElement.style.cssText = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: scroll; z-index: -1; visibility: hidden;';
            resizeGrowElement.style.cssText = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: scroll; z-index: -1; visibility: hidden;';
            resizeShrinkElement.style.cssText = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: scroll; z-index: -1; visibility: hidden;';

            resizeGrowChildElement.style.cssText = 'position: absolute; left: 0; top: 0;';
            resizeShrinkChildElement.style.cssText = 'position: absolute; left: 0; top: 0; width: 200%; height: 200%;';

            // Create a function to programmatically update sizes
            var updateSizes = function () {

                resizeGrowChildElement.style.width = resizeGrowElement.offsetWidth + 10 + 'px';
                resizeGrowChildElement.style.height = resizeGrowElement.offsetHeight + 10 + 'px';

                resizeGrowElement.scrollLeft = resizeGrowElement.scrollWidth;
                resizeGrowElement.scrollTop = resizeGrowElement.scrollHeight;

                resizeShrinkElement.scrollLeft = resizeShrinkElement.scrollWidth;
                resizeShrinkElement.scrollTop = resizeShrinkElement.scrollHeight;

                resizeWidth = element.offsetWidth;
                resizeHeight = element.offsetHeight;
            };

            // create functions to call when content grows
            var onGrow = function () {

                var currentWidth = element.offsetWidth,
                    currentHeight = element.offsetHeight;

                // check to see if the content has change size
                if (currentWidth > resizeWidth || currentHeight > resizeHeight) {

                    // if size has changed then call callbacks
                    informCallbacks(currentWidth, currentHeight);
                }
                // after reinitialising update sizes
                updateSizes();
            };

            // create functions to call when content shrinks
            var onShrink = function () {

                var currentWidth = element.offsetWidth,
                    currentHeight = element.offsetHeight;

                // check to see if the content has change size
                if (currentWidth < resizeWidth || currentHeight < resizeHeight) {

                    // if size has changed then call callbacks
                    informCallbacks(currentWidth, currentHeight);
                }
                // after reinitialising update sizes
                updateSizes();
            };

            var informCallbacks = function (width, height) {

                // return all callbacks for current element
                var matchingListeners = listeners.filter(function (listener) {
                    return element === listener.element;
                }).map(function (listener) {
                    return listener.callback;
                });

                matchingListeners.forEach(function (callback) {
                    callback.call(this, element, width, height);
                });
            };

            // bind to scroll events
            resizeGrowElement.addEventListener('scroll', onGrow.bind(this));
            resizeShrinkElement.addEventListener('scroll', onShrink.bind(this));

            // nest elements before adding to pane
            resizeGrowElement.appendChild(resizeGrowChildElement);
            resizeShrinkElement.appendChild(resizeShrinkChildElement);

            resizeElement.appendChild(resizeGrowElement);
            resizeElement.appendChild(resizeShrinkElement);

            element.appendChild(resizeElement);

            // get all computed styles of element
            var styles = window.getComputedStyle(element, null);

            // ensure parent element is not statically positioned
            if (styles.getPropertyValue('position') === 'static') {
                element.style.position = 'relative';
            }

            // ensure element is not display inline
            if (styles.getPropertyValue('display') === 'inline') {
                console.log('Elements Resize Service - This will not work correctly on inline elements. Consider using block or inline-block instead.');
            }

            // update sizes initially
            updateSizes();

        }

        function sensorsAttached(element) {
            var matchingElements = listeners.filter(function (listener) {
                return listener.element === element;
            });

            return matchingElements.length !== 0;
        }

        function listenerAttached(element, callback) {
            var matchingElements = listeners.filter(function (listener) {
                return listener.element === element && listener.callback === callback;
            });

            return matchingElements.length !== 0;
        }
    }
})();;
(function () {  
  angular.module("hpe.elements.safeAnimationFrame", []);
})();
;
(function() {
  
  angular.module("hpe.elements.safeAnimationFrame").service("safeAnimationFrame", ['$window', safeAnimationFrame]);

  function safeAnimationFrame($window) {

    return {
      create: create
    };

    function create($scope) {

      //create shim
      $window.requestAnimFrame = (function() {
        return $window.requestAnimationFrame ||
          $window.webkitRequestAnimationFrame ||
          $window.mozRequestAnimationFrame ||
          function(callback) {
            $window.setTimeout(callback, 1000 / 60);
          };
      })();

      var callbacks = [];
      var isDestroyed = false;

      //start loop
      (function loop() {
        if (isDestroyed) return;

        //process all callbacks
        processCallbacks();

        $window.requestAnimFrame(loop);
      })();

      $scope.$on('$destroy', function() {

        //clear all callbacks
        callbacks = [];

        isDestroyed = true;
      });

      return {
        animationFrame: animationFrame,
        cancelAnimationFrame: cancelAnimationFrame
      };

      function cancelAnimationFrame(id) {
        callbacks[id] = null;
      }

      function animationFrame(handler) {
        //store function - return id
        return callbacks.push(handler);
      }

      function processCallbacks() {
        for (var i = 0; i < callbacks.length; i++) {
          var callback = callbacks[i];
          if (callback) callback();
        }
      }
    }

  }

})();
;
(function () {  
  angular.module("hpe.elements.safeEventListener", []);
})();
;
(function () {

	angular.module("hpe.elements.safeEventListener").service("safeEventListener", safeEventListener);

	function safeEventListener() {

		return {
			create: create
		};

		function create($scope) {

			var events = [];

			$scope.$on('$destroy', function () {

				//Cancel any remaining promises
				for (var i = 0; i < events.length; i++) {
					var evt = events[i];
					if (!evt.destroyed) unbind(evt.element, evt.evt, evt.handler);
				}
				events = [];
			});

			return {
				bind: bind,
				unbind: unbind
			};

			function unbind(element, evt, handler) {
				for (var i = 0; i < events.length; i++) {
					var evnt = events[i];

					if (evnt.element === element && evnt.evt === evt && evnt.handler === handler) {

						//if already destroyed we dont need to do again
						if (evnt.destroyed) continue;

						//remove associate event listener
						evnt.element.removeEventListener(evnt.evt, evnt.handler);

						evnt.destroyed = true;
					}
				}
			}

			function bind(element, evt, handler) {
				events.push({
					element: element,
					evt: evt,
					handler: handler,
					destroyed: false
				});

				element.addEventListener(evt, handler);
			}
		}

	}

})();;
(function () {
  angular.module("hpe.elements.safeInterval", []);
})();;
(function () {

	angular.module("hpe.elements.safeInterval").service("safeInterval", safeInterval);

	safeInterval.$inject = ["$interval"];

	function safeInterval($interval) {

		return {
			create: create
		};

		function create($scope) {

			var intervals = {};

			$scope.$on('$destroy', function () {

				//Cancel any remaining promises
				for (var interval in intervals) {
					$interval.cancel(intervals[interval]);
				}

			});

			return {
				interval: interval,
				cancel: cancel
			};

			function cancel(interval) {

				//cancel the interval
				$interval.cancel(intervals[interval.$$intervalId]);

				//release the object
				delete intervals[interval.$$intervalId];
			}

			function interval(func, delay, count, invokeApply) {

				if(count === undefined) {
					count = 0;
				}

				if(invokeApply === undefined) {
					invokeApply = true;
				}

				//Set an interval
				var interval = $interval(func, delay, count, invokeApply);

				//Record the interval
				intervals[interval.$$intervalId] = interval;

				//Return the passthrough result from the interval call
				return interval;
			}
		}

	}

})();;
(function () {  
  angular.module("hpe.elements.safeTimeout", []);
})();
;
(function () {

	angular.module("hpe.elements.safeTimeout").service("safeTimeout", safeTimeout);

	safeTimeout.$inject = ["$timeout"];

	function safeTimeout($timeout) {

		return {
			create: create
		};

		function create($scope) {

			var timers = {};

			$scope.$on('$destroy', function () {

				//Cancel any remaining promises
				for (var timer in timers) {
					$timeout.cancel(timers[timer]);
				}

			});

			return {
				timeout: timeout,
				cancel: cancel
			};

			function cancel(timer) {

				//cancel the timer
				$timeout.cancel(timers[timer.$$timeoutId]);

				//release the object
				delete timers[timer.$$timeoutId];
			}

			function timeout(func, delay) {

				//Set a timer 
				var timeout = $timeout(decoratedFunc, delay);

				//Record the timer
				timers[timeout.$$timeoutId] = timeout;

				//Return the passthrough result from the timer call
				return timeout;

				//Set timer with wrapper that records when the timeout has executed
				function decoratedFunc() {

					try {
						//release the object
						delete timers[timeout.$$timeoutId];

						//perform the delayed function
						return func();

					} catch (e) {
						console.error(e);
					}
				}

			}
		}

	}

})();;
(function () {
  angular.module('hpe.elements.timeAgoService', []);
})();;
(function () {

    angular.module('hpe.elements.timeAgoService').service('timeAgoService', timeAgoService);

    function timeAgoService() {
        var vm = this;

        var defaultStrings = {
            lessThanSecond: 'less than a second ago',
            second: '1 second ago',
            seconds: '{x} seconds ago',
            minute: '1 minute ago',
            minutes: '{x} minutes ago',
            hour: '1 hour ago',
            hours: '{x} hours ago',
            day: '1 day ago',
            days: '{x} days ago',
            week: '1 week ago',
            weeks: '{x} weeks ago',
            month: '1 month ago',
            months: '{x} months ago',
            year: '1 year ago',
            years: '{x} years ago'
        };

        //store the active string set
        var stringSet = defaultStrings;

        //time enum
        vm.timeUnit = {
            second: 1000,
            minute: 60000,
            hour: 3600000,
            day: 86400000,
            week: 604800000,
            month: 2419200000,
            year: 31536000000
        };

        vm.setStrings = function (strings) {
            //update the string set
            stringSet = angular.extend(defaultStrings, strings);
        };

        vm.timeSinceNow = function (date) {
            //call the time since function with the since time as now
            return vm.timeSince(date, new Date());
        };

        vm.timeSince = function (date, dateSince) {

            //get epochs
            var dateEpoch = date.getTime();
            var dateSinceEpoch = dateSince.getTime();

            //time difference
            var timeDifference = dateSinceEpoch - dateEpoch;

            //ensure the date was in the past
            if (timeDifference < 0) throw 'Time Ago Service - Cannot convert future dates to a string';

            //less than one second ago
            if (timeDifference < vm.timeUnit.second) return stringSet.lessThanSecond;

            //one second ago
            if (timeDifference < (vm.timeUnit.second * 2)) return stringSet.second;

            //x seconds ago
            if (timeDifference < (vm.timeUnit.minute)) return formatString(Math.floor(timeDifference / vm.timeUnit.second), stringSet.seconds);

            //one minute ago
            if (timeDifference < (vm.timeUnit.minute * 2)) return stringSet.minute;

            //x minutes ago
            if (timeDifference < (vm.timeUnit.minute * 60)) return formatString(Math.floor(timeDifference / vm.timeUnit.minute), stringSet.minutes);

            //one hour ago
            if (timeDifference < (vm.timeUnit.hour * 2)) return stringSet.hour;

            //x hours ago
            if (timeDifference < (vm.timeUnit.hour * 24)) return formatString(Math.floor(timeDifference / vm.timeUnit.hour), stringSet.hours);

            //one day ago
            if (timeDifference < (vm.timeUnit.day * 2)) return stringSet.day;

            //x days ago
            if (timeDifference < (vm.timeUnit.day * 7)) return formatString(Math.floor(timeDifference / vm.timeUnit.day), stringSet.days);

            //one week ago
            if (timeDifference < (vm.timeUnit.week * 2)) return stringSet.week;

            //x weeks ago
            if (timeDifference < (vm.timeUnit.week * 4)) return formatString(Math.floor(timeDifference / vm.timeUnit.week), stringSet.weeks);

            //one month ago
            if (timeDifference < (vm.timeUnit.month * 2)) return stringSet.month;

            //x months ago
            if (timeDifference < (vm.timeUnit.month * 12)) return formatString(Math.floor(timeDifference / vm.timeUnit.month), stringSet.months);

            //one year ago
            if (timeDifference < (vm.timeUnit.year * 2)) return stringSet.year;

            //x years ago
            else return formatString(Math.floor(timeDifference / vm.timeUnit.year), stringSet.years);

        };

        function formatString(unit, string) {
            if (string.indexOf('{x}') === -1)
                throw 'Time Ago - Variable unit strings should have an {x} in the string to define where the unit should be placed.';

            return string.replace('{x}', unit);
        }

        return vm;
    }

})();;
(function() {  
  angular.module('hpe.elements.windowCommunicationService', []);
})();
;
(function () {

	angular.module('hpe.elements.windowCommunicationService').service('windowCommunicationService', windowCommunicationService);

	windowCommunicationService.$inject = ['$compile', '$templateRequest', '$document', '$window'];

	function windowCommunicationService($compile, $templateRequest, $document, $window) {
		var vm = this;

		var newWindow;

		vm.createWindow = function (windowTitle, scope, url, winWidth, winHeight, winX, winY) {
			var width = winWidth === undefined ? screen.width - 200 : winWidth;
			var height = winHeight === undefined ? screen.height - 400 : winHeight;
			var left = winX === undefined ? screen.width / 2 - width / 2 + FindLeftWindowBoundry() : winX;
			var top = winY === undefined ? screen.height / 2 - height / 2 + FindTopWindowBoundry() : winY;

			// html for the head and body of the new window
			var html = '<!DOCTYPE html>' +
				'<html>' +
				'<head>' +
				'  <meta charset="utf-8">' +
				'  <meta name="viewport" content="width=device-width, initial-scale=1.0">' +
				'  <meta http-equiv="X-UA-Compatible" content="IE=edge" />' +
				'</head>' +
				'<body>' +
				'</body>' +
				'</html>';

			// get the links and scripts required for the new window
			var links = angular.element($document).find('link');
			var scripts = angular.element($document).find('script');

			// load the preview pane template
			var promise = $templateRequest(url);

			// open a new blank window approximately in the centre of the screen
			newWindow = $window.open('about:blank', windowTitle, 'height=' + height + ',width=' + width + ',left=' + left + ',top=' + top);

			promise.then(function (template) {
				// prepare the new window with the html head and body
				newWindow.document.write(html);

				var window_head = newWindow.document.head;
				var window_body = newWindow.document.body;

				// add required links to head
				links.each(function (idx, link) {
					window_head.innerHTML += link.outerHTML;
				});

				// add template to body
				window_body.innerHTML += template;

				// add required scripts to body
				scripts.each(function (idx, script) {
					window_body.innerHTML += script.outerHTML;
				});

				// compile the new window against the scope we passed in
				$compile(newWindow.document)(scope);
			});

			return newWindow;
		};


		// if url has changed to show a different page, call this method to update to window to show the new content
		vm.updateContent = function (scope, url) {
			var promise = $templateRequest(url);

			promise.then(function (template) {
				angular.element(newWindow.document.body).contents().not("script").remove();
				newWindow.document.body.innerHTML += template;
				$compile(newWindow.document)(scope);
			});
		};

	}

	function FindLeftWindowBoundry() {
		// In Internet Explorer window.screenLeft is the window's left boundry
		if (window.screenLeft) {
			return window.screenLeft;
		}

		// In Firefox window.screenX is the window's left boundry
		if (window.screenX)
			return window.screenX;

		return 0;
	}
	// Find Left Boundry of current Window
	function FindTopWindowBoundry() {
		// In Internet Explorer window.screenLeft is the window's top boundry
		if (window.screenTop) {
			return window.screenTop;
		}

		// In Firefox window.screenY is the window's top boundry
		if (window.screenY)
			return window.screenY;

		return 0;
	}

})();;
/*!
 LICENSE-START
 angular-breadcrumb - v0.3.2-dev-2014-12-14
 * http://ncuillery.github.io/angular-breadcrumb
 * Copyright (c) 2014 Nicolas Cuillery; Licensed MIT
 LICENSE-END
 */

(function(window, angular, undefined) {

  function isAOlderThanB(scopeA, scopeB) {
    if (angular.equals(scopeA.length, scopeB.length)) {
      return scopeA > scopeB;
    } else {
      return scopeA.length > scopeB.length;
    }
  }

  function parseStateRef(ref) {
    var parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/);
    if (!parsed || parsed.length !== 4) {
      throw new Error("Invalid state ref '" + ref + "'");
    }
    return {
      state: parsed[1],
      paramExpr: parsed[3] || null
    };
  }

  function $Breadcrumb() {

    var $$options = {
      prefixStateName: null,
      template: 'bootstrap3',
      templateUrl: null,
      includeAbstract: false
    };

    this.setOptions = function (options) {
      angular.extend($$options, options);
    };

    this.$get = ['$state', '$stateParams', '$rootScope',
      function ($state, $stateParams, $rootScope) {

        var $lastViewScope = $rootScope;

        // Early catch of $viewContentLoaded event
        $rootScope.$on('$viewContentLoaded', function (event) {
          // With nested views, the event occur several times, in "wrong" order
          if (isAOlderThanB(event.targetScope.$id, $lastViewScope.$id)) {
            $lastViewScope = event.targetScope;
          }
        });

        // Get the parent state
        var $$parentState = function (state) {
          // Check if state has explicit parent OR we try guess parent from its name
          var name = state.parent || (/^(.+)\.[^.]+$/.exec(state.name) || [])[1];
          // If we were able to figure out parent name then get this state
          return name;
        };

        // Add the state in the chain if not already in and if not abstract
        var $$addStateInChain = function (chain, stateRef) {
          var conf,
            parentParams,
            ref = parseStateRef(stateRef);

          for (var i = 0, l = chain.length; i < l; i += 1) {
            if (chain[i].name === ref.state) {
              return;
            }
          }

          conf = $state.get(ref.state);
          if ((!conf.abstract || $$options.includeAbstract) && !(conf.ncyBreadcrumb && conf.ncyBreadcrumb.skip)) {
            if (ref.paramExpr) {
              parentParams = $lastViewScope.$eval(ref.paramExpr);
            }

            conf.ncyBreadcrumbLink = $state.href(ref.state, parentParams || $stateParams || {});
            chain.unshift(conf);
          }
        };

        // Get the state for the parent step in the breadcrumb
        var $$breadcrumbParentState = function (stateRef) {
          var ref = parseStateRef(stateRef),
            conf = $state.get(ref.state);

          if (conf.ncyBreadcrumb && conf.ncyBreadcrumb.parent) {
            // Handle the "parent" property of the breadcrumb, override the parent/child relation of the state
            var isFunction = typeof conf.ncyBreadcrumb.parent === 'function';
            var parentStateRef = isFunction ? conf.ncyBreadcrumb.parent($lastViewScope) : conf.ncyBreadcrumb.parent;
            if (parentStateRef) {
              return parentStateRef;
            }
          }

          return $$parentState(conf);
        };

        return {

          getTemplate: function (templates) {
            if ($$options.templateUrl) {
              // templateUrl takes precedence over template
              return null;
            } else if (templates[$$options.template]) {
              // Predefined templates (bootstrap, ...)
              return templates[$$options.template];
            } else {
              return $$options.template;
            }
          },

          getTemplateUrl: function () {
            return $$options.templateUrl;
          },

          getStatesChain: function (exitOnFirst) { // Deliberately undocumented param, see getLastStep
            var chain = [];

            // From current state to the root
            for (var stateRef = $state.$current.self.name; stateRef; stateRef = $$breadcrumbParentState(stateRef)) {
              $$addStateInChain(chain, stateRef);
              if (exitOnFirst && chain.length) {
                return chain;
              }
            }

            // Prefix state treatment
            if ($$options.prefixStateName) {
              $$addStateInChain(chain, $$options.prefixStateName);
            }

            return chain;
          },

          getLastStep: function () {
            var chain = this.getStatesChain(true);
            return chain.length ? chain[0] : undefined;
          },

          $getLastViewScope: function () {
            return $lastViewScope;
          }
        };
    }];
  }

  var getExpression = function (interpolationFunction) {
    if (interpolationFunction.expressions) {
      return interpolationFunction.expressions;
    } else {
      var expressions = [];
      angular.forEach(interpolationFunction.parts, function (part) {
        if (angular.isFunction(part)) {
          expressions.push(part.exp);
        }
      });
      return expressions;
    }
  };

  var registerWatchers = function (labelWatcherArray, interpolationFunction, viewScope, step) {
    angular.forEach(getExpression(interpolationFunction), function (expression) {
      var watcher = viewScope.$watch(expression, function () {
        step.ncyBreadcrumbLabel = interpolationFunction(viewScope);
      });
      labelWatcherArray.push(watcher);
    });

  };

  var deregisterWatchers = function (labelWatcherArray) {
    angular.forEach(labelWatcherArray, function (deregisterWatch) {
      deregisterWatch();
    });
    labelWatcherArray = [];
  };

  function BreadcrumbDirective($interpolate, $breadcrumb, $rootScope) {
    var $$templates = {
      bootstrap2: '<ul class="breadcrumb">' +
        '<li ng-repeat="step in steps" ng-switch="$last || !!step.abstract" ng-class="{active: $last}">' +
        '<a ng-switch-when="false" href="{{step.ncyBreadcrumbLink}}">{{step.ncyBreadcrumbLabel}}</a> ' +
        '<span ng-switch-when="true">{{step.ncyBreadcrumbLabel}}</span>' +
        '<span class="divider" ng-hide="$last">/</span>' +
        '</li>' +
        '</ul>',
      bootstrap3: '<ol class="breadcrumb">' +
        '<li ng-repeat="step in steps" ng-class="{active: $last}" ng-switch="$last || !!step.abstract">' +
        '<a ng-switch-when="false" href="{{step.ncyBreadcrumbLink}}">{{step.ncyBreadcrumbLabel}}</a> ' +
        '<span ng-switch-when="true">{{step.ncyBreadcrumbLabel}}</span>' +
        '</li>' +
        '</ol>'
    };

    return {
      restrict: 'AE',
      replace: true,
      scope: {},
      template: $breadcrumb.getTemplate($$templates),
      templateUrl: $breadcrumb.getTemplateUrl(),
      link: {
        post: function postLink(scope) {
          var labelWatchers = [];

          var renderBreadcrumb = function () {
            deregisterWatchers(labelWatchers);
            var viewScope = $breadcrumb.$getLastViewScope();
            scope.steps = $breadcrumb.getStatesChain();
            angular.forEach(scope.steps, function (step) {
              if (step.ncyBreadcrumb && step.ncyBreadcrumb.label) {
                var parseLabel = $interpolate(step.ncyBreadcrumb.label);
                step.ncyBreadcrumbLabel = parseLabel(viewScope);
                // Watcher for further viewScope updates
                registerWatchers(labelWatchers, parseLabel, viewScope, step);
              } else {
                step.ncyBreadcrumbLabel = step.name;
              }
            });
          };

          $rootScope.$on('$viewContentLoaded', function () {
            renderBreadcrumb();
          });

          // View(s) may be already loaded while the directive's linking
          renderBreadcrumb();
        }
      }
    };
  }
  BreadcrumbDirective.$inject = ['$interpolate', '$breadcrumb', '$rootScope'];

  function BreadcrumbLastDirective($interpolate, $breadcrumb, $rootScope) {

    return {
      restrict: 'A',
      scope: {},
      template: '{{ncyBreadcrumbLabel}}',
      compile: function (cElement, cAttrs) {

        // Override the default template if ncyBreadcrumbLast has a value
        var template = cElement.attr(cAttrs.$attr.ncyBreadcrumbLast);
        if (template) {
          cElement.html(template);
        }

        return {
          post: function postLink(scope) {
            var labelWatchers = [];

            var renderLabel = function () {
              deregisterWatchers(labelWatchers);
              var viewScope = $breadcrumb.$getLastViewScope();
              var lastStep = $breadcrumb.getLastStep();
              if (lastStep) {
                scope.ncyBreadcrumbLink = lastStep.ncyBreadcrumbLink;
                if (lastStep.ncyBreadcrumb && lastStep.ncyBreadcrumb.label) {
                  var parseLabel = $interpolate(lastStep.ncyBreadcrumb.label);
                  scope.ncyBreadcrumbLabel = parseLabel(viewScope);
                  // Watcher for further viewScope updates
                  // Tricky last arg: the last step is the entire scope of the directive !
                  registerWatchers(labelWatchers, parseLabel, viewScope, scope);
                } else {
                  scope.ncyBreadcrumbLabel = lastStep.name;
                }
              }
            };

            $rootScope.$on('$viewContentLoaded', function () {
              renderLabel();
            });

            // View(s) may be already loaded while the directive's linking
            renderLabel();
          }
        };

      }
    };
  }
  BreadcrumbLastDirective.$inject = ['$interpolate', '$breadcrumb', '$rootScope'];

  angular.module('ncy-angular-breadcrumb', ['ui.router.state'])
    .provider('$breadcrumb', $Breadcrumb)
    .directive('ncyBreadcrumb', BreadcrumbDirective)
    .directive('ncyBreadcrumbLast', BreadcrumbLastDirective);
})(window, window.angular);
angular.module('hpe.elements.templates', ['template/angular-breadcrumb.html', 'template/datepicker/day.html', 'template/datepicker/month.html', 'template/datepicker/popup.html', 'template/datepicker/year.html', 'template/pagination/pagination.html', 'applicationSwitcher/applicationSwitcherContainer/template/applicationSwitcherContainer.html', 'applicationSwitcher/applicationSwitcherItem/template/applicationSwitcherItem.html', 'backButton/template/backButton.html', 'backButtonHeader/template/backButtonHeader.html', 'cardTabs/templates/cardSet.html', 'checkbox/checkbox.html', 'contacts/templates/contact.html', 'contacts/templates/contactGroup.html', 'dateTimePicker/templates/dateTimePicker.html', 'dateTimePicker/templates/timePicker.html', 'displayPanels/displayPanel/template/displayPanel.html', 'draggableCards/template/draggableCard.html', 'draggableCards/template/draggableCards.html', 'draggableCards/template/fixedCard.html', 'expandInputs/template/expandInput.html', 'facets/facet/template/facet.html', 'facets/facetContainer/template/facetContainer.html', 'facets/facetCustom/template/facetCustom.html', 'facets/facetDynamic/template/facetDynamic.html', 'facets/facetOption/template/facetOption.html', 'filters/filter/template/filter.html', 'filters/filter/template/filterOptions.html', 'filters/filterContainer/template/filterContainer.html', 'filters/filterOption/template/filterOption.html', 'floatingActionButton/template/floatingActionButton.html', 'helpCenter/template/helpCenterMenu.html', 'hoverActions/templates/hoverAction.html', 'listHoverActions/listHoverAction/template/listHoverAction.html', 'listHoverActions/template/listHoverActions.html', 'marqueeWizard/templates/marqueeWizard.html', 'menuTab/templates/menuTab.html', 'modalInsetPanel/templates/modalInsetHeader.html', 'multipleListSelect/displayCancelOption/template/displayCancelOption.html', 'multipleListSelect/displaySelectOptions/template/displaySelectOptions.html', 'multipleListSelect/multipleListSelectActions/template/multipleListSelectActions.html', 'multipleListSelect/multipleListSelectItem/template/multipleListSelectItem.html', 'multipleSelect/multipleSelectAction/template/multipleSelectAction.html', 'multipleSelect/multipleSelectActions/template/multipleSelectActions.html', 'numberPicker/template/numberPicker.tmpl.html', 'partitionMap/template/editTemplate.html', 'partitionMap/template/partitionMap.html', 'partitionMap/template/popoverTemplate.html', 'previewPanes/previewPane/template/previewPane.html', 'previewPanes/previewPaneToggle/template/previewPaneToggle.html', 'radiobutton/radiobutton.html', 'sankey/template/sankey.html', 'scrollTop/template/scrollTop.html', 'searchBuilder/templates/searchComponent.html', 'searchBuilder/templates/searchGroup.html', 'searchToolbar/template/searchToolbar.html', 'selectTable/template/selectTable.html', 'sideModal/sideModalDialog/template/sideModalDialog.html', 'sideModal/sideModalWindow/template/sideWindowDialog.html', 'slider/slider.html', 'socialChart/template/socialChart.html', 'sorters/detailRowHeader/template/detailRowHeader.html', 'sorters/multiSortableHeader/template/multiSortableHeader.html', 'sorters/sortDirectionToggle/template/sortDirectionToggle.html', 'sorters/sorter/template/sorter.html', 'sorters/sorterHeader/template/sortableHeader.html', 'sorters/sorterOption/template/sorterOption.html', 'spark/template/spark.html', 'splitter/templates/splitter.html', 'splitter/templates/splitterPanel.html', 'tagInput/template/customAutocompleteTemplate.html', 'tagInput/template/tagInput.html', 'treeView/template/_partial.html', 'treeView/template/treeView.html', 'wizard/template/step.html', 'wizard/template/wizard.html']);

angular.module("template/angular-breadcrumb.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/angular-breadcrumb.html",
    "<ol class=\"breadcrumb\">\n" +
    "  <div ng-if=\"steps.length - 1==0\" class=\"p-t-md\"></div>\n" +
    "  <li ng-repeat=\"step in steps | limitTo: steps.length-1\" ng-switch=\"!!step.abstract\" >\n" +
    "    <a ng-switch-when=\"false\" href=\"{{step.ncyBreadcrumbLink}}\">{{step.ncyBreadcrumbLabel}}</a> \n" +
    "    <span ng-switch-when=\"true\">{{step.ncyBreadcrumbLabel}}</span>\n" +
    "  </li>\n" +
    "</ol>");
}]);

angular.module("template/datepicker/day.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/day.html",
    "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th ng-click=\"move(-1)\" tabindex=\"-1\"><span class=\"hpe-icon hpe-previous\"></span></th>\n" +
    "      <th colspan=\"{{5 + showWeeks}}\" class=\"datepicker-switch\" id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" ng-click=\"toggleMode()\" tabindex=\"-1\">{{title}}</th>\n" +
    "      <th ng-click=\"move(1)\" tabindex=\"-1\"><span class=\"hpe-icon hpe-next\"></span></th>\n" +
    "    </tr>\n" +
    "    <tr>\n" +
    "      <th ng-show=\"showWeeks\"></th>\n" +
    "      <th ng-repeat=\"label in labels track by $index\" aria-label=\"{{label.full}}\">{{label.abbr}}</th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr ng-repeat=\"row in rows track by $index\">\n" +
    "      <td ng-show=\"showWeeks\"><em>{{ weekNumbers[$index] }}</em></td>\n" +
    "      <td ng-repeat=\"dt in row track by dt.date\" class=\"day\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\"\n" +
    "          ng-class=\"{ active: isActive(dt),'old':dt.secondary}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\">{{dt.label}}\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "  <tfoot ng-if=\"$parent.$parent.showButtonBar\">\n" +
    "    <tr>\n" +
    "      <th colspan=\"7\" class=\"today\" ng-click=\"$parent.$parent.$parent.select('today')\">{{$parent.$parent.$parent.getText('current')}}</th>\n" +
    "    </tr>\n" +
    "  </tfoot>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/month.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/month.html",
    "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th ng-click=\"move(-1)\" tabindex=\"-1\"><span class=\"hpe-icon hpe-previous\"></span></th>\n" +
    "      <th colspan=\"{{5 + showWeeks}}\" class=\"datepicker-switch\" id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" ng-click=\"toggleMode()\" tabindex=\"-1\">{{title}}</th>\n" +
    "      <th ng-click=\"move(1)\" tabindex=\"-1\"><span class=\"hpe-icon hpe-next\"></span></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr>\n" +
    "      <td colspan=\"7\">\n" +
    "        <div class=\"inline\" ng-repeat=\"row in rows track by $index\">\n" +
    "          <span class=\"month\" ng-repeat=\"dt in row track by dt.date\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\"\n" +
    "                ng-class=\"{active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\">{{dt.label}}\n" +
    "          </span>\n" +
    "        </div>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "  <tfoot ng-if=\"$parent.$parent.showButtonBar\">\n" +
    "    <tr>\n" +
    "      <th colspan=\"7\" class=\"today\" ng-click=\"$parent.$parent.$parent.select('today')\">{{$parent.$parent.$parent.getText('current')}}</th>\n" +
    "    </tr>\n" +
    "  </tfoot>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/datepicker/popup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/popup.html",
    "<ul class=\"datepicker datepicker-dropdown dropdown-menu datepicker-orient-left datepicker-orient-top\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\" ng-keydown=\"keydown($event)\">\n" +
    "  <li ng-transclude></li>\n" +
    "</ul>");
}]);

angular.module("template/datepicker/year.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/datepicker/year.html",
    "<table role=\"grid\" aria-labelledby=\"{{uniqueId}}-title\" aria-activedescendant=\"{{activeDateId}}\">\n" +
    "  <thead>\n" +
    "    <tr>\n" +
    "      <th ng-click=\"move(-1)\" tabindex=\"-1\"><span class=\"hpe-icon hpe-previous\"></span></th>\n" +
    "      <th id=\"{{uniqueId}}-title\" role=\"heading\" aria-live=\"assertive\" aria-atomic=\"true\" class=\"datepicker-switch\" ng-click=\"toggleMode()\" tabindex=\"-1\">{{title}}</th>\n" +
    "      <th ng-click=\"move(1)\" tabindex=\"-1\"><span class=\"hpe-icon hpe-next\"></span></th>\n" +
    "    </tr>\n" +
    "  </thead>\n" +
    "  <tbody>\n" +
    "    <tr>\n" +
    "      <td colspan=\"7\">\n" +
    "        <div class=\"inline\" ng-repeat=\"row in rows track by $index\">\n" +
    "          <span ng-repeat=\"dt in row track by dt.date\" class=\"text-center\" role=\"gridcell\" id=\"{{dt.uid}}\" aria-disabled=\"{{!!dt.disabled}}\"\n" +
    "                ng-class=\"{active: isActive(dt)}\" ng-click=\"select(dt.date)\" ng-disabled=\"dt.disabled\" tabindex=\"-1\">\n" +
    "            {{dt.label}}\n" +
    "          </span>\n" +
    "        </div>\n" +
    "      </td>\n" +
    "    </tr>\n" +
    "  </tbody>\n" +
    "  <tfoot ng-if=\"$parent.$parent.showButtonBar\">\n" +
    "    <tr>\n" +
    "      <th colspan=\"7\" class=\"today\" ng-click=\"$parent.$parent.$parent.select('today')\">{{$parent.$parent.$parent.getText('current')}}</th>\n" +
    "    </tr>\n" +
    "  </tfoot>\n" +
    "</table>\n" +
    "");
}]);

angular.module("template/pagination/pagination.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("template/pagination/pagination.html",
    "<ul class=\"pagination\">\n" +
    "  <li ng-if=\"boundaryLinks\" ng-class=\"{disabled: noPrevious()}\">\n" +
    "    <a href ng-click=\"selectPage(1)\" tabindex=\"{{tabIndex+1}}\" class=\"btn\">{{getText('first')}}</a>\n" +
    "  </li>\n" +
    "  <li ng-if=\"directionLinks\" ng-class=\"{disabled: noPrevious()}\">\n" +
    "    <a href ng-click=\"selectPage(page - 1)\" tabIndex=\"{{tabIndex+1}}\" class=\"btn\">\n" +
    "      <i class=\"hpe-icon hpe-previous\"></i>\n" +
    "      <span class=\"sr-only\">{{getText('previous')}}</span>\n" +
    "    </a>\n" +
    "  </li>\n" +
    "  <li ng-repeat=\"page in pages track by $index\" ng-class=\"{active: page.active}\">\n" +
    "    <a href ng-click=\"selectPage(page.number)\" tabIndex=\"{{tabIndex+1+$index}}\" class=\"btn\">{{page.text}}</a>\n" +
    "  </li>\n" +
    "  <li ng-if=\"directionLinks\" ng-class=\"{disabled: noNext()}\">\n" +
    "    <a href ng-click=\"selectPage(page + 1)\" tabIndex=\"{{tabIndex+totalPages}}\" class=\"btn\">\n" +
    "      <i class=\"hpe-icon hpe-next\"></i>\n" +
    "      <span class=\"sr-only\">{{getText('next')}}</span></a></li>\n" +
    "  <li ng-if=\"boundaryLinks\" ng-class=\"{disabled: noNext()}\">\n" +
    "    <a href ng-click=\"selectPage(totalPages)\" tabIndex=\"{{tabIndex+totalPages}}\" class=\"btn\">{{getText('last')}}</a>\n" +
    "  </li>\n" +
    "</ul>\n" +
    "");
}]);

angular.module("applicationSwitcher/applicationSwitcherContainer/template/applicationSwitcherContainer.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("applicationSwitcher/applicationSwitcherContainer/template/applicationSwitcherContainer.html",
    "<span ng-transclude></span>");
}]);

angular.module("applicationSwitcher/applicationSwitcherItem/template/applicationSwitcherItem.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("applicationSwitcher/applicationSwitcherItem/template/applicationSwitcherItem.html",
    "<li>\n" +
    "    <a>\n" +
    "        <i ng-if=\"asi.checked\" class=\"hpe-icon hpe-checkmark text-muted m-r-xs\"></i><span ng-class=\"{'m-l-md': !asi.checked}\" ng-bind=\"name\"></span>\n" +
    "    </a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("backButton/template/backButton.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("backButton/template/backButton.html",
    "<a class=\"btn-back m-r-xs\" aria-label=\"{{ariaLabel}}\" role=\"button\" type=\"button\"></a>");
}]);

angular.module("backButtonHeader/template/backButtonHeader.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("backButtonHeader/template/backButtonHeader.html",
    "<span class=\"hpe-icon hpe-previous text-primary\"></span>\n" +
    "");
}]);

angular.module("cardTabs/templates/cardSet.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("cardTabs/templates/cardSet.html",
    "<div>\n" +
    "  <div class=\"tab-content-container top\"></div>\n" +
    "  <div class=\"card-tab-container\">\n" +
    "    <ul class=\"card-tabs\" ng-transclude></ul>\n" +
    "    <div class=\"page-btn previous\">\n" +
    "      <i class=\"hpe-icon hpe-previous\"></i>\n" +
    "    </div>\n" +
    "    <div class=\"page-btn next\">\n" +
    "      <i class=\"hpe-icon hpe-next\"></i>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "  <div class=\"tab-content-container bottom\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("checkbox/checkbox.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("checkbox/checkbox.html",
    "<label class=\"el-checkbox-label\" ng-click=\"vm.toggleChecked()\">\n" +
    "\n" +
    "    <div class=\"el-checkbox\" \n" +
    "         tabindex=\"0\"\n" +
    "         ng-keydown=\"vm.keydown($event)\"\n" +
    "         ng-class=\"{ 'checked': vm.ngModel === true, 'indeterminate': vm.indeterminate, 'simplified': vm.simplified, 'disabled': vm.ngDisabled }\">\n" +
    "\n" +
    "        <input type=\"checkbox\" \n" +
    "            role=\"checkbox\" \n" +
    "            aria-checked=\"{{ vm.ngModel }}\"\n" +
    "            aria-disabled=\"{{ vm.ngDisabled }}\"\n" +
    "            name=\"{{ ::vm.name }}\" \n" +
    "            ng-model=\"vm.ngModel\" \n" +
    "            tabindex=\"-1\"\n" +
    "            ng-disabled=\"vm.ngDisabled\" />\n" +
    "    </div>\n" +
    "\n" +
    "    <div class=\"el-checkbox-content\" ng-transclude></div>\n" +
    "</label>");
}]);

angular.module("contacts/templates/contact.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("contacts/templates/contact.html",
    "<div class=\"status\"></div>\n" +
    "<div class=\"contact {{ size }}\" ng-bind=\"contact.text\" tooltip-html=\"contact.tooltip\"></div>\n" +
    "");
}]);

angular.module("contacts/templates/contactGroup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("contacts/templates/contactGroup.html",
    "<div class=\"contacts-list-container\" ng-show=\"contacts[0].text && organization\">\n" +
    "  <ul class=\"contacts-list\">\n" +
    "    <li ng-repeat=\"contact in contacts | limitTo: maxContacts\" ng-show=\"contact.text\">\n" +
    "      <elements-contact contact=\"contact\" size=\"size\" order=\"$index\" colors=\"colors\" show-status=\"showStatus\"></elements-contact>\n" +
    "    </li>\n" +
    "  </ul>\n" +
    "  <div class=\"contact-overflow-container\" ng-if=\"contacts.length > maxContacts\">\n" +
    "    <div class=\"contact-overflow {{size}}\" ng-class=\"{ 'contact-overflow-clickable': overflowClickable }\" ng-style=\"{ 'color': colors.secondary, 'background-color': colors.primary }\" ng-click=\"overflowClick()\">&hellip;</div>\n" +
    "    <div class=\"contact-overflow-label\" ng-class=\"size\" ng-bind=\"overflowCount(contacts.length, maxContacts)\"></div>\n" +
    "  </div>\n" +
    "  <div class=\"organization\" ng-class=\"size\" ng-bind=\"organization.text\" tooltip-html=\"organization.tooltip\" ng-show=\"organization.text\"></div>\n" +
    "  <div class=\"organization-label {{label}}\" ng-if=\"organization.label && label\"></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("dateTimePicker/templates/dateTimePicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("dateTimePicker/templates/dateTimePicker.html",
    "<div class=\"date-picker\" ng-show=\"chooseDate\">\n" +
    "    <datepicker ng-model=\"dtpk.date\" class=\"datepicker\" hide-active=\"editing\"></datepicker>\n" +
    "    <button type=\"button\" class=\"btn today-btn button-secondary\" ng-click=\"dtpk.goToday()\">Today</button>\n" +
    "</div>\n" +
    "<div ng-show=\"chooseTime||chooseTimeZone\" ng-class=\"{'timepicker-dark':chooseDate, 'timepicker-light': !chooseDate}\">\n" +
    "    <time-picker></time-picker>\n" +
    "</div>\n" +
    "");
}]);

angular.module("dateTimePicker/templates/timePicker.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("dateTimePicker/templates/timePicker.html",
    "<table class=\"timepicker\">\n" +
    "    <tbody>\n" +
    "        <tr>\n" +
    "            <td>\n" +
    "                <span ng-show=\"!chooseDate\" class=\"p-l-md\"> </span>\n" +
    "                <span ng-show=\"chooseDate\" class=\"hpe-icon hpe-alarm hp-lg\"></span>\n" +
    "            </td>\n" +
    "            <td ng-show=\"chooseTime\" class=\"form-group\" ng-class=\"{'has-error': invalidHours}\">\n" +
    "                <input style=\"width: 40px; padding-right: 12px\" type=\"text\" ng-model=\"tmpk.hours\" class=\"form-control text-center\" ng-model-options=\"{ updateOn: 'blur' }\" maxlength=\"2\">\n" +
    "            </td>\n" +
    "            <td ng-show=\"chooseTime\" class=\"form-group\" ng-class=\"{'has-error': invalidMinutes}\">\n" +
    "                <input style=\"width: 40px; padding-right: 12px\" type=\"text\" ng-model=\"tmpk.minutes\" class=\"form-control text-center\" ng-model-options=\"{ updateOn: 'blur' }\" maxlength=\"2\">\n" +
    "            </td>\n" +
    "            <td ng-show=\"chooseTime && chooseSeconds\" class=\"form-group\" ng-class=\"{'has-error': invalidSeconds}\">\n" +
    "                <input style=\"width: 40px; padding-right: 12px\" type=\"text\" ng-model=\"tmpk.seconds\" class=\"form-control text-center\" ng-model-options=\"{ updateOn: 'blur' }\" maxlength=\"2\">\n" +
    "            </td>\n" +
    "            <td ng-show=\"chooseTime && isMeridian\">\n" +
    "                <button style=\"width: 40px\" type=\"button\" class=\"btn meridian-btn btn-secondary text-center\"  ng-click=\"tmpk.toggleMeridian()\" ng-bind=\"tmpk.meridian\"></button>\n" +
    "            </td>\n" +
    "            <td ng-show=\"chooseTimeZone\">\n" +
    "                <div class=\"btn-group\" dropdown is-open=\"timezoneDropDownOpen\">\n" +
    "                    <button type=\"button\" class=\"btn inline-dropdown timezone-dropdown dropdown-toggle\" dropdown-toggle>\n" +
    "                        <span ng-bind=\"tmpk.timezone\" style=\"vertical-align:inherit;\"></span>\n" +
    "                        <span class=\"hpe-icon hpe-down\"></span>\n" +
    "                    </button>\n" +
    "                    <ul class=\"dropdown-menu\" role=\"menu\">\n" +
    "                        <li ng-repeat=\"timezone in dtpk.timezones\"><a href=\"\" ng-click=\"tmpk.selectTimezone($index)\" ng-bind=\"timezone\"></a></li>\n" +
    "                    </ul>\n" +
    "                </div>\n" +
    "            </td>\n" +
    "        </tr>\n" +
    "    </tbody>\n" +
    "</table>\n" +
    "");
}]);

angular.module("displayPanels/displayPanel/template/displayPanel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("displayPanels/displayPanel/template/displayPanel.html",
    "<div ng-class=\"modalOpt.modalColumns\" class=\"display-panel p-l-nil\" ng-style=\"{top: top}\">\n" +
    "    <div ng-class=\"{'display-panel-header-affix display-panel-content full-width':modalOpt.title!=''}\">\n" +
    "        <div ng-if=\"modalOpt.title\" class=\"header p-l-md\">\n" +
    "            <div ng-class=\"{'preview-pane-shadow': $parent.shadow==true}\">\n" +
    "                <div>\n" +
    "                    <h3 class=\"modalheader m-b-nil\" ng-bind=\"modalOpt.title\"></h3>\n" +
    "                    <span class=\"modal-close\">\n" +
    "                    <button type=\"button\" class=\"btn btn-white\" ng-click=\"close()\" tabindex=\"1\">\n" +
    "                        <i class=\"hpe-icon hpe-close\"></i>\n" +
    "                    </button>\n" +
    "                </span>\n" +
    "                </div>\n" +
    "            </div>\n" +
    "        </div>\n" +
    "        <div class=\"main display-scroll\" scroll-config=\"{ autoReinitialise: false, resizeSensor: true, showOnlyOnHover:true, enableKeyboardNavigation:true, initialDelay :0, contentWidth:'0px'}\"\n" +
    "            scroll-pane id=\"displaypanelscroll\">\n" +
    "        </div>\n" +
    "        <div ng-if=\"modalOpt.footer\" ng-class=\"modalOpt.modalColumns\" class=\"footer p-l-nil\">\n" +
    "            <div>\n" +
    "                <div ng-include=\"modalOpt.footer\"></div>\n" +
    "            </div>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "</div>");
}]);

angular.module("draggableCards/template/draggableCard.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("draggableCards/template/draggableCard.html",
    "<div class=\"card-container\">\n" +
    "  <div class=\"card draggable\">\n" +
    "    <div class=\"callout\"></div>\n" +
    "    <div class=\"title-container\" ng-show=\"showHeader\">\n" +
    "      <div class=\"m-b-nil title\" ng-style=\"{ 'padding-right' : showTitle ? '8px': 0 }\"><p ng-bind=\"cardTitle\" class=\"title-text\" overflow-tooltip></p> \n" +
    "        <span class=\"text-muted title-subtext\" ng-bind=\"cardSubtitle\"></span> \n" +
    "        <i class=\"hpe-icon hpe-edit draggable-icon editing-btn show-on-hover\" ng-show=\"allowEditing\" ng-class=\"{'disabled': disableEdit}\"></i>\n" +
    "        <i ng-repeat=\"icon in cardIcons\" class=\"hpe-icon draggable-icon show-on-hover {{ ::icon.icon }}\" ng-class=\"{ 'disabled': icon.disabled }\" ng-disable=\"icon.disabled\" tooltip=\"{{icon.tooltip}}\" ng-click=\"icon.disabled || icon.click()\"></i>\n" +
    "      </div>\n" +
    "      <div class=\"close-btn show-on-hover\" ng-show=\"allowRemoving\" ng-class=\"{'disabled': disableRemove}\"></div>\n" +
    "    </div>\n" +
    "    <div class=\"content-area\">\n" +
    "      <div class=\"drag-container\">\n" +
    "        <div class=\"center-controls\" ng-show=\"allowReordering\">\n" +
    "          <div class=\"arrow-up show-on-hover\"></div>\n" +
    "          <div class=\"drag-handle show-on-hover\"></div>\n" +
    "          <div class=\"arrow-down show-on-hover\"></div>\n" +
    "        </div>\n" +
    "      </div>\n" +
    "      <div class=\"card-template\">\n" +
    "        <ng-transclude></ng-transclude>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("draggableCards/template/draggableCards.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("draggableCards/template/draggableCards.html",
    "<div class=\"draggable-card-scroller\">\n" +
    "  <div class=\"draggable-card-container\" tabindex=\"0\">\n" +
    "    <ng-transclude></ng-transclude>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("draggableCards/template/fixedCard.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("draggableCards/template/fixedCard.html",
    "<div class=\"card-container\">\n" +
    "  <div class=\"card fixed\">\n" +
    "    <div class=\"callout\"></div>\n" +
    "    <p class=\"m-b-nil title\">{{ cardTitle }} <span class=\"text-muted\">{{ cardSubtitle }}</span></p>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("expandInputs/template/expandInput.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("expandInputs/template/expandInput.html",
    "<div class=\"input-group-sm expand-input\" ng-class=\"{ 'input-group': vm.expanded }\">\n" +
    "\n" +
    "    <!-- Text Input Field -->\n" +
    "    <input type=\"text\" \n" +
    "           ng-class=\"vm.className\" \n" +
    "           placeholder=\"{{ ::vm.placeHolder }}\" \n" +
    "           name=\"{{ ::vm.name }}\" \n" +
    "           ng-model=\"vm.value\"\n" +
    "           ng-focus=\"vm.updateState(true)\"\n" +
    "           ng-blur=\"vm.updateState(false)\" \n" +
    "           ng-keypress=\"vm.keyPressed($event)\"\n" +
    "           ng-keydown=\"vm.keyDown($event)\">\n" +
    "\n" +
    "    <!-- Clear Text Button -->\n" +
    "    <div class=\"input-group-btn input-group-btn-append\" ng-show=\"vm.expanded\">\n" +
    "        <button class=\"btn btn-white expand-input-clear\" ng-mousedown=\"vm.clear($event)\">\n" +
    "            <i ng-class=\"[vm.iconBase, vm.clearTextIcon]\"></i>\n" +
    "        </button>\n" +
    "    </div>\n" +
    "\n" +
    "    <!-- Close Button -->\n" +
    "    <div class=\"input-group-addon\" ng-show=\"vm.expanded\">\n" +
    "        <button class=\"btn btn-link button-secondary btn-sm expand-input-close\" ng-bind=\"vm.closeSearch\" ng-click=\"vm.close()\"></button>\n" +
    "    </div>\n" +
    "\n" +
    "</div>\n" +
    "\n" +
    "\n" +
    "");
}]);

angular.module("facets/facet/template/facet.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("facets/facet/template/facet.html",
    "<div class=\"facet\">\n" +
    "\n" +
    "  <a class=\"facet-header\" href=\"\" ng-click=\"fac.toggleExpand($event)\" ng-keydown=\"fac.toggleExpandKey($event)\" tabindex=\"1\">\n" +
    "    <span single-line-overflow-tooltip class=\"facet-name\" ng-bind=\"name\"></span>\n" +
    "    <span class=\"pull-right hpe-icon\" ng-class=\"{'hpe-down':fac.expanded,'hpe-previous':!fac.expanded}\"></span>\n" +
    "  </a>\n" +
    "  <div ng-if=\"enableScroll\" class=\"facet-scroll\" scroll-config=\"fac.scrollConfig\" scroll-pane scroll-name=\"facetScroll\">\n" +
    "    <ul class=\"facet-options\" ng-transclude ng-show=\"fac.expanded\">\n" +
    "    </ul>\n" +
    "  </div>\n" +
    "  <div ng-if=\"!enableScroll\">\n" +
    "    <ul class=\"facet-options\" ng-transclude ng-show=\"fac.expanded\">\n" +
    "    </ul>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("facets/facetContainer/template/facetContainer.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("facets/facetContainer/template/facetContainer.html",
    "<div class=\"facets-container\">\n" +
    "  <div class=\"facets-selected-container clearfix\" ng-if=\"fc.selected.length > 0 || fc.noItemsText\">\n" +
    "    <div class=\"facets-selected-title\">{{fc.selectTitle}}\n" +
    "      <a  ng-if=\"fc.selected.length > 0\" class=\"facets-selected-clear pull-right\" href=\"\" ng-click=\"fc.clearAll()\" tooltip=\"{{fc.clearText}}\" aria-label=\"{{fc.clearText}}\" tooltip-placement=\"left\" tooltip-append-to-body=\"false\" tabindex=\"1\"></a>\n" +
    "    </div>\n" +
    "    <p ng-if=\"fc.noItemsText && fc.selected.length === 0\" ng-bind=\"fc.noItemsText\" class=\"facets-none-selected\"></p>\n" +
    "    <ul class=\"clearfix\">\n" +
    "      <li ng-repeat=\"selected in fc.selected\">\n" +
    "        <a href=\"\" ng-click=\"selected.deselect();\" tabindex=\"1\">\n" +
    "          <span class=\"facet-selected-name\" ng-bind=\"selected.option.displayName || selected.option.name\"></span>&nbsp;\n" +
    "          <span class=\"hpe-icon hpe-close\"></span>\n" +
    "        </a>\n" +
    "      </li>\n" +
    "    </ul>\n" +
    "  </div>\n" +
    "  <div ng-transclude></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("facets/facetCustom/template/facetCustom.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("facets/facetCustom/template/facetCustom.html",
    "<div class=\"facet facet-custom\">\n" +
    "\n" +
    "  <a class=\"facet-header\" href=\"\" ng-click=\"fac.toggleExpand($event)\" ng-keydown=\"fac.toggleExpandKey($event)\" tabindex=\"1\">\n" +
    "    <span class=\"facet-name\" ng-bind=\"title\"></span>\n" +
    "    <span class=\"pull-right hpe-icon\" ng-class=\"{'hpe-down':fac.expanded,'hpe-previous':!fac.expanded}\"></span>\n" +
    "  </a>\n" +
    "\n" +
    "  <div ng-transclude ng-show=\"fac.expanded\">\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("facets/facetDynamic/template/facetDynamic.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("facets/facetDynamic/template/facetDynamic.html",
    "<div class=\"facet facet-dynamic\">\n" +
    "\n" +
    "  <a class=\"facet-header\" href=\"\" ng-click=\"fac.toggleExpand($event)\" ng-keydown=\"fac.toggleExpandKey($event)\" tabindex=\"1\">\n" +
    "    <span class=\"facet-name\" ng-bind=\"title\"></span>\n" +
    "    <span class=\"pull-right hpe-icon\" ng-class=\"{'hpe-down':fac.expanded,'hpe-previous':!fac.expanded}\"></span>\n" +
    "  </a>\n" +
    "\n" +
    "   <div>\n" +
    "    <ul ng-if=\"fac.showFacetOptions\" class=\"facet-options m-b-nil\" ng-show=\"fac.expanded\">\n" +
    "   		<dynamic-facet-option ng-repeat=\"option in fac.visibleFacetOptions\" name=\"option.name\" select=\"option.select()\" count=\"option.count\" deselect=\"option.deselect()\" show-zero=\"fac.showZero\" disabled=\"option.disabled\"></dynamic-facet-option>\n" +
    "   	</ul>\n" +
    "  	<ul ng-if=\"fac.useTypeaheadControl\" class=\"facet-options facet-options-dynamic\" ng-show=\"fac.expanded\">\n" +
    "  		<li ng-repeat=\"facet in fac.selectedDynamicFacets\" class=\"facet-option\">\n" +
    "  			<a href=\"\" ng-click=\"fac.remove(facet,$index)\">\n" +
    "    			<span class=\"facet-option-check hpe-icon hpe-checkmark\" aria-label=\"Selected\"></span>\n" +
    "    			<span class=\"facet-option-name\" ng-bind=\"facet.option.name\"></span>&nbsp;\n" +
    "    			<span class=\"facet-option-count\">(<span ng-bind=\"facet.option.count\"></span>)</span>\n" +
    "			</a>\n" +
    "  		</li>\n" +
    "  		<li class=\"input-container\">\n" +
    "  			<textarea rows=\"1\" ng-attr-placeholder=\"{{fac.placeholder}}...\" type=\"text\" ng-model=\"fac.dynamicTypeaheadSelected.text\"\n" +
    "  			typeahead=\"option as (option.name +' (' + option.count + ')') for option in fac.facetOptions.options | facetDynamicSelectedFilter: fac.selectedDynamicFacets | facetDynamicVisibleFilter: fac.visibleFacetOptions | filter: $viewValue | limitTo: fac.maxDisplayableItems\"\n" +
    "        ng-change=\"fac.dynamicTypeaheadOnChange()\"\n" +
    "        regex=\"regex\" apply-class=\"fontClass\"\n" +
    "  			typeahead-min-length=\"fac.minCharsForTypeahead\"\n" +
    "  			typeahead-on-select=\"fac.select($item, $model, $label)\"\n" +
    "  			class=\"form-control\"\n" +
    "        expanding-textarea\n" +
    "        disable-return=\"{{ disableReturn }}\"\n" +
    "        max-visible-lines=\"{{ maxLines }}\" \n" +
    "        tabindex=\"1\"></textarea>\n" +
    "  		</li>\n" +
    "  	</ul>\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("facets/facetOption/template/facetOption.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("facets/facetOption/template/facetOption.html",
    "<li ng-show=\"count!==0 || showZero\" class=\"facet-option\" ng-class=\"{ 'disabled': disabled }\">\n" +
    "  <a href=\"\" ng-click=\"fo.toggle()\" tabindex=\"1\">\n" +
    "    <span class=\"facet-option-check hpe-icon hpe-checkmark\" ng-class=\"{'invisible':!checked}\" aria-label=\"{{selectedAriaLabel}}\"></span>\n" +
    "    <span single-line-overflow-tooltip class=\"facet-option-name\" ng-bind=\"name\"></span>&nbsp;\n" +
    "    <span ng-show=\"count !== undefined && count !== null\" class=\"facet-option-count\">(<span ng-bind=\"count\"></span>)</span>\n" +
    "  </a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("filters/filter/template/filter.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("filters/filter/template/filter.html",
    "<div class=\"btn-group filter\">\n" +
    "    <button data-toggle=\"dropdown\" ng-class=\"class\" class=\"filter-dropdown btn dropdown-toggle\" aria-expanded=\"false\"\n" +
    "            id=\"btndropdown\">{{name}}<span class=\"hp-icon hp-chevron-down\"></span>\n" +
    "    </button>\n" +
    "    <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"btndropdown\" ng-transclude ></ul>\n" +
    "</div>");
}]);

angular.module("filters/filter/template/filterOptions.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("filters/filter/template/filterOptions.html",
    "<div class=\"btn-group filter dynamic-filter-toggle\">\n" +
    "    <button data-toggle=\"dropdown\" ng-class=\"class\" class=\"filter-dropdown btn dropdown-toggle\" aria-expanded=\"false\"\n" +
    "            id=\"btndropdown\">{{name}}<span class=\"hp-icon hp-chevron-down\"></span>\n" +
    "    </button>\n" +
    "\n" +
    "    <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"btndropdown\" ng-if=\"!showListControl\">\n" +
    "\n" +
    "    <!-- Default Option (before fixed options) -->\n" +
    "    <filter-option ng-if=\"dynamicOptions.options[0]\" name=\"dynamicOptions.options[0].name\"\n" +
    "                                                   select=\"dynamicOptions.options[0].select()\"\n" +
    "                                                   default=\"dynamicOptions.options[0].default\"></filter-option>\n" +
    "\n" +
    "    <!-- Fixed Options -->\n" +
    "    <filter-option ng-repeat=\"option in dynamicOptions.fixedOptions\" name=\"option.name\"\n" +
    "                                                   select=\"option.select()\"\n" +
    "                                                   default=\"option.default\"></filter-option>\n" +
    "    <!-- Other filters -->\n" +
    "		<filter-option ng-repeat=\"option in dynamicOptions.options\" ng-if=\"!$first\" name=\"option.name\"\n" +
    "                                                   select=\"option.select()\"\n" +
    "                                                   default=\"option.default\"></filter-option>\n" +
    "\n" +
    "    </ul>\n" +
    "\n" +
    "   <ul class=\"dropdown-menu dynamic-filter\" role=\"menu\" aria-labelledby=\"btndropdown\" ng-if=\"showListControl\" ng-click=\"$event.preventDefault(); $event.stopImmediatePropagation();\" >\n" +
    "    <li class=\"default-container\">\n" +
    "        <filter-option name=\"dynamicOptions.options[0].name\" select=\"dynamicOptions.options[0].select()\" default=\"dynamicOptions.options[0].default\" ng-click=\"fc.clearDynamic()\"></filter-option>\n" +
    "        <!-- Fixed Options -->\n" +
    "      <filter-option ng-repeat=\"option in dynamicOptions.fixedOptions\" name=\"option.name\" select=\"option.select()\" default=\"option.default\"  ng-click=\"fc.clearDynamic()\">\n" +
    "           </filter-option>\n" +
    "    </li>\n" +
    "    <li ng-if=\"dynamicSelected.name\" id=\"dynamic-filter\">\n" +
    "            <a href=\"\" target=\"_blank\" ng-click=\"dynamicSelected.name.select(); fc.dismiss();\">\n" +
    "              <i class=\"hpe-icon hpe-checkmark\"></i>\n" +
    "              <span>{{dynamicSelected.name}}</span>\n" +
    "            </a>\n" +
    "    </li>\n" +
    "    <li class=\"input-container\">\n" +
    "          <input placeholder=\"Find {{ type }}...\" type=\"text\" ng-model=\"dynamicTypeaheadSelected.text\" typeahead=\"option as option.name for option in dynamicOptions.options | filter:$viewValue | limitTo:maxDisplayableItems\"\n" +
    "          ng-change=\"fc.dynamicTypeaheadOnChange()\"\n" +
    "          typeahead-min-length=\"minCharsForTypeAhead\"\n" +
    "          typeahead-on-select=\"fc.dynamicFilterSelected($item, $model, $label)\"\n" +
    "           class=\"form-control\">\n" +
    "    </li>\n" +
    "\n" +
    "  </ul>\n" +
    "\n" +
    "\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("filters/filterContainer/template/filterContainer.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("filters/filterContainer/template/filterContainer.html",
    "<span>\n" +
    "    <span ng-transclude></span>\n" +
    "    <button type=\"button\" ng-class=\"containerClass\" class=\"btn btn-clear btn-icon  listview-clear\" ng-click=\"fil.clearFilter();\" tooltip=\"{{clearTooltip}}\" aria-label=\"{{clearTooltip}}\"></button>\n" +
    "</span>");
}]);

angular.module("filters/filterOption/template/filterOption.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("filters/filterOption/template/filterOption.html",
    "<li>\n" +
    "    <a href=\"\" target=\"_blank\" ng-click=\"foc.select()\">\n" +
    "        <i ng-class=\"{invisible: !selectedClass}\" class=\"hpe-icon hpe-checkmark\"></i>\n" +
    "        <span >{{foc.name}}</span>\n" +
    "    </a>\n" +
    "</li>\n" +
    "");
}]);

angular.module("floatingActionButton/template/floatingActionButton.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("floatingActionButton/template/floatingActionButton.html",
    "<span class=\"floating-action-button\" ng-mouseleave=\"collapse($event)\">\n" +
    "    <!-- Additional buttons to the top -->\n" +
    "    <ul class=\"unstyled p-l-nil child-btn-set-top top m-b-nil\" ng-if=\"direction == 'top'\">\n" +
    "        <li ng-repeat=\"key in items\">\n" +
    "            <button type=\"button\" class=\"btn btn-icon btn-circular button-secondary m-b-md\" aria-label=\"{{key.icon}}\" ng-click=\"selectedCollapse(key.event)\">\n" +
    "                <span class=\"{{ key.icon.indexOf('hp-') === -1 ? 'hpe-icon' : 'hp-icon' }}\" ng-class=\"key.icon\" aria-hidden=\"true\"></span>\n" +
    "            </button>\n" +
    "        </li>\n" +
    "    </ul>\n" +
    "\n" +
    "    <button type=\"button\" class=\"btn btn-icon btn-circular button-primary parent-btn\" ng-class=\"{'dir-top': direction=='top',\n" +
    "     'dir-left': direction=='left', 'dir-right': direction=='right' , 'dir-bottom': direction=='bottom'}\" aria-label=\"{{primary}}\"\n" +
    "            ng-click=\"expand($event)\">\n" +
    "        <span class=\"{{ primary.indexOf('hp-') === -1 ? 'hpe-icon' : 'hp-icon' }}\" ng-class=\"primary\" aria-hidden=\"true\"></span>\n" +
    "    </button>\n" +
    "\n" +
    "\n" +
    "    <!-- Additional buttons to the left -->\n" +
    "    <ul class=\"unstyled p-l-nil  child-btn-set-horizontal left inline-block\" ng-if=\"direction == 'left'\">\n" +
    "        <li class=\"inline-block\" ng-repeat=\"key in items\">\n" +
    "            <button type=\"button\" class=\"btn btn-icon btn-circular button-secondary m-r-md\" aria-label=\"{{key.icon}}\" ng-click=\"selectedCollapse(key.event)\">\n" +
    "                <span class=\"{{ key.icon.indexOf('hp-') === -1 ? 'hpe-icon' : 'hp-icon' }}\" ng-class=\"key.icon\" aria-hidden=\"true\"></span>\n" +
    "            </button>\n" +
    "        </li>\n" +
    "    </ul>\n" +
    "\n" +
    "    <!-- Additional buttons to the right -->\n" +
    "    <span class=\"child-btn-set-horizontal right inline-block\" ng-if=\"direction == 'right'\">\n" +
    "        <button ng-repeat=\"key in items\" type=\"button\" class=\"btn btn-icon btn-circular button-secondary m-r-md\" ng-class={'m-l-md':$first} aria-label=\"{{key.icon}}\" ng-click=\"selectedCollapse(key.event)\">\n" +
    "            <span class=\"{{ key.icon.indexOf('hp-') === -1 ? 'hpe-icon' : 'hp-icon' }}\" ng-class=\"key.icon\" aria-hidden=\"true\"></span>\n" +
    "        </button>\n" +
    "    </span>\n" +
    "\n" +
    "    <!-- Additional buttons to the bottom -->\n" +
    "    <ul class=\"unstyled p-l-nil child-btn-set bottom\" ng-if=\"direction == 'bottom'\">\n" +
    "        <li ng-repeat=\"key in items\">\n" +
    "            <button type=\"button\" class=\"btn btn-icon btn-circular button-secondary\" ng-class=\"{'m-b-md': !$last, 'm-t-md': $first}\" aria-label=\"{{key.icon}}\" ng-click=\"selectedCollapse(key.event)\">\n" +
    "                <span class=\"{{ key.icon.indexOf('hp-') === -1 ? 'hpe-icon' : 'hp-icon' }}\" ng-class=\"key.icon\" aria-hidden=\"true\"></span>\n" +
    "            </button>\n" +
    "        </li>\n" +
    "    </ul>\n" +
    "</span>\n" +
    "");
}]);

angular.module("helpCenter/template/helpCenterMenu.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("helpCenter/template/helpCenterMenu.html",
    "<li class=\"dropdown navbar-top-link help\">\n" +
    "    <a class=\"dropdown-toggle count-info\" data-toggle=\"dropdown\">\n" +
    "        <i class=\"{{ iconBase }} hp-fw\" ng-class=\"{{icon}}\"></i>\n" +
    "    </a>\n" +
    "    <ul class=\"dropdown-menu helpCenter\">\n" +
    "        <li>\n" +
    "            <a href=\"{{url}}\" target=\"{{ target }}\">{{helpText}}</a>\n" +
    "        </li>\n" +
    "        <li ng-if=\"menuItems.length!=0\" class=\"divider\"></li>\n" +
    "        <li ng-repeat=\"name in menuItems\">\n" +
    "            <a href=\"{{name.url}}\" target=\"{{ target }}\">\n" +
    "                {{name.title}}\n" +
    "            </a>\n" +
    "        </li>\n" +
    "    </ul>\n" +
    "</li>\n" +
    "");
}]);

angular.module("hoverActions/templates/hoverAction.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("hoverActions/templates/hoverAction.html",
    "<a tooltip=\"{{ name }}\" aria-label=\"{{ name }}\" class=\"hover-action\" ng-show=\"icon\" tabIndex=\"-1\">\n" +
    "  <span class=\"hpe-icon\" ng-class=\"icon\" ></span>\n" +
    "</a>\n" +
    "");
}]);

angular.module("listHoverActions/listHoverAction/template/listHoverAction.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("listHoverActions/listHoverAction/template/listHoverAction.html",
    "<a href=\"\" aria-label=\"{{::lha.tooltipText}}\" class=\"list-hover-action\" ng-click=\"lha.click(); $event.preventDefault(); $event.stopPropagation();\" ng-show=\"lha.icon\" tabIndex=\"-1\">\n" +
    "  <span class=\"{{ ::lha.iconBase }}\" ng-class=\"::lha.icon\" ></span>\n" +
    "</a>\n" +
    "");
}]);

angular.module("listHoverActions/template/listHoverActions.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("listHoverActions/template/listHoverActions.html",
    "<div class=\"list-hover-actions\" ng-transclude></div>");
}]);

angular.module("marqueeWizard/templates/marqueeWizard.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("marqueeWizard/templates/marqueeWizard.html",
    "<div>\n" +
    "  <div class=\"dismiss\">\n" +
    "    <button class=\"btn btn-icon button-dark btn-circular btn-close\" ng-click=\"mc.cancel()\"><i class=\"hpe-icon hpe-close\"></i></button>\n" +
    "  </div>\n" +
    "\n" +
    "  <div class=\"side-panel\">\n" +
    "    <div class=\"marquee-logo\">\n" +
    "      <div class=\"marquee-wizard-user\"></div>\n" +
    "    </div>\n" +
    "\n" +
    "    <div class=\"marquee-wizard-info-panel\" ng-if=\"mc.sidePanelInfo\">\n" +
    "      <h3 class=\"title\" ng-if=\"mc.sidePanelTitle\" ng-bind=\"mc.sidePanelTitle\" single-line-overflow-tooltip></h3>\n" +
    "      <div class=\"description\" ng-if=\"mc.sidePanelDescription\" >\n" +
    "        <p ng-bind=\"mc.sidePanelDescription\" overflow-tooltip></p>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "\n" +
    "    <ul class=\"marquee-wizard-steps\">\n" +
    "      <li class=\"marquee-wizard-step\" ng-repeat=\"step in wizardSteps\"\n" +
    "                                      ng-class=\"{ 'active': mc.currentStep.title === step.title, 'visited': step.visited, 'error': step.error }\"\n" +
    "                                      ng-click=\"mc.goToStep($index)\">\n" +
    "        <div class=\"step-label\">\n" +
    "          <div class=\"step-title\">\n" +
    "            <p class=\"title m-nil\" ng-bind=\"step.title\"></p>\n" +
    "          </div>\n" +
    "          <div class=\"step-complete\">\n" +
    "            <span class=\"hpe-icon hpe-checkmark\" ng-class=\"{ 'invisible': !step.completed }\"></span>\n" +
    "          </div>\n" +
    "        </div>\n" +
    "      </li>\n" +
    "    </ul>\n" +
    "  </div>\n" +
    "\n" +
    "  <div class=\"main-panel\">\n" +
    "\n" +
    "    <div class=\"marquee-header\">\n" +
    "      <h1 class=\"marquee-title\" ng-bind=\"mc.currentStep.header\"></h1>\n" +
    "    </div>\n" +
    "\n" +
    "    <div class=\"marquee-body marquee-wizard-modal\">\n" +
    "      <div ng-repeat=\"step in mc.steps\" ng-show=\"$index === mc.stepIndex\">\n" +
    "        <marquee-wizard-step template=\"step.templateUrl\"></marquee-wizard-step>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "\n" +
    "    <div class=\"marquee-footer\">\n" +
    "      <button type=\"button\" class=\"btn button-secondary m-r-xs marquee-previous-btn\" ng-disabled=\"!mc.buttonOptions.previousEnabled\" ng-show=\"mc.showPrevious\" ng-click=\"mc.goPrevious()\" ng-bind=\"mc.buttonOptions.previousText\"></button>\n" +
    "      <button type=\"button\" class=\"btn button-primary marquee-next-btn\" ng-disabled=\"!mc.buttonOptions.nextEnabled\" ng-show=\"mc.showNext\" ng-click=\"mc.goNext()\" ng-bind=\"mc.buttonOptions.nextText\"></button>\n" +
    "      <button type=\"button\" class=\"btn button-primary marquee-finish-btn\" ng-disabled=\"!mc.buttonOptions.finishEnabled\" ng-show=\"mc.showFinish\" ng-click=\"mc.finish()\" ng-bind=\"mc.buttonOptions.finishText\"></button>\n" +
    "    </div>\n" +
    "\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("menuTab/templates/menuTab.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("menuTab/templates/menuTab.html",
    "<div class=\"btn-group align-left menu-tab\" dropdown>\n" +
    "    <div dropdown-toggle>\n" +
    "        <button type=\"button\" class=\"btn btn-icon btn-circular button-secondary menu-tab-btn\" ng-click=\"resizeDropdown()\">\n" +
    "            <i class=\"hpe-icon hpe-more\" aria-hidden=\"true\"></i>\n" +
    "        </button>\n" +
    "    </div>\n" +
    "\n" +
    "    <ul class=\"dropdown-menu\" role=\"menu\">\n" +
    "        <div class=\"arrow\">\n" +
    "            <div class=\"arrow-inner\"></div>\n" +
    "        </div>\n" +
    "        <div class=\"align-left content\" ng-repeat=\"column in tabMenuContent\">\n" +
    "            <li><p ng-bind=\"column.title\"></p></li>\n" +
    "            <li ng-repeat=\"content in column.content\"><a class=\"hyperlink-hover\" ng-bind=\"content\" ng-click=\"addTag(content)\"></a></li>\n" +
    "        </div>\n" +
    "    </ul>\n" +
    "</div>");
}]);

angular.module("modalInsetPanel/templates/modalInsetHeader.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("modalInsetPanel/templates/modalInsetHeader.html",
    "<div class=\"modal-panel-header\">\n" +
    "  <div class=\"header-content\"></div>\n" +
    "  <div class=\"close-container\"><span class=\"hpe-icon hpe-close\"></span></div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("multipleListSelect/displayCancelOption/template/displayCancelOption.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("multipleListSelect/displayCancelOption/template/displayCancelOption.html",
    "<span ng-if=\"dc.state.selecting\">\n" +
    "    <a href=\"\" ng-click=\"dc.provider.cancel();$event.preventDefault();\" class=\"btn btn-link cancel-btn\"><span ng-bind=\"dc.provider.cancelText\" class=\"cancel-btn-text\">\n" +
    "    </span></a>\n" +
    "      <div class=\"multiple-select-error\" ng-class=\"{'show-error':dc.provider.showError}\">\n" +
    "        <span class=\"error-text\" ng-bind=\"dc.provider.selectionInvalidText\"></span>\n" +
    "      </div>      \n" +
    "</span>\n" +
    "");
}]);

angular.module("multipleListSelect/displaySelectOptions/template/displaySelectOptions.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("multipleListSelect/displaySelectOptions/template/displaySelectOptions.html",
    "<span ng-if=\"ds.state.selecting\" class=\"selecting-text\">\n" +
    "        <span class=\"multiple-list-select-text\">\n" +
    "        <span ng-bind=\"ds.provider.selectItemsText\" ng-if=\"ds.state.count===0\"></span>\n" +
    "        <span ng-if=\"ds.state.count>0\">\n" +
    "          <span ng-bind=\"ds.provider.selectedItemsText\"></span>&nbsp;\n" +
    "        <b ng-bind=\"ds.state.count\"></b>&nbsp;\n" +
    "        <span ng-if=\"ds.state.count>1\" ng-bind=\"ds.provider.selectedItemsUnitText\"></span>\n" +
    "        <span ng-if=\"ds.state.count===1\" ng-bind=\"ds.provider.selectedItemUnitText\"></span>&nbsp;&nbsp;\n" +
    "        </span>\n" +
    "        </span>\n" +
    "        <a href=\"\" class=\"multiple-select-link\" ng-click=\"ds.provider.selectAll();\" ng-if=\"!ds.state.selectAllMode || ds.provider.deselectedItems.length\">\n" +
    "          <span ng-bind=\"ds.provider.selectAllText\"></span>\n" +
    "        </a>\n" +
    "        <a href=\"\" class=\"multiple-select-link\" ng-click=\"ds.provider.selectNone();\" ng-if=\"ds.state.selectAllMode && !ds.provider.deselectedItems.length\">\n" +
    "          <span ng-bind=\"ds.provider.selectNoneText\"></span>\n" +
    "        </a>\n" +
    "        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\n" +
    "      \n" +
    "       </span>\n" +
    "");
}]);

angular.module("multipleListSelect/multipleListSelectActions/template/multipleListSelectActions.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("multipleListSelect/multipleListSelectActions/template/multipleListSelectActions.html",
    "<div class=\"multiple-select-container\">\n" +
    "  <div ng-transclude ng-show=\"!dssa.provider.state.selecting\"></div>\n" +
    "  <div class=\"multiple-list-select-selecting\" ng-if=\"dssa.provider.state.selectedFromButton\">\n" +
    "    <div class=\"row\">\n" +
    "      <div class=\"col-xs-9\">\n" +
    "        <span ng-bind=\"dssa.provider.selectItemsText\" ng-if=\"dssa.state.count===0\"></span>\n" +
    "        <span ng-if=\"dssa.state.count>0\">\n" +
    "          <span ng-bind=\"dssa.provider.selectedItemsText\"></span>&nbsp;\n" +
    "        <b ng-bind=\"dssa.state.count\"></b>&nbsp;\n" +
    "        <span ng-if=\"dssa.state.count>1\" ng-bind=\"dssa.provider.selectedItemsUnitText\"></span>\n" +
    "        <span ng-if=\"dssa.state.count===1\" ng-bind=\"dssa.provider.selectedItemUnitText\"></span>&nbsp;&nbsp;\n" +
    "        </span>\n" +
    "        <a href=\"\" class=\"multiple-select-link\" ng-click=\"dssa.provider.selectAll();\" ng-if=\"!dssa.state.selectAllMode || dssa.provider.deselectedItems.length\">\n" +
    "          <span ng-bind=\"dssa.provider.selectAllText\"></span>\n" +
    "        </a>\n" +
    "        <a href=\"\" class=\"multiple-select-link\" ng-click=\"dssa.provider.selectNone();\" ng-if=\"dssa.state.selectAllMode && !dssa.provider.deselectedItems.length\">\n" +
    "          <span ng-bind=\"dssa.provider.selectNoneText\"></span>\n" +
    "        </a>\n" +
    "        <a href=\"\" ng-bind=\"dssa.provider.action.name\" class=\"btn button-primary m-r-xs m-l-lg\" ng-disabled=\"!dssa.provider.itemsSelected()\" ng-click=\"dssa.provider.proceed();\"></a>\n" +
    "        <span class=\"v-separator\"></span>\n" +
    "        <a href=\"\" ng-click=\"dssa.provider.cancel();$event.preventDefault();\" class=\"btn btn-link cancel-btn\"><span ng-bind=\"dssa.provider.cancelText\" class=\"cancel-btn-text\"></span></a>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "    <div class=\"multiple-select-error\" ng-class=\"{'show-error':dssa.provider.showError}\">\n" +
    "      <span class=\"error-text\" ng-bind=\"dssa.provider.selectionInvalidText\"></span>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "  <div class=\"multiple-list-select-selecting\">\n" +
    "  <div ng-transclude ng-show=\"dssa.provider.state.selectedFromCheckBox\"></div>\n" +
    "  </div>\n" +
    "\n" +
    "</div>");
}]);

angular.module("multipleListSelect/multipleListSelectItem/template/multipleListSelectItem.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("multipleListSelect/multipleListSelectItem/template/multipleListSelectItem.html",
    "<span class=\"multi-select-checkbox\"></span>\n" +
    "                    ");
}]);

angular.module("multipleSelect/multipleSelectAction/template/multipleSelectAction.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("multipleSelect/multipleSelectAction/template/multipleSelectAction.html",
    "<a href=\"\" class=\"btn multiple-select-action\" ng-click=\"msa.activate(); $event.preventDefault();\" ng-class=\"'button-'+msa.type\" ng-transclude></a> ");
}]);

angular.module("multipleSelect/multipleSelectActions/template/multipleSelectActions.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("multipleSelect/multipleSelectActions/template/multipleSelectActions.html",
    "<div class=\"multiple-select-container\">\n" +
    "  <div ng-transclude ng-show=\"!mssa.state.selecting\"></div>\n" +
    "  <div class=\"multiple-select-selecting\" ng-if=\"mssa.state.selecting\">\n" +
    "    <div class=\"row\">\n" +
    "      <div class=\"col-xs-9\">\n" +
    "        <span class=\"selecting-text\"> \n" +
    "          <span ng-bind=\"mssa.provider.selectItemsText\" ng-if=\"mssa.state.count===0\"></span>\n" +
    "          <span ng-if=\"mssa.state.count>0\">\n" +
    "            <span ng-bind=\"mssa.provider.selectedItemsText\"></span>&nbsp;\n" +
    "            <b ng-bind=\"mssa.state.count\"></b>&nbsp;\n" +
    "            <span ng-if=\"mssa.state.count>1\" ng-bind=\"mssa.provider.selectedItemsUnitText\"></span>\n" +
    "            <span ng-if=\"mssa.state.count===1\" ng-bind=\"mssa.provider.selectedItemUnitText\"></span>&nbsp;&nbsp;\n" +
    "          </span>\n" +
    "        </span>\n" +
    "        <a href=\"\" class=\"multiple-select-link\" ng-click=\"mssa.provider.selectAll();\" ng-if=\"!mssa.state.selectAllMode || mssa.provider.deselectedItems.length\">\n" +
    "          <span ng-bind=\"mssa.provider.selectAllText\"></span>\n" +
    "        </a>\n" +
    "        <a href=\"\" class=\"multiple-select-link\" ng-click=\"mssa.provider.selectNone();\" ng-if=\"mssa.state.selectAllMode && !mssa.provider.deselectedItems.length\">\n" +
    "          <span ng-bind=\"mssa.provider.selectNoneText\"></span>\n" +
    "        </a>\n" +
    "        <a href=\"\" ng-bind=\"mssa.provider.action.name\" class=\"btn button-primary m-r-xs m-l-lg\" ng-disabled=\"!mssa.provider.itemsSelected()\" ng-click=\"mssa.provider.proceed();\"></a>\n" +
    "        <span class=\"v-separator\"></span>\n" +
    "        <a href=\"\" ng-click=\"mssa.provider.cancel();$event.preventDefault();\" class=\"btn btn-link cancel-btn\"><span ng-bind=\"mssa.provider.cancelText\" class=\"cancel-btn-text\"></span></a>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "    <div class=\"multiple-select-error\" ng-class=\"{'show-error':mssa.provider.showError}\">\n" +
    "      <span class=\"error-text\" ng-bind=\"mssa.provider.selectionInvalidText\"></span>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>");
}]);

angular.module("numberPicker/template/numberPicker.tmpl.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("numberPicker/template/numberPicker.tmpl.html",
    "<div class=\"input-group number-picker\" ng-class=\"{ 'invalid-entry': vm.validate.inputError }\">\n" +
    "	<input type=\"text\" class=\"form-control\" ng-model=\"vm.value\" ng-keydown=\"vm.keyPressed($event)\">\n" +
    "	<div class=\"number-picker-icons\">\n" +
    "		<i class=\"hpe-icon hpe-up\" id=\"upButton\" aria-hidden=\"true\" ng-class=\"{ disabled: vm.validate.upDisabled }\" ng-click=\"vm.upClick()\"></i>\n" +
    "		<i class=\"hpe-icon hpe-down\" id=\"downButton\" aria-hidden=\"true\" ng-class=\"{ disabled: vm.validate.downDisabled }\" ng-click=\"vm.downClick()\"></i>\n" +
    "	</div>\n" +
    "</div>\n" +
    "\n" +
    "");
}]);

angular.module("partitionMap/template/editTemplate.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("partitionMap/template/editTemplate.html",
    "<div class=\"edit-container\" style=\"display: none;\">\n" +
    "  <div class=\"root-segment\">\n" +
    "    <div class=\"done-btn\" ng-click=\"editing.done()\">\n" +
    "      <div class=\"icon\"></div>\n" +
    "    </div>\n" +
    "    <p class=\"done-text\" ng-bind=\"chart.finishText\"></p>\n" +
    "  </div>\n" +
    "\n" +
    "  <!-- Segments -->\n" +
    "  <ul class=\"segment-list\">\n" +
    "\n" +
    "  </ul>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("partitionMap/template/partitionMap.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("partitionMap/template/partitionMap.html",
    "<div class=\"partition-map-container\" id=\"partition-box\">\n" +
    "\n" +
    "  <button aria-label=\"maximize\" class=\"btn btn-icon btn-circular button-primary btn-lg partition-expand\" ng-show=\"chart.allowMaximize && !chart.noData\" ng-class=\"{ 'maximized' : chart.isMaximized }\" type=\"button\" ng-click=\"chart.toggleMaximized()\">\n" +
    "    <div ng-class=\"{ 'partition-fullscreen-icon': !chart.isMaximized, 'partition-close-icon': chart.isMaximized }\"></span>\n" +
    "  </button>\n" +
    "\n" +
    "  <partition-editing show=\"chart.editMode\" groups=\"chart.groups\" rows=\"chart.maxRows\"></partition-editing>\n" +
    "  \n" +
    "  <div class=\"partition-map\">\n" +
    "\n" +
    "\n" +
    "    <h3 class=\"no-data\" ng-show=\"chart.noData\" ng-bind=\"chart.noDataLabel\"></h3>\n" +
    "    <div class=\"loading\" ng-show=\"chart.isLoading\" ng-class=\"{ 'fade-in' : chart.isLoading }\">\n" +
    "      <div class=\"contents\">\n" +
    "        <div class=\"vertically-centered\">\n" +
    "          <h3 class=\"loading-text\" ng-bind=\"chart.loadingLabel\"></h3>\n" +
    "        </div>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "  <partition-popover></partition-popover>\n" +
    "\n" +
    "  <div class=\"partition-docked-popover\" style=\"display: none\">\n" +
    "    <div ng-hide=\"chart.isLoading\">\n" +
    "    <div class=\"callout\"></div>\n" +
    "    <div class=\"user-content docked\" ng-show=\"chart.popoverTemplate !== null\"></div>\n" +
    "    <div class=\"data-content\">\n" +
    "      <div scroll-config=\"{ autoReinitialise: false, enableKeyboardNavigation: true, verticalGutter:-2 }\" scroll-name=\"partition-popover-scrollbar\" scroll-pane>\n" +
    "        <ul class=\"child-list\">\n" +
    "          <li class=\"child-item\" ng-repeat=\"child in $parent.chart.dockedChildList\" ng-click=\"$parent.chart.selectSegment(child)\">\n" +
    "            <div class=\"color-block\" ng-style=\"::{'background-color': child.color}\"></div>\n" +
    "            <p class=\"item-key\" ng-bind=\"::child.key\"></p>\n" +
    "            <p class=\"item-value pull-right text-muted\" ng-bind=\"::child.formattedValue\"></p>\n" +
    "          </li>\n" +
    "        </ul>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "  </div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("partitionMap/template/popoverTemplate.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("partitionMap/template/popoverTemplate.html",
    "<div class=\"popover bottom partition-popover\" id=\"partition-popover\" style=\"display: none\">\n" +
    "  <div class=\"arrow\"></div>\n" +
    "  <div class=\"popover-inner\">\n" +
    "    <div class=\"popover-content\">\n" +
    "      <div class=\"popover-container\">\n" +
    "        <div class=\"user-content\" ng-class=\"{ 'full-width' : $parent.chart.childList.length === 0 }\"></div>\n" +
    "        <div class=\"data-content\" ng-style=\"{'display': $parent.chart.childList.length === 0 ? 'none' : 'block'}\">\n" +
    "          <div scroll-config=\"{ autoReinitialise: false, enableKeyboardNavigation: true, verticalGutter:-2 }\" scroll-name=\"partition-popover-scrollbar\" scroll-pane>\n" +
    "            <ul class=\"child-list\">\n" +
    "              <li class=\"child-item\" ng-repeat=\"child in $parent.chart.childList\" ng-click=\"$parent.chart.selectSegment(child, 0, true)\">\n" +
    "                <div class=\"color-block\" ng-style=\"::{'background-color': child.color}\"></div>\n" +
    "                <p class=\"item-key\" ng-bind=\"::child.key\"></p>\n" +
    "                <p class=\"item-value pull-right text-muted\" ng-bind=\"::child.formattedValue\"></p>\n" +
    "              </li>\n" +
    "            </ul>\n" +
    "          </div>\n" +
    "        </div>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("previewPanes/previewPane/template/previewPane.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("previewPanes/previewPane/template/previewPane.html",
    "<div ng-show=\"pp.previewOn\" class=\"p-nil\">\n" +
    "  <div class=\"hpebox\" ng-show=\"previewFile\">\n" +
    "    <div class=\"hpebox-content\">\n" +
    "      <div ng-if=\"previewTitle || previewSubtitle\" ng-class=\"{'preview-pane-shadow': shadow==true}\">\n" +
    "        <div ng-if=\"previewTitle\">\n" +
    "          <h2 class=\"m-b-nil\" ng-bind=\"previewTitle\"></h2>\n" +
    "        </div>\n" +
    "        <div ng-if=\"previewSubtitle\">\n" +
    "          <small class=\"text-muted\" ng-bind=\"previewSubtitle\"></small>\n" +
    "        </div>\n" +
    "      </div>\n" +
    "\n" +
    "      <div class=\"preview-pane-right p-md scroll-cardview\" scroll-config=\"::{autoReinitialise: true, autoReinitialiseDelay:100, showOnlyOnHover:true, enableKeyboardNavigation:true, initialDelay :0} \" scroll-pane  id=\"previewPaneScroll\">\n" +
    "        <div class=\"previewFile\"></div>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "  <div ng-show=\"!previewFile\" class=\"no-preview-pane-right p-md\">\n" +
    "    <div class=\"preview-no-record\">\n" +
    "      <i class=\"hpe-icon hpe-document\"></i>\n" +
    "      <h2 ng-bind=\"previewEmptyText\"></h2>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("previewPanes/previewPaneToggle/template/previewPaneToggle.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("previewPanes/previewPaneToggle/template/previewPaneToggle.html",
    "<button class=\"btn btn-icon btn-white\" aria-label=\"{{ariaLabel}}\">\n" +
    "    <i ng-if=\"!setPreview\" class=\"hpe-icon hpe-divide-right\" aria-hidden=\"true\"></i>\n" +
    "    <i ng-if=\"setPreview\" class=\"hpe-icon hpe-checkbox\" aria-hidden=\"true\"></i>\n" +
    "</button>\n" +
    "");
}]);

angular.module("radiobutton/radiobutton.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("radiobutton/radiobutton.html",
    "<label class=\"el-radiobutton-label\" ng-click=\"vm.toggleChecked()\">\n" +
    "\n" +
    "    <div class=\"el-radiobutton\" \n" +
    "         tabindex=\"0\"\n" +
    "         ng-keydown=\"vm.keydown($event)\"\n" +
    "         ng-class=\"{ 'checked': vm.ngModel === vm.ngValue, 'simplified': vm.simplified, 'disabled': vm.ngDisabled }\">\n" +
    "\n" +
    "         <input type=\"radio\"\n" +
    "           role=\"radio\" \n" +
    "           aria-checked=\"{{ vm.ngModel }}\"\n" +
    "           aria-disabled=\"{{ vm.ngDisabled }}\"\n" +
    "           name=\"{{ ::vm.name }}\" \n" +
    "           ng-model=\"vm.ngModel\" \n" +
    "           ng-value=\"vm.ngValue\" \n" +
    "           tabindex=\"-1\"\n" +
    "           ng-disabled=\"vm.ngDisabled\"\n" +
    "           id=\"{{ ::vm.id }}\" />\n" +
    "    </div>\n" +
    "\n" +
    "    <div class=\"el-radiobutton-content\" ng-transclude></div>\n" +
    "</label>");
}]);

angular.module("sankey/template/sankey.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("sankey/template/sankey.html",
    "<div class=\"sankey hpe-elements-sankey-light\"></div>");
}]);

angular.module("scrollTop/template/scrollTop.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("scrollTop/template/scrollTop.html",
    "<div class=\"scroll-top\">\n" +
    "    <i class=\"hpe-icon hpe-up\" style=\"color: #fff;\" aria-hidden=\"true\"></i>\n" +
    "</div>\n" +
    "");
}]);

angular.module("searchBuilder/templates/searchComponent.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("searchBuilder/templates/searchComponent.html",
    "<div class=\"search-component\">\n" +
    "  <div class=\"component-container\">\n" +
    "  </div>\n" +
    "  <div class=\"component-remove\">\n" +
    "      <span class=\"hpe-icon hpe-close\" ng-click=\"sc.removeComponent()\"></span>\n" +
    "  </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("searchBuilder/templates/searchGroup.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("searchBuilder/templates/searchGroup.html",
    "<div class=\"search-group\">\n" +
    "\n" +
    "  <p class=\"search-group-title\" ng-bind=\"groupTitle\"></p>\n" +
    "\n" +
    "  <div class=\"search-group-content\">\n" +
    "    <div class=\"operator-label {{ operator }}\" ng-class=\"{ 'search-builder-show': sg.components.length > 1 }\">\n" +
    "      {{ operator }}\n" +
    "    </div>\n" +
    "    <div class=\"field-list\">\n" +
    "      <ul class=\"field-collection\" ng-class=\"{ 'search-builder-show': sg.components.length > 0 }\">\n" +
    "        <li class=\"field\" ng-repeat=\"component in sg.components\" component-id=\"{{ component.componentId }}\">\n" +
    "          <ng-include src=\"component.templateUrl\"></ng-include>\n" +
    "        </li>\n" +
    "      </ul>\n" +
    "      <div class=\"placeholder-field\" ng-show=\"sg.showPlaceholder\">\n" +
    "        <label class=\"form-label\">New field</label>\n" +
    "        <div class=\"form-control\"></div>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "    <div class=\"add-field\" ng-class=\"{ 'limit-reached' : sg.maxFields && (sg.components.length >= maxFields) }\">\n" +
    "      <div class=\"button-container\" ng-click=\"sg.addNewField()\">\n" +
    "        <div class=\"add-button\"><span class=\"hpe-icon hpe-add\"></span></div>\n" +
    "        <span class=\"add-text\" single-line-overflow-tooltip ng-bind=\"buttonText\"></span>\n" +
    "      </div>\n" +
    "    </div>\n" +
    "  </div>\n" +
    "  <hr class=\"group-divider\" />\n" +
    "</div>\n" +
    "");
}]);

angular.module("searchToolbar/template/searchToolbar.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("searchToolbar/template/searchToolbar.html",
    "<div class=\"input-group-sm expand-input\" ng-class=\"{'input-group': st.inputexpanded}\">\n" +
    "	<div class=\"search-toolbar-icon\">\n" +
    "		<i class=\"hpe-icon hpe-search hp-fw\"></i>\n" +
    "	</div>\n" +
    "\n" +
    "	<div class=\"search-container input-group expand-input \">\n" +
    "		<input class=\"input form-control filter-text search-toolbar-input\" typeahead=\"item for item in searchTypeahead | filter:$viewValue | limitTo:8\" typeahead-on-select=\"st.selectTypeaheadValue($item, $model, $label)\" type=\"text\" placeholder=\"{{ placeHolder }}\" ng-model=\"st.inputValue\" />\n" +
    "		\n" +
    "		<div class=\"input-group-btn input-group-btn-append \">\n" +
    "			<button type=\"button\" class=\"btn expand-input-clear search-toolbar-input\">\n" +
    "				<i class=\"hpe-icon hpe-close\"></i>\n" +
    "			</button>\n" +
    "		</div>\n" +
    "\n" +
    "		<div class=\"input-group-addon\">\n" +
    "		    <button type=\"button\" class=\"btn btn-link button-secondary btn-sm expand-input-close cancel-search\" href=\"\" ng-bind=\"closeSearch\"></button>\n" +
    "		</div>\n" +
    "	</div>\n" +
    "</div>");
}]);

angular.module("selectTable/template/selectTable.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("selectTable/template/selectTable.html",
    "<div class=\"select-table-container\" ng-style=\"{ 'height': vm.tableHeight }\">\n" +
    "  <div scroll-config=\"{ autoReinitialise: false, showOnlyOnHover:false, enableKeyboardNavigation:true }\" \n" +
    "       style=\"overflow: auto; height: 100%;\"\n" +
    "       scroll-pane id=\"{{ vm.id }}\">\n" +
    "\n" +
    "      <table class=\"table table-hover select-table\">\n" +
    "        <tbody>\n" +
    "          <tr tabindex=\"0\" \n" +
    "              ng-keydown=\"vm.keydown($event)\" \n" +
    "              ng-repeat=\"value in vm.displayVals track by $index\" \n" +
    "              ng-click=\"vm.select(value, $event)\"\n" +
    "              ng-class=\"{'highlight': vm.isselected(value) }\">\n" +
    "            \n" +
    "              <td ng-bind=\"vm.displayFn(value)\"></td>\n" +
    "\n" +
    "          </tr>\n" +
    "        </tbody>\n" +
    "      </table>\n" +
    "  </div>\n" +
    "</div>");
}]);

angular.module("sideModal/sideModalDialog/template/sideModalDialog.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("sideModal/sideModalDialog/template/sideModalDialog.html",
    "<div ng-class=\"modalOpt.modalColumns\" class=\"side-modal p-l-nil\">\n" +
    "    <div ng-class=\"{'side-modal-header-affix' :modalOpt.affixHeader==true, 'side-modal-content full-width':modalOpt.affixHeader==false}\">\n" +
    "        <div class=\"header p-l-md\">\n" +
    "            <div>\n" +
    "                <h3 class=\"modalheader m-b-nil\">{{modalOpt.title}}</h3>\n" +
    "            <span class=\"modal-close\">\n" +
    "                <button type=\"button\" class=\"btn btn-white\" ng-click=\"closeModal()\">\n" +
    "                    <i class=\"hpe-icon hpe-close\"></i>\n" +
    "                </button>\n" +
    "            </span>\n" +
    "            </div>\n" +
    "        </div>\n" +
    "        <div class=\"main\" ng-class=\"{ 'footer-hidden': modalOpt.footer === null || modalOpt.footer === undefined }\" ng-include=\"modalOpt.main\"></div>\n" +
    "    </div>\n" +
    "    <div class=\"footer p-l-nil\" ng-show=\"modalOpt.footer !== null && modalOpt.footer !== undefined\">\n" +
    "        <div>\n" +
    "            <div ng-include=\"modalOpt.footer\"></div>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "</div>\n" +
    "");
}]);

angular.module("sideModal/sideModalWindow/template/sideWindowDialog.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("sideModal/sideModalWindow/template/sideWindowDialog.html",
    "<div modal-render=\"{{$isRendered}}\" tabindex=\"-1\" role=\"dialog\" class=\"modal\" modal-animation-class=\"fade\" ng-class=\"{'in': animate}\" ng-style=\"{'z-index': 1050 + index*10, display: 'block'}\" ng-click=\"close($event)\">\n" +
    "    <div side-modal-dialog></div>\n" +
    "</div>");
}]);

angular.module("slider/slider.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("slider/slider.html",
    "<div class=\"slider\">\n" +
    "\n" +
    "    <div class=\"track\" ng-class=\"vm.options.track.height\">\n" +
    "\n" +
    "        <div class=\"track-section track-lower\"\n" +
    "             ng-style=\"{ 'flex-grow': vm.trackSizes.lower, 'background': vm.trackColors.lower }\">\n" +
    "        </div>\n" +
    "\n" +
    "        <div class=\"thumb lower\"\n" +
    "             ng-style=\"{ 'left': vm.thumbPositions.lower, 'z-index': vm.thumbOrder.lower }\"      \n" +
    "             ng-class=\"[vm.options.handles.style, vm.options.track.height]\"\n" +
    "             ng-mouseenter=\"vm.lowerThumbState.hover = true\"\n" +
    "             ng-mouseleave=\"vm.lowerThumbState.hover = false\">\n" +
    "\n" +
    "             <div class=\"tooltip top tooltip-lower\" \n" +
    "                  ng-style=\"{ 'opacity': vm.tooltipLowerVisible ? 1 : 0 }\">\n" +
    "\n" +
    "                    <div class=\"tooltip-arrow\" \n" +
    "                         ng-style=\"{'border-top-color': vm.options.handles.callout.background }\">\n" +
    "                    </div>\n" +
    "\n" +
    "                    <div class=\"tooltip-inner\" \n" +
    "                         ng-style=\"{ 'background-color': vm.options.handles.callout.background, 'color': vm.options.handles.callout.color }\" \n" +
    "                         ng-bind=\"vm.options.handles.callout.formatter(vm.thumbLowerValue)\">\n" +
    "                    </div>\n" +
    "             </div>\n" +
    "        </div>\n" +
    "\n" +
    "        <div class=\"track-section track-range\"\n" +
    "             ng-show=\"vm.options.type === 'range'\"\n" +
    "             ng-style=\"{ 'flex-grow': vm.trackSizes.range, 'background': vm.trackColors.range }\">\n" +
    "        </div>\n" +
    "\n" +
    "        <div class=\"thumb upper\" \n" +
    "             ng-show=\"vm.options.type === 'range'\"\n" +
    "             ng-style=\"{ 'left': vm.thumbPositions.upper, 'z-index': vm.thumbOrder.upper }\"\n" +
    "             ng-class=\"[vm.options.handles.style, vm.options.track.height]\"\n" +
    "             ng-mouseenter=\"vm.upperThumbState.hover = true\"\n" +
    "             ng-mouseleave=\"vm.upperThumbState.hover = false\">\n" +
    "\n" +
    "             <div class=\"tooltip top tooltip-upper\" \n" +
    "                  ng-style=\"{ 'opacity': vm.tooltipUpperVisible ? 1 : 0 }\">\n" +
    "\n" +
    "                    <div class=\"tooltip-arrow\" \n" +
    "                         ng-style=\"{'border-top-color': vm.options.handles.callout.background }\">\n" +
    "                    </div>\n" +
    "\n" +
    "                    <div class=\"tooltip-inner\" \n" +
    "                         ng-if=\"vm.options.type === 'range'\"\n" +
    "                         ng-style=\"{ 'background-color': vm.options.handles.callout.background, 'color': vm.options.handles.callout.color }\" \n" +
    "                         ng-bind=\"vm.options.handles.callout.formatter(vm.thumbUpperValue)\">\n" +
    "                    </div>\n" +
    "             </div>\n" +
    "        </div>\n" +
    "\n" +
    "        <div class=\"track-section track-higher\"\n" +
    "             ng-style=\"{ 'flex-grow': vm.trackSizes.higher, 'background': vm.trackColors.higher }\">\n" +
    "        </div>\n" +
    "\n" +
    "    </div>\n" +
    "\n" +
    "    <div class=\"tick-container\" \n" +
    "         ng-if=\"vm.options.track.ticks.major.show || vm.options.track.ticks.minor.show\"\n" +
    "         ng-class=\"{ 'show-labels': vm.options.track.ticks.major.labels || vm.options.track.ticks.minor.labels }\">\n" +
    "\n" +
    "            <div class=\"tick\" ng-repeat=\"tick in vm.ticks\" ng-class=\"::tick.type\" ng-style=\"::{ 'left': tick.position + '%' }\" ng-show=\"::tick.showTicks\">\n" +
    "                <div class=\"tick-indicator\"></div>\n" +
    "                <div class=\"tick-label\" ng-show=\"::tick.showLabels\" ng-bind=\"::tick.label\"></div>\n" +
    "            </div>\n" +
    "    </div>\n" +
    "</div>");
}]);

angular.module("socialChart/template/socialChart.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("socialChart/template/socialChart.html",
    "<div class=\"sigma-chart-maximise-control\" ng-if=\"sc.showMaximiseControl && sc.isFullscreen\" ng-style=\"sc.minimiseControlStyle\"\n" +
    "ng-mouseenter=\"sc.mouseEnterUIElement($event)\" ng-mouseleave=\"sc.mouseLeaveUIElement($event)\">\n" +
    "		<button class=\"btn btn-icon button-primary btn-lg btn-circular social-expand fullscreen\" type=\"button\" ng-click=\"sc.toggleFullscreen()\">\n" +
    "    		<div class=\"partition-close-icon\"></div>\n" +
    "  		</button>\n" +
    "</div>\n" +
    "\n" +
    "<div class=\"sigma-wrapper\" style=\"position:relative; height:100%;\">\n" +
    "	<div id=\"sigma-container\" ng-style=\"sc.style\">\n" +
    "	</div>\n" +
    "	<p ng-if=\"sc.isFullscreen && sc.showTitle\" class=\"sigma-chart-title\" ng-class=\"{'sigma-chart-title-visible': sc.updateTitle}\">{{sc.socialChartTitle}}</p>\n" +
    "	<div class=\"sigma-chart-actions\" ng-mouseenter=\"sc.mouseEnterUIElement($event)\" ng-mouseleave=\"sc.mouseLeaveUIElement($event)\">\n" +
    "		<ul>\n" +
    "			<li>\n" +
    "				<i class=\"hpe-icon hpe-link-top black-tooltip\" ng-click=\"sc.top()\" tooltip-html=\"sc.tooltipResetHtml\"\n" +
    "				tooltip-placement=\"right\" ></i>\n" +
    "			</li>\n" +
    "			<li>\n" +
    "				<i class=\"hpe-icon hpe-add black-tooltip\" ng-click=\"sc.zoomIn()\" tooltip=\"{{sc.localStrings.zoomIn}}\" tooltip-placement=\"right\"\n" +
    "				></i>\n" +
    "			</li>\n" +
    "			<li>\n" +
    "				<i class=\"hpe-icon hpe-subtract black-tooltip\" ng-click=\"sc.zoomOut()\" tooltip=\"{{sc.localStrings.zoomOut}}\" tooltip-placement=\"right\" \n" +
    "				></i>\n" +
    "			</li>\n" +
    "		</ul>\n" +
    "	</div>\n" +
    "\n" +
    "	<div class=\"sigma-chart-maximise-control\" ng-if=\"sc.showMaximiseControl && !sc.isFullscreen\" ng-style=\"sc.maximiseControlStyle\"\n" +
    "	ng-mouseenter=\"sc.mouseEnterUIElement($event)\" ng-mouseleave=\"sc.mouseLeaveUIElement($event)\">\n" +
    "		<button class=\"btn btn-icon button-primary btn-lg btn-circular social-expand\" type=\"button\" ng-click=\"sc.toggleFullscreen()\">\n" +
    "    		<div class=\"partition-fullscreen-icon\"></div>\n" +
    "  		</button>\n" +
    "	</div>\n" +
    "\n" +
    "	<div class=\"sigma-chart-popover node\" ng-class=\"sc.popoverPosition\" ng-if=\"sc.hoveredItem && sc.hoveredItem.node && sc.nodePopover\" ng-mouseleave=\"sc.leavePopover($event)\" ng-style=\"sc.nodePopoverStyle\" ng-click=\"sc.popoverClick()\">\n" +
    "		<div class=\"arrow\" ng-style=\"sc.popoverArrowStyle\"></div>\n" +
    "		<div ng-include=\"sc.nodePopover\"></div>\n" +
    "	</div>\n" +
    "	<div class=\"sigma-chart-popover edge\" ng-class=\"sc.popoverPosition\" ng-if=\"sc.hoveredItem && sc.hoveredItem.edge && sc.edgePopover\" ng-mouseleave=\"sc.leavePopover($event)\" ng-style=\"sc.edgePopoverStyle\" ng-click=\"sc.popoverClick()\">\n" +
    "		<div class=\"arrow\" ng-style=\"sc.popoverArrowStyle\"></div>\n" +
    "		<div ng-include=\"sc.edgePopover\"></div>\n" +
    "	</div>\n" +
    "\n" +
    "	<div class=\"sigma-chart-detail node\" ng-if=\"sc.selectedNode && sc.nodeDetail\" ng-style=\"sc.nodeDetailStyle\" ng-mouseenter=\"sc.mouseEnterUIElement($event)\"\n" +
    "	ng-mouseleave=\"sc.mouseLeaveUIElement($event)\">\n" +
    "		<div class=\"panel\" ng-style=\"sc.detailInlayStyle\">\n" +
    "			<span class=\"sigma-panel-close-icon\" ng-click=\"sc.closeDetail();\" ng-if=\"sc.showDetailCloseButton\"></span>\n" +
    "			<div ng-include=\"sc.nodeDetail\" ng-class=\"{'fullscreen-shadow':sc.isFullscreen}\"></div>\n" +
    "		</div>\n" +
    "	</div>\n" +
    "\n" +
    "	<div class=\"sigma-chart-detail edge\" ng-if=\"sc.selectedEdge && sc.edgeDetail\" ng-style=\"sc.edgeDetailStyle\" ng-mouseenter=\"sc.mouseEnterUIElement($event)\"\n" +
    "	ng-mouseleave=\"sc.mouseLeaveUIElement($event)\">\n" +
    "		<div class=\"panel\" ng-style=\"sc.detailInlayStyle\">\n" +
    "		<span class=\"sigma-panel-close-icon\" ng-click=\"sc.closeDetail();\" ng-if=\"sc.showDetailCloseButton\"></span>\n" +
    "			<div ng-include=\"sc.edgeDetail\" ng-class=\"{'fullscreen-shadow':sc.isFullscreen}\"></div>\n" +
    "		</div>\n" +
    "	</div>\n" +
    "\n" +
    "</div>\n" +
    "");
}]);

angular.module("sorters/detailRowHeader/template/detailRowHeader.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("sorters/detailRowHeader/template/detailRowHeader.html",
    "<div class=\"row\">\n" +
    "	<div class=\"{{header.class}} detail-row-header\" ng-repeat=\"header in vm.headers\" ng-class=\"{'clickable': header.sort, 'sort': vm.sortingActive(header.sort) }\" ng-click=\"vm.sort(header)\">\n" +
    "		<div class=\"title\" single-line-overflow-tooltip ng-bind=\"header.title\"></div>\n" +
    "		<div class=\"filter clickable\" ng-if=\"header.filter\" ng-click=\"$event.stopPropagation()\">\n" +
    "			<i class=\"hpe-icon hpe-caret-down\" aria-hidden=\"true\" detail-row-header-popover=\"header.filter\" ></i>\n" +
    "		</div>\n" +
    "		<div class=\"sort\">\n" +
    "			<i class=\"hpe-icon\" aria-hidden=\"true\" ng-class=\"vm.getSortIcon(header)\"></i>\n" +
    "			<p class=\"number\" ng-bind=\"vm.getSortOrder(header)\"></p>\n" +
    "		</div>\n" +
    "	</div>\n" +
    "</div>");
}]);

angular.module("sorters/multiSortableHeader/template/multiSortableHeader.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("sorters/multiSortableHeader/template/multiSortableHeader.html",
    "<tr class=\"multiSortHeader\">\n" +
    "\n" +
    "	<th ng-repeat=\"header in vm.headers\" class=\"header {{ ::header.fixedClass }}\"\n" +
    "		ng-class=\"{ 'text-center': header.center, 'clickable': header.sortable }\" \n" +
    "    	ng-click=\"vm.select(header)\">\n" +
    "		\n" +
    "		<p class=\"multiSortTitle\" ng-bind=\"header.sorterHeader\"></p>\n" +
    "\n" +
    "		<div class=\"multiSortContainer\">\n" +
    "    		<i class=\"hpe-icon text-muted sortableHeaderIcon\" ng-class=\"vm.columnData[header.sort] ? vm.columnData[header.sort].icon : ''\"></i>\n" +
    "        	<p class=\"multiSortNumber text-muted\" ng-bind=\"vm.columnData[header.sort] ? vm.columnData[header.sort].order : ''\"></p>\n" +
    "		</div>\n" +
    "\n" +
    "	</th>\n" +
    "</tr>\n" +
    "");
}]);

angular.module("sorters/sortDirectionToggle/template/sortDirectionToggle.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("sorters/sortDirectionToggle/template/sortDirectionToggle.html",
    "<div class=\"btn-group filter sort-direction-toggle\">\n" +
    "	<p ng-bind=\"label\"></p>\n" +
    "	<button data-toggle=\"dropdown\" ng-class=\"class\" class=\"filter-dropdown btn dropdown-toggle\" aria-expanded=\"false\" id=\"sortdropdown\">{{sdt.name}}\n" +
    "        <span class=\"hp-icon hp-chevron-down\"></span>\n" +
    "    </button>\n" +
    "    <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"sortdropdown\">\n" +
    "    	<li ng-repeat=\"sorter in sorters\" name=\"sorter.name\">\n" +
    "    		<a href=\"\" target=\"_blank\" ng-click=\"sdt.select(sorter)\">\n" +
    "    			<i ng-class=\"{invisible: sdt.name!==sorter.name}\" class=\"hpe-icon hpe-checkmark\"></i>\n" +
    "		        <span ng-bind=\"sorter.name\"></span>\n" +
    "		    </a>\n" +
    "    	</li>\n" +
    "    </ul>\n" +
    "	<i class=\"sort-icon hpe-icon text-muted\" ng-class=\"{'hpe-ascend': !sdt.descend, 'hpe-descend': sdt.descend}\" ng-click=\"sdt.toggle()\" ng-keypress=\"sdt.toggleKeypress($event)\" tabindex=\"0\"></i>\n" +
    "</div>");
}]);

angular.module("sorters/sorter/template/sorter.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("sorters/sorter/template/sorter.html",
    "<span class=\"sorter-container\">\n" +
    "<span class=\"sorter-title\" ng-bind=\"sorterTitle\"></span>\n" +
    "<div class=\"btn-group filter\">\n" +
    "    <button data-toggle=\"dropdown\" ng-class=\"class\" class=\"filter-dropdown btn dropdown-toggle\" aria-expanded=\"false\" \n" +
    "    id=\"btndropdown\">{{name}}<span class=\"hp-icon hp-chevron-down\"></span>\n" +
    "    </button>\n" +
    "    <ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"btndropdown\" ng-transclude ></ul>\n" +
    "</div>\n" +
    "</span>");
}]);

angular.module("sorters/sorterHeader/template/sortableHeader.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("sorters/sorterHeader/template/sortableHeader.html",
    "<th ng-repeat=\"header in vm.headers\" class=\"{{ ::header.fixedClass }}\" \n" +
    "    ng-class=\"{ 'text-center': header.center, 'clickable': header.sortable }\" \n" +
    "    ng-click=\"vm.select(header)\">\n" +
    "\n" +
    "    <p class=\"sortableHeader\" ng-bind=\"header.sorterHeader\"></p>\n" +
    "    <i class=\"hpe-icon text-muted sortableHeaderIcon\" ng-class=\"vm.getIcon(header)\"></i>\n" +
    "</th>");
}]);

angular.module("sorters/sorterOption/template/sorterOption.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("sorters/sorterOption/template/sorterOption.html",
    "<li>\n" +
    "    <a href=\"\" target=\"_blank\" ng-click=\"soc.select()\">\n" +
    "        <i ng-class=\"{invisible: !selectedClass}\" class=\"hpe-icon hpe-checkmark sorter-icon\"></i>\n" +
    "        <p class=\"sorter-text\"><span ng-bind=\"soc.name\"></span></p>\n" +
    "        <i class=\"sorter-icon\" ng-class=\"iconClass\"></i>\n" +
    "    </a>\n" +
    "</li> \n" +
    "");
}]);

angular.module("spark/template/spark.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("spark/template/spark.html",
    "<div>\n" +
    "    <div ng-if=\"sc.inline === true\">\n" +
    "        <div class=\"spark-label-left\">\n" +
    "            <div ng-bind-html=\"sc.label\"></div>\n" +
    "        </div>\n" +
    "        <div class=\"inline-block spark-line\">\n" +
    "            <div>\n" +
    "                <div class=\"inline-block\" ng-if=\"sc.topLeftLabel\" ng-bind-html=\"sc.topLeftLabel\"></div>\n" +
    "                <div class=\"align-right inline-block\" ng-if=\"sc.topRightLabel\" ng-bind-html=\"sc.topRightLabel\" class=\"text-right\"></div>\n" +
    "            </div>\n" +
    "            <div class=\"spark\" ng-class=\"[ 'inline', sc.type ]\" ng-style=\"sc.setPosition\" tooltip=\"{{sc.sparkTooltip}}\">\n" +
    "                <div class=\"progress-bar fill\" aria-valuenow=\"{{sc.value}}\" aria-valuemin=\"0\"\n" +
    "                     aria-valuemax=\"100\" ng-style=\"{width: (sc.value < 100 ? sc.value : 100) + '%'}\"\n" +
    "                     aria-valuetext=\"sc.label\"></div>\n" +
    "            </div>\n" +
    "            <div>\n" +
    "                <div class=\"inline-block\" ng-if=\"sc.bottomLeftLabel\" ng-bind-html=\"sc.bottomLeftLabel\"></div>\n" +
    "                <div class=\"align-right inline-block\" ng-if=\"sc.bottomRightLabel\" ng-bind-html=\"sc.bottomRightLabel\" class=\"text-right\"></div>\n" +
    "            </div>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "\n" +
    "    <div ng-if=\"sc.inline === false\">\n" +
    "        <div>\n" +
    "            <div class=\"inline-block\" ng-if=\"sc.topLeftLabel\" ng-bind-html=\"sc.topLeftLabel\"></div>\n" +
    "            <div class=\"align-right inline-block\" ng-if=\"sc.topRightLabel\" ng-bind-html=\"sc.topRightLabel\" class=\"text-right\"></div>\n" +
    "        </div>\n" +
    "        <div class=\"spark\" ng-class=\"sc.type\" ng-style=\"{height: sc.fillheight + 'px'}\" tooltip=\"{{sc.sparkTooltip}}\">\n" +
    "            <div class=\"progress-bar fill\" aria-valuenow=\"{{sc.value}}\" aria-valuemin=\"0\"\n" +
    "                 aria-valuemax=\"100\" ng-style=\"{width: (sc.value < 100 ? sc.value : 100) + '%'}\"\n" +
    "                 aria-valuetext=\"sc.top-left-label\"></div>\n" +
    "        </div>\n" +
    "        <div>\n" +
    "            <div class=\"inline-block\" ng-if=\"sc.bottomLeftLabel\" ng-bind-html=\"sc.bottomLeftLabel\"></div>\n" +
    "            <div class=\"align-right inline-block\" ng-if=\"sc.bottomRightLabel\" ng-bind-html=\"sc.bottomRightLabel\" class=\"text-right\"></div>\n" +
    "        </div>\n" +
    "    </div>\n" +
    "</div>");
}]);

angular.module("splitter/templates/splitter.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("splitter/templates/splitter.html",
    "<div class=\"splitter\" ng-transclude></div>\n" +
    "");
}]);

angular.module("splitter/templates/splitterPanel.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("splitter/templates/splitterPanel.html",
    "<div class=\"splitter-panel\" ng-transclude></div>\n" +
    "");
}]);

angular.module("tagInput/template/customAutocompleteTemplate.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("tagInput/template/customAutocompleteTemplate.html",
    "<div class=\"custom-autocomplete-template\">\n" +
    "          <span class=\"tags-text-bold\" ng-bind-html=\"$highlight($getDisplayText())\"><b></b></span>\n" +
    "          <span class=\"tags-text-small\">({{data.position}})</span>\n" +
    "          <br>\n" +
    "          <span class=\"tags-text-small\">{{data.email}}</span>\n" +
    "      </div>");
}]);

angular.module("tagInput/template/tagInput.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("tagInput/template/tagInput.html",
    "<div>\n" +
    "	<tags-input \n" +
    "		ng-model=\"ti.tags\"\n" +
    "		key-property=\"{{ti.keyProperty}}\"\n" +
    "		display-property=\"{{ti.displayProperty}}\"\n" +
    "		tabindex=\"{{ti.tabIndex}}\"\n" +
    "		placeholder=\"{{ti.placeholder}}\"\n" +
    "		min-length=\"{{ti.minTagLength}}\"\n" +
    "		max-length=\"{{ti.maxTagLength}}\"\n" +
    "		min-tags=\"{{ti.minNumberTags}}\"\n" +
    "		max-tags=\"{{ti.maxNumberTags}}\"\n" +
    "		add-on-space=\"{{ti.addOnSpace}}\"\n" +
    "		add-on-comma=\"{{ti.addOnComma}}\"\n" +
    "		add-on-blur=\"{{ti.addOnBlur}}\"\n" +
    "		add-on-paste=\"{{ti.addOnPaste}}\"\n" +
    "		paste-split-pattern=\"{{ti.pasteSplitPattern}}\"\n" +
    "		replace-spaces-with-dashes=\"false\"\n" +
    "		enable-editing-last-tag=\"{{ti.enableEditingLastTag}}\"\n" +
    "		add-from-autocomplete-only=\"{{ti.addFromAutocompleteOnly}}\"\n" +
    "		on-tag-adding=\"ti.onTagAdding($tag)\"\n" +
    "		on-tag-added=\"ti.onTagAdded($tag)\"\n" +
    "		on-invalid-tag=\"ti.onInvalidTag($tag)\"\n" +
    "		on-tag-removing=\"ti.onTagRemoving($tag)\"\n" +
    "		on-tag-removed=\"ti.onTagRemoved($tag)\"\n" +
    "		on-tag-clicked=\"ti.onTagClicked($tag)\"\n" +
    "		template=\"{{ti.template}}\"\n" +
    "		max-tags-hidden=\"{{ti.maxTagsHidden}}\"\n" +
    "		>\n" +
    "\n" +
    "		<auto-complete \n" +
    "			ng-if=\"ti.autocomplete\"\n" +
    "			source=\"ti.source($query) || ti.loadTags($query)\"\n" +
    "			displayProperty=\"{{ti.displayProperty}}\"\n" +
    "			debounce-delay=\"{{ti.autocompleteDelay}}\"\n" +
    "			min-length=\"{{ti.autocompleteMinLength}}\"\n" +
    "			select-first-match=\"{{ti.selectFirstMatch}}\"\n" +
    "			template=\"{{ti.autocompleteTemplate}}\"\n" +
    "			>\n" +
    "		</auto-complete>\n" +
    "\n" +
    "	</tags-input>\n" +
    "	<p class=\"text-warning\" ng-show=\"ti.showMessage\" ng-bind=\"ti.maxTagsMessage\"></p>\n" +
    "</div>");
}]);

angular.module("treeView/template/_partial.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("treeView/template/_partial.html",
    "<div class=\"tree-node tree-node-content\" data-nodrag ng-click=\"tv.select(this)\" ng-class=\"{highlight : tv.isSelected(this)}\" >\n" +
    "\n" +
    "<a class=\"btn btn-link button-secondary btn-icon btn-sm toggle chevron\" ng-if=\"node.allowChildren\" ng-disabled=\"!node.nodes || node.nodes.length <= 0\" ng-click=\"toggle(this); $event.preventDefault(); $event.stopPropagation(); this.blur();\" tabIndex=\"0\" href>\n" +
    "  <span\n" +
    "    class=\"hpe-icon\"\n" +
    "    ng-class=\"{\n" +
    "      'hpe-next': collapsed,\n" +
    "      'hpe-down': !collapsed || (!node.nodes || node.nodes.length <= 0)\n" +
    "    }\">\n" +
    "    </span>\n" +
    "</a>\n" +
    "<span ng-if=\"!node.allowChildren\" style=\"padding-left: 17px;\"></span>\n" +
    "\n" +
    "<span class=\"icon\"><i class=\"hpe-icon\" ng-class=\"tv.getIcon(node.type, collapsed)\"></i><span class=\"sr-only\" ng-bind=\"node.type\"></span></span>\n" +
    "\n" +
    "<span class=\"title-readonly\" ng-click=\"tv.edit(this); $event.preventDefault(); $event.stopPropagation();\" ng-show=\"!tv.isBeingEdited(this)\" tabIndex=\"0\" ng-keydown=\"tv.keyboardSelect(this,$event);\">{{node.title}}</span>\n" +
    "<input class=\"title-edit\" ng-click=\"tv.edit(this); $event.preventDefault(); $event.stopPropagation();\" ng-keypress=\"tv.finishEdit(this,$event)\" ng-blur=\"tv.finishEdit(this,$event)\"\n" +
    "ng-show=\"tv.isBeingEdited(this)\" ng-model=\"node.title\" focus-on-show tabIndex=\"0\">\n" +
    "\n" +
    "<a class=\"pull-right btn btn-link btn-icon button-secondary btn-xs tree-action-button\" ng-show=\"tv.inlineEdit && tv.canDeleteItem(this)\" data-nodrag ng-click=\"tv.remove(this); $event.preventDefault(); $event.stopPropagation();\" tabIndex=\"0\">\n" +
    "  <span class=\"hpe-icon hpe-close\"></span>\n" +
    "</a>\n" +
    "\n" +
    "<a class=\"pull-right btn btn-link btn-icon button-secondary btn-xs tree-action-button\" ng-show=\"tv.inlineEdit && tv.canAddItem(this)\" data-nodrag ng-click=\"tv.newSubItem(this, true); expand(this); $event.preventDefault(); $event.stopPropagation();\" tabIndex=\"0\">\n" +
    "  <span class=\"hpe-icon hpe-add\"></span>\n" +
    "</a>\n" +
    "\n" +
    "</div>\n" +
    "\n" +
    "<ol ui-tree-nodes=\"\" ng-model=\"node.nodes\" ng-class=\"{hidden: collapsed}\">\n" +
    "	<li ng-repeat=\"node in node.nodes\" ui-tree-node ng-include=\"'treeView/template/_partial.html'\"></li>\n" +
    "</ol>\n" +
    "");
}]);

angular.module("treeView/template/treeView.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("treeView/template/treeView.html",
    "<div ui-tree ng-init=\"tv.init(this)\" ng-class=\"{'show-tree-outline' : tv.treeOptions.showTreeLines}\">\n" +
    "  <ol ui-tree-nodes=\"\" ng-model=\"data\">\n" +
    "        <li ng-repeat=\"node in data\" ui-tree-node ng-include=\"'treeView/template/_partial.html'\">\n" +
    "        </li>\n" +
    "  </ol>\n" +
    "</div> ");
}]);

angular.module("wizard/template/step.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("wizard/template/step.html",
    "<li ng-class=\"{current: active, disabled: disabled, done: done, error:error}\"  aria-disabled=\"{{disabled}}\" aria-selected=\"{{active}}\">\n" +
    "  <a href ng-click=\"select()\" aria-controls=\"{{id}}\">{{index}}. <span step-heading-transclude>{{heading}}</span></a>\n" +
    "</li>");
}]);

angular.module("wizard/template/wizard.html", []).run(["$templateCache", function($templateCache) {
  $templateCache.put("wizard/template/wizard.html",
    "<div class=\"wizard clearfix\" role=\"application\">\n" +
    "  <div class=\"steps clearfix\">\n" +
    "    <ul role=\"tablist\" ng-transclude></ul>\n" +
    "  </div>\n" +
    "  <div class=\"content\">\n" +
    "    <div class=\"body hide\" aria-labelledby=\"step.id\"\n" +
    "         ng-repeat=\"step in wzrd.steps\" \n" +
    "         ng-class=\"{show: step.active}\"\n" +
    "         step-content-transclude=\"step\">\n" +
    "    </div>\n" +
    "  </div>\n" +
    "  <div class=\"actions\">\n" +
    "    <ul role='menu'>\n" +
    "      <li>\n" +
    "        <a href role=\"menuitem\" class=\"btn button-secondary\" ng-class=\"{disabled:!wzrd.buttonOptions.previousEnabled}\" ng-click=\"wzrd.previous()\" tooltip=\"{{wzrd.buttonOptions.previousTooltip}}\" \n" +
    "        ng-show=\"wzrd.buttonOptions.showPrevious\" tabindex=\"{{wzrd.buttonOptions.previousTabIndex}}\">\n" +
    "          {{wzrd.buttonOptions.previousText}}\n" +
    "        </a>\n" +
    "      </li>\n" +
    "      <li>\n" +
    "        <a href role=\"menuitem\" class=\"btn button-primary\"  ng-class=\"{hide:!wzrd.nextShow,show:wzrd.nextShow,disabled:!wzrd.buttonOptions.nextEnabled}\" ng-click=\"wzrd.next()\" tooltip=\"{{wzrd.buttonOptions.nextTooltip}}\"\n" +
    "        ng-show=\"wzrd.buttonOptions.showNext\" tabindex=\"{{wzrd.buttonOptions.nextTabIndex}}\">\n" +
    "          {{wzrd.buttonOptions.nextText}}\n" +
    "        </a></li>\n" +
    "      <li>\n" +
    "        <a href role=\"menuitem\" class=\"btn button-primary\"  ng-class=\"{hide:!wzrd.finishShow,show:wzrd.finishShow || wzrd.buttonOptions.alwaysShowFinish,disabled:!wzrd.buttonOptions.finishEnabled}\" ng-click=\"wzrd.finish()\" tooltip=\"{{wzrd.buttonOptions.finishTooltip}}\" ng-show=\"wzrd.buttonOptions.showFinish || wzrd.buttonOptions.alwaysShowFinish\" tabindex=\"{{wzrd.buttonOptions.finishTabIndex}}\">\n" +
    "          {{wzrd.buttonOptions.finishText}}\n" +
    "        </a>\n" +
    "      </li>\n" +
    "      <li>\n" +
    "        <a href role=\"menuitem\" class=\"btn button-secondary\"  ng-click=\"wzrd.cancel()\" tooltip=\"{{wzrd.buttonOptions.cancelTooltip}}\"\n" +
    "        ng-show=\"wzrd.showingCancel\">\n" +
    "          {{wzrd.buttonOptions.cancelText}}\n" +
    "        </a>\n" +
    "      </li>\n" +
    "    </ul>\n" +
    "  </div>\n" +
    "</div>");
}]);
;
